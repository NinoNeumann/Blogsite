{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/fonts/NinoNuemann.ttf","path":"fonts/NinoNuemann.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/digit-lg.png","path":"img/digit-lg.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/digit-md.png","path":"img/digit-md.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/digit-sm.png","path":"img/digit-sm.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/digit-xs.png","path":"img/digit-xs.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/categoryBar.js","path":"js/categoryBar.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/flipcountdown.js","path":"js/flipcountdown.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/floatpanel.js","path":"js/floatpanel.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/github-calendar.min.js","path":"js/github-calendar.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/grayscale.js","path":"js/grayscale.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/inject_calender.js","path":"js/inject_calender.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/randombg.js","path":"js/randombg.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/runtime.js","path":"js/runtime.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"711490d153285a1bfd3a7cc0b9593f326be39cbc","modified":1679559590835},{"_id":"source/_posts/CMU15445-learning.md","hash":"fc8a3a892e0521760267384bf37375f73f6566c6","modified":1681214466789},{"_id":"source/_posts/hello-world.md","hash":"f62bd671ddc78df048330f088d58782e42e841a7","modified":1681214462837},{"_id":"source/_posts/hexo-外挂标签模板-速查.md","hash":"dba657b99d5496cbf15219e83010d572c5c1dc67","modified":1682218887152},{"_id":"source/_posts/acwing算法每日一题记录.md","hash":"0cda7b229afd454f19f0664bc93935460e4b1af9","modified":1682256263024},{"_id":"source/_posts/my-pat-learning.md","hash":"fff1a16de1566dfe6551e7173117c61fdd44a5f4","modified":1682256277234},{"_id":"source/_posts/考研二战-DS整理复习.md","hash":"7e03d15aab8c1ef74a8b7309ac8ba67bf7360a2d","modified":1682236397863},{"_id":"source/_posts/考研数学（概率论部分，第一章）学习.md","hash":"b236ef0bde28ae4dccda25df8e1a102e64069255","modified":1681540656993},{"_id":"source/_posts/考研数学（概率论部分，第三章）学习.md","hash":"a3ea4ad935a187a61bb370a232d952447e7362d5","modified":1682147914547},{"_id":"source/_posts/考研数学（概率论部分，第二章）学习.md","hash":"1fb50ac797da16cf92023f728535ce7df8a75ecc","modified":1681958737910},{"_id":"source/_posts/c-中的输入.md","hash":"28e68a6245f7eb9fa4fa8b3f665c81ef769e5be2","modified":1681214471574},{"_id":"source/_posts/考研数学（概率论部分，第四章）学习.md","hash":"80e2ad8c6e89845d6f6a8d739afdebf1240432d0","modified":1682257249291},{"_id":"source/_posts/考研数学（高数部分，第一章）复习.md","hash":"a8c08c789fb0f499616efbfd31ce3d917c5680aa","modified":1681802697646},{"_id":"source/_posts/考研数学（高数部分，第七章）学习.md","hash":"b8c6b2dd10aaf12eb7e9513c96efea4dbfcaaf05","modified":1681715467537},{"_id":"source/_posts/考研数学（高数部分，第三章）复习.md","hash":"dec5483266123b1b5175eafa3ccb3c430df6f32f","modified":1681709646493},{"_id":"source/_posts/考研数学（高数部分，第二章）复习.md","hash":"47c349b1e438269645a116680485ab32e6d0ca5e","modified":1682059657384},{"_id":"source/_posts/考研数学（高数部分，第五章）复习.md","hash":"f1f6ca6ffab208a4424a7633332449d6edb273fe","modified":1682062330650},{"_id":"source/_posts/考研数学（高数部分，第四章）复习.md","hash":"6f57e985a6485ba0c177dbb75e488c57e1eac27d","modified":1682046935783},{"_id":"source/archives/index.md","hash":"6d445ff85b9874670d90ffb13656510bff3d6042","modified":1679453700401},{"_id":"source/categories/index.md","hash":"48b4ce345b3266cf317f3a9d59625dd38d813a9b","modified":1679629407982},{"_id":"source/tags/index.md","hash":"886f1978a49515453c960f1e245675d4ebcebb38","modified":1679629403323},{"_id":"source/link/index.md","hash":"177318a81e04e6fa2b1b0d5426d45f2e4af82f6d","modified":1679453725231},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1676882261209},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"c34579d9d7239828ce7d8abc235521eaf4ea9e17","modified":1676882261464},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"25cfdbaf9883095322259c4f49bd08f0a7cffa0e","modified":1676882261460},{"_id":"node_modules/hexo-theme-butterfly/package-lock.json","hash":"c6eab0bc7873916bb5f59ecf717a13cc6af6960c","modified":1679564837522},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"c01ba979de99265effade6aad41c1d49a10b5223","modified":1679564837514},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"ee8d1240372fc90e2666759088ad0c5375666d74","modified":1676882261573},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"e889eabdf04a9fcf0bb14e914f7c3b394dc6532c","modified":1681525678269},{"_id":"node_modules/hexo-theme-butterfly/.idea/hexo-theme-butterfly.iml","hash":"402e38def734b476c4c697c9a36892567ab6af8b","modified":1679443905592},{"_id":"node_modules/hexo-theme-butterfly/.idea/.gitignore","hash":"2e8e3f2c21083bfc1741db5df016b198b53ae6ad","modified":1679443905852},{"_id":"node_modules/hexo-theme-butterfly/.idea/misc.xml","hash":"2b0148a6c3c6fe5962a1ba2b12656c9f346f26bb","modified":1679443905671},{"_id":"node_modules/hexo-theme-butterfly/.idea/modules.xml","hash":"b45cb30e0a3d63976eaae35e4cee9857ea52588c","modified":1679443905625},{"_id":"node_modules/hexo-theme-butterfly/.idea/vcs.xml","hash":"c75f6a9f73d6a593959bbeeb5c8d00a5d919408c","modified":1679443905702},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"9b9c5b8158d1296c64a354e57a3b0b809575a77d","modified":1676882261572},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"e0e52a7ba52fa70c3557f00ddf681f66098ac8b7","modified":1676882261572},{"_id":"node_modules/hexo-theme-butterfly/.idea/workspace.xml","hash":"a983fbda6a8a86276fef014fb1b3392987fa5a68","modified":1682256935692},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"0b994863599d62c56d2bc50d20b94332ed9d98cf","modified":1676882261574},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"5b9ce449bd4f7e3ba46131546e75976efe31a1f6","modified":1676882261574},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1676882261467},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"c1847753ace8e30ccd29a5c1f2684344ef7af745","modified":1679981153566},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"4d1f400c90be856676fd9850b6b85a63f6b399db","modified":1679652415899},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1676882261500},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1676882261507},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1676882261512},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1676882261571},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1676882261572},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1676882261572},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1676882261573},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"d1bf03af239d94a8f03e040ef4dd5ea6334a48fd","modified":1676882261466},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1676882261573},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/categoryBar.pug","hash":"568fb5c58317735efed63595e22891dcfa43140e","modified":1680592293975},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1676882261465},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1676882261487},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"a8720f01c429c839149d7f5991c49541011f4796","modified":1676882261493},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"bb45b395d530d2930c79555432e398c142d4a16f","modified":1676882261496},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1676882261501},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1676882261512},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1676882261300},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"83a1f2d31792206d432e8e2041e284d88327c02e","modified":1676882261511},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"f5cbd41c6afb49639b59ab5ad659da0d3b7f25dd","modified":1676882261399},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1676882261400},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"3ace1139182d3d367149db138990891427f3356e","modified":1676882261402},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1676882261428},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1676882261459},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1676882261427},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"d1a5b26c8239189493c1f7d8fd0b8f8ec3d11eaa","modified":1676882261428},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1676882261306},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1676882261306},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1676882261400},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"c2d4d0537f9aed4eba2bb3d093ad89ca9e80cff9","modified":1676882261413},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1676882261428},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1676882261307},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"f92dc2116776ac897b913130b574f1c78491bc76","modified":1676882261427},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1676882261401},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"fc0b813452a705911af37b891513ae50a8795710","modified":1676882261401},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1676882261401},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1676882261413},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1676882261414},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1676882261426},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1676882261427},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1676882261429},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1676882261430},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"38c5e8380f4d7b8ed40791bfca46d74bcdc7ef5a","modified":1679446783335},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"e018dad9f674fc5564112b99032fe5fe8b2d195f","modified":1676882261552},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1676882261299},{"_id":"node_modules/hexo-theme-butterfly/source/img/digit-md.png","hash":"e09b4c968f0921731982b37b148fec6f3a049ca5","modified":1603891308000},{"_id":"node_modules/hexo-theme-butterfly/source/img/digit-sm.png","hash":"2b32341d8b6b7f33b7e55d4068785ec389091ae2","modified":1603891308000},{"_id":"node_modules/hexo-theme-butterfly/source/img/digit-xs.png","hash":"eb2aeeeb7cf6888dd1a4cb47fd484677b431a124","modified":1603891308000},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1676882261464},{"_id":"node_modules/hexo-theme-butterfly/source/js/categoryBar.js","hash":"1e57c3c48a8a5531510f57359840294a5ad56bc1","modified":1679652145740},{"_id":"node_modules/hexo-theme-butterfly/source/js/flipcountdown.js","hash":"30e7ee1ac4de6df7a51a410da8469b7dd3293e93","modified":1603891308000},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1676882261282},{"_id":"node_modules/hexo-theme-butterfly/source/js/floatpanel.js","hash":"ee21e1868c349b7cc96a5f693acf468911540091","modified":1679459950477},{"_id":"node_modules/hexo-theme-butterfly/source/js/github-calendar.min.js","hash":"249391735d6d890ea957d4a5ff7a086865d9b055","modified":1679582315682},{"_id":"node_modules/hexo-theme-butterfly/source/js/grayscale.js","hash":"cbbb8578a6a955b6c9609205ef20225c32132b0c","modified":1680594559058},{"_id":"node_modules/hexo-theme-butterfly/source/js/inject_calender.js","hash":"10e92ece90ff31ebf5f50d7731d730962dae8f76","modified":1679650875098},{"_id":"node_modules/hexo-theme-butterfly/source/js/randombg.js","hash":"3bc709fbbd8642f9a24e010279347bfaa051b370","modified":1681393430933},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"c0a3093c2485fa2121c10741e256170f211c7398","modified":1676882261426},{"_id":"node_modules/hexo-theme-butterfly/source/js/runtime.js","hash":"2e301caba36657ddc386111f525132a4ac947835","modified":1603897608000},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"76d0c5c172cae44b34b0bd3125fd068b2c3cbd4a","modified":1676882261448},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"0c1551ef80bbece550fe520d91e21f083cbc14fe","modified":1676882261494},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"c9b4d8ec10a74f29cf1f9c4275f0cae3bd93b427","modified":1676882261459},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1676882261498},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"c72be46dadef859681c87b9fca27590dee255594","modified":1676882261499},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1676882261506},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1676882261512},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1676882261500},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1676882261466},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"428e3c39053b44760463682848f2eae238ff9d64","modified":1676882261478},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1676882261477},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1676882261489},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1676882261499},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1676882261507},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1676882261507},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1676882261512},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"c4b86758f3a3deae4612c31d725814c8753a7804","modified":1676882261488},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1676882261494},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"278855fe4399489bdef0393697bb87420e671fe9","modified":1676882261500},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1676882261473},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"43b23f4ef8264093ebe1d0a759c7d5605f4d30e2","modified":1679632830459},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1676882261476},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1676882261478},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"a59bcfbb609a099c1bf5be40b7a94e7e2b06fc4a","modified":1676882261487},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1676882261513},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1676882261506},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1676882261511},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1676882261467},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1676882261486},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1676882261501},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"fc0b09068009edd4026d90a669608cbe211aeecf","modified":1676882261505},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1676882261507},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"35223531f8e086d57caec2d17d45ddbcb39deb74","modified":1676882261512},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1676882261473},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1676882261473},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1676882261473},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1676882261474},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1676882261474},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1676882261474},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1676882261475},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1676882261475},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1676882261475},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1676882261475},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1676882261476},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1676882261476},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1676882261495},{"_id":"node_modules/hexo-theme-butterfly/source/css/_custom/categoryBar.css","hash":"4025151a966d3a07f5ff97c43892d0974cd7f09b","modified":1679651679630},{"_id":"node_modules/hexo-theme-butterfly/source/css/_custom/flipcountdown.css","hash":"82a8b25b5ad61fcdb03aafe8ebd43104369f82ec","modified":1679454406470},{"_id":"node_modules/hexo-theme-butterfly/source/css/_custom/github-calendar-responsive.css","hash":"4da882edd7e695c0d4d898392ed450def1fa3e2f","modified":1679639306179},{"_id":"node_modules/hexo-theme-butterfly/source/css/_custom/heoMainColor.css","hash":"f7905aac978854330e9039efb3f2795ed8cbe877","modified":1679651638120},{"_id":"node_modules/hexo-theme-butterfly/source/css/_custom/main_style.css","hash":"5a238b5975665932a72e31ac5c1132408e70f07d","modified":1681524840229},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"336b7ac54b66a1d70baa9bde51d1a5aca92f451e","modified":1676882261537},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"7fdfbe8f97b41588bbd5c6f27e7e85a881b28954","modified":1676882261533},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1676882261537},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1676882261551},{"_id":"node_modules/hexo-theme-butterfly/source/css/_index_card_style/homepage.styl","hash":"bb470da1d2ba292cae0a30a252f82f37c4130d2d","modified":1679629529712},{"_id":"node_modules/hexo-theme-butterfly/source/css/_index_card_style/slidecard.styl","hash":"67135df2f12e6d11b9e3825deb43876d8c3935ac","modified":1681525013713},{"_id":"node_modules/hexo-theme-butterfly/source/css/_index_card_style/multicard.styl","hash":"20b6918f0811b0acf2024893816054b70baab6f1","modified":1679629243810},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"52763ef97c7146d27eb06f35007ed6e269e089ca","modified":1679460097982},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1676882261525},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1676882261526},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"83553445fbc92cad4ad220fbd87b4c3db958c32a","modified":1676882261533},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"45d71dbb2a61e30989851ba29bb8be7094574d14","modified":1676882261534},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1676882261542},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"23db4e3cab68fed78601fc8a9c39ff5753bcc716","modified":1676882261542},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1676882261539},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1676882261542},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1676882261543},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1676882261549},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1676882261550},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"56389925671c7e8da0c033769421269e15e8f795","modified":1676882261552},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"a92984f566c97bb4179f34be79240af1552c6f17","modified":1676882261527},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1676882261520},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"ffea9e7c1543edcf080381e7b99828954c2f2cef","modified":1676882261542},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1676882261521},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1676882261525},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1676882261526},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"564d9ecaf299375a4440d4fefed964e5bcf89f8f","modified":1679630543025},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1676882261532},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1676882261551},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"7fdbe79b6c98157706be016f990ab3501bd796b1","modified":1676882261521},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"39d61cbe0c1e937f83ba3b147afaa29b4de2f87d","modified":1676882261538},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"86f3962a6ea11b2951b4ddb6424fda5e95ec962a","modified":1676882261540},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1676882261533},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1676882261525},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1676882261534},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1676882261534},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1676882261539},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1676882261539},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1676882261541},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1676882261551},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1676882261552},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1676882261210},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"5f4294337c28324e088908ed0ceb237a2a360ae5","modified":1676882261306},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"ee86f52bb6558c51a6f31402c2e4ec1dcb81bb55","modified":1676882261414},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"99d9b17668260b242749c16851d9ec1024d31899","modified":1676882261467},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1676882261494},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"58406a7a3bf45815769f652bf3ef81e57dcd07eb","modified":1676882261513},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1676882261479},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"b2aadea7351fae8382b8c2a3b9de810d922b0ec1","modified":1676882261487},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1676882261519},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1676882261477},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1676882261508},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"55acc455ca8e13211e3906cf78e487cc92accee5","modified":1676882261520},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1676882261478},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"0611d9216f4c128ebdea4cc21454c3dc4a6398d5","modified":1676882261494},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1676882261489},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1676882261478},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"ccb7d8ce3ded7364f9a15334b68ad73869fca757","modified":1676882261498},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1676882261513},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"95738f110598f999d627234e78ff9e9decac1b9b","modified":1676882261468},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"3ba842bf4801b2f115c2cfe5657f35a732ce589f","modified":1676882261480},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"8ec24c1939895ac0db2b2e8700bc9307b4ceb53c","modified":1676882261479},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"1c3a87393cb49915940c2dd206356c2a16549767","modified":1676882261488},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"eefdaa94956adc7a3ca90dd8edcd70a7574b439c","modified":1676882261486},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1676882261496},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"351fe25fbf02635b1f9e86e5e244c7d61f69baa7","modified":1676882261494},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"591ef23c583690bd74af0cafb09af64ba5bd8151","modified":1676882261488},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"e18fbd88d8942e53e771f29b26209ab735c5c567","modified":1676882261513},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"e9bdf80d6796afc04eb809dbbe780d97f22c7fcd","modified":1676882261508},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1676882261497},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1676882261518},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1676882261520},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1676882261495},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1676882261519},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"1c846c8d51649b8554d91536323eaeb20c8fc236","modified":1676882261498},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1676882261496},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"c12c898b35dd014780c1f3220ddbe12e7270983c","modified":1676882261472},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"8e33aca36a4d3ae9e041ba05ced8eff56ae38f77","modified":1676882261498},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1676882261495},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1676882261479},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1676882261489},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"233907dd7f5b5f33412701d2ccffbc0bbae8707b","modified":1676882261513},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"ab167c00da4506f591b96f0591bf5bd214a26d4b","modified":1676882261510},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1676882261519},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"441d87067d87d9996b53b25c05b8e620bd94b027","modified":1676882261520},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"e8245d0b4933129bb1c485d8de11a9e52e676348","modified":1676882261466},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"178c9cdcc4ce5a006885b24ce4a3d624e4734899","modified":1676882261497},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1676882261495},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1676882261465},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1676882261495},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1676882261466},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1676882261511},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1676882261527},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1676882261538},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1676882261528},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1676882261538},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1676882261539},{"_id":"node_modules/hexo-theme-butterfly/source/img/digit-lg.png","hash":"a9518a4025d2c2db68210494ae518fa67ff5ad63","modified":1603891308000},{"_id":"node_modules/hexo-theme-butterfly/source/fonts/NinoNuemann.ttf","hash":"2357da9903fae0a9864ab208f01c705063d03542","modified":1679444667171},{"_id":"public/archives/index.html","hash":"fe65709bd96a5a53b3de573326099004c72a47aa","modified":1682257844445},{"_id":"public/categories/index.html","hash":"e19b30041098a854bc41acfef4bb7ebea07a7384","modified":1682257844445},{"_id":"public/tags/index.html","hash":"16745c511f52030315918a98bb1f2780f1f8cdba","modified":1682257844445},{"_id":"public/link/index.html","hash":"07a6eb5901f96c3b9093774c5cc0347cf3c7918b","modified":1682257844445},{"_id":"public/2023/04/22/考研数学（概率论部分，第四章）学习/index.html","hash":"1558fbeaa7857496ef886dd02b29980558fc2872","modified":1682257844445},{"_id":"public/2023/04/21/考研数学（高数部分，第五章）复习/index.html","hash":"8b241d42b45b5907eca44f6558955ae0403b0ea4","modified":1682257844445},{"_id":"public/2023/04/21/考研数学（高数部分，第四章）复习/index.html","hash":"1c66247910addc7bdb389da323e002fabc7a67f7","modified":1682257844445},{"_id":"public/2023/04/20/考研数学（概率论部分，第三章）学习/index.html","hash":"cfef9dac26786dd7557bff9a74f9f8a068092e64","modified":1682257844445},{"_id":"public/2023/04/17/考研数学（高数部分，第七章）学习/index.html","hash":"43237db2cc326d4d815a998ce93d4da6cc9be8ee","modified":1682257844445},{"_id":"public/2023/04/15/考研数学（概率论部分，第二章）学习/index.html","hash":"3c592e12df7cb317ab272a3d1e5f6dfc0220fe18","modified":1682257844445},{"_id":"public/2023/04/15/考研数学（高数部分，第三章）复习/index.html","hash":"239bbad3ee0f1cf2355c7ae8d02c2c10ce24ac8c","modified":1682257844445},{"_id":"public/2023/04/13/考研数学（高数部分，第二章）复习/index.html","hash":"3dfd4c7d960ccd83d529f72780ae57a64617944c","modified":1682257844445},{"_id":"public/2023/04/11/考研数学（概率论部分，第一章）学习/index.html","hash":"eadbe84e588b8d99ad15c53693b20015dc3d9f4c","modified":1682257844445},{"_id":"public/2023/04/09/acwing算法每日一题记录/index.html","hash":"3cf2202f4ab34e5122bf52ff198feea6cbf70acf","modified":1682257844445},{"_id":"public/2023/04/02/考研数学（高数部分，第一章）复习/index.html","hash":"b86b391a16dd38ece6e5cec984b6a063d9f9d068","modified":1682257844445},{"_id":"public/2023/03/30/考研二战-DS整理复习/index.html","hash":"60a88218828f2f4ec9ee80c1194030ecced1d122","modified":1682257844445},{"_id":"public/2023/03/29/c-中的输入/index.html","hash":"8fa7217faf024821f6776c08c16eacbbe5b9980e","modified":1682257844445},{"_id":"public/2023/03/28/hexo-外挂标签模板-速查/index.html","hash":"7f6fcf236c23de3ec0145a9b07a36434923661fa","modified":1682257844445},{"_id":"public/2023/03/27/CMU15445-learning/index.html","hash":"83684fad28455a8b92137a3f9f0b9bfe1f3f2d28","modified":1682257844445},{"_id":"public/2023/03/24/my-pat-learning/index.html","hash":"236affab054f73e2dcfeb136e6c9600104131058","modified":1682257844445},{"_id":"public/2023/03/23/hello-world/index.html","hash":"2b690b8a9ad1f2daccd3125c7dfe30cf3ebd6274","modified":1682257844445},{"_id":"public/categories/学习笔记/index.html","hash":"4bf0010cd5ef3cdfa695cf4e93e96c65f44cfd9d","modified":1682257844445},{"_id":"public/categories/Algorithm/index.html","hash":"4f25bbe4516317a63dd351f4af12c32230663d99","modified":1682257844445},{"_id":"public/categories/一个计科生的考研二战日记/index.html","hash":"affd3dec558b2d66d63a5bb931843c3cf71ce1e9","modified":1682257844445},{"_id":"public/categories/一个计科生的考研二战日记/page/2/index.html","hash":"285ad0a30c6160f5ba5f4d78de2203d32464208c","modified":1682257844445},{"_id":"public/categories/算法/index.html","hash":"b2b8802b52daec1ba6bdae1309be6bbfbc78f626","modified":1682257844445},{"_id":"public/archives/page/2/index.html","hash":"9968c6e66a7b73268c93e440bbb8aac20ab2e9e9","modified":1682257844445},{"_id":"public/archives/2023/index.html","hash":"2360893b432e238b5122f53324d5c6ac012fbc71","modified":1682257844445},{"_id":"public/archives/2023/page/2/index.html","hash":"5955bb32ffd293b96b977dc1b7078d46e647733f","modified":1682257844445},{"_id":"public/archives/2023/03/index.html","hash":"3c110ee037b8b290223f8d13e9fe3c595bd756b9","modified":1682257844445},{"_id":"public/archives/2023/04/index.html","hash":"0e6d8b123c80dac925287bbbdde13de55e26316c","modified":1682257844445},{"_id":"public/archives/2023/04/page/2/index.html","hash":"7de553552b4b1f9035081b9b438bf79ee9d2a1de","modified":1682257844445},{"_id":"public/tags/CMU15445/index.html","hash":"8ec3c009a23b652e09ec739ba32ae612d03bfc25","modified":1682257844445},{"_id":"public/tags/database/index.html","hash":"f0a24497d3dd5246e55fbac866a1f741afc89a0d","modified":1682257844445},{"_id":"public/tags/algorithm/index.html","hash":"90b0a0ed4a03adc33e9c37df4700d0bffb4a54cf","modified":1682257844445},{"_id":"public/tags/PAT-certificate/index.html","hash":"fa28d3aad4dfbfd30761e49bdd04071caa5cb0d9","modified":1682257844445},{"_id":"public/tags/start/index.html","hash":"d8d008bfeb3d008be6420c0982605cff9d8e3b3d","modified":1682257844445},{"_id":"public/tags/主题美化/index.html","hash":"09956ddf49fb30cd186ac989792842a3d71d6935","modified":1682257844445},{"_id":"public/tags/标签速查/index.html","hash":"b1ecdf842a099dccc34948252d8745db59393202","modified":1682257844445},{"_id":"public/tags/考研/index.html","hash":"ee443d570024e11593015db15d231d3f02b1ce82","modified":1682257844445},{"_id":"public/tags/考研/page/2/index.html","hash":"eda3445ad863e4b9b2727a24d4041659bb60ba9e","modified":1682257844445},{"_id":"public/tags/DS/index.html","hash":"cf6c57d2f16ef49aa16aa1c39b1364e5bcc52a10","modified":1682257844445},{"_id":"public/tags/二战/index.html","hash":"e1540c094ee530e87ffa1c4f5f14f2901b0a5915","modified":1682257844445},{"_id":"public/tags/二战/page/2/index.html","hash":"11a18e073f1cda7c91ec1c29e44f5f6daf7efb16","modified":1682257844445},{"_id":"public/tags/复习/index.html","hash":"d31fa563cce13f59d8e82408d997cabbc8b3433e","modified":1682257844445},{"_id":"public/tags/数学/index.html","hash":"4650f505920c6cf861b4a6101073d2edea9b9a55","modified":1682257844445},{"_id":"public/tags/c/index.html","hash":"4466b2f4c581d431c3f6cc80ab6311451daf4de1","modified":1682257844445},{"_id":"public/index.html","hash":"520b62e786976e2ae855cbbc9c02ef8d6be889a4","modified":1682257844445},{"_id":"public/page/2/index.html","hash":"d29c6f0d5d035a30854372e6194140b0c380aa1d","modified":1682257844445},{"_id":"public/CNAME","hash":"711490d153285a1bfd3a7cc0b9593f326be39cbc","modified":1682257844445},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1682257844445},{"_id":"public/img/digit-xs.png","hash":"eb2aeeeb7cf6888dd1a4cb47fd484677b431a124","modified":1682257844445},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1682257844445},{"_id":"public/img/digit-sm.png","hash":"2b32341d8b6b7f33b7e55d4068785ec389091ae2","modified":1682257844445},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1682257844445},{"_id":"public/img/digit-md.png","hash":"e09b4c968f0921731982b37b148fec6f3a049ca5","modified":1682257844445},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1682257844445},{"_id":"public/js/flipcountdown.js","hash":"edc24d8a0fa70850ab1bf92398860c0fadafcff7","modified":1682257844445},{"_id":"public/js/floatpanel.js","hash":"c5ed2589adb0f438daafa40e31330f47e4a8b3af","modified":1682257844445},{"_id":"public/js/categoryBar.js","hash":"c08f24ceb72df009f4ff12db2c506a759d1c3410","modified":1682257844445},{"_id":"public/js/inject_calender.js","hash":"3e1abe81daf38cad3cde1cb8a64ea60b536d9318","modified":1682257844445},{"_id":"public/js/grayscale.js","hash":"6465eba0c0e6f94e772d4d09c20ba2b26b8a031e","modified":1682257844445},{"_id":"public/js/randombg.js","hash":"35ca3bb80bdecfbad9ced5b628b21dffd1d700a0","modified":1682257844445},{"_id":"public/js/github-calendar.min.js","hash":"249391735d6d890ea957d4a5ff7a086865d9b055","modified":1682257844445},{"_id":"public/js/runtime.js","hash":"531db551f1dc5f7d88bcf162230bae6a23e81ef0","modified":1682257844445},{"_id":"public/js/utils.js","hash":"c9b4d8ec10a74f29cf1f9c4275f0cae3bd93b427","modified":1682257844445},{"_id":"public/js/search/local-search.js","hash":"ee86f52bb6558c51a6f31402c2e4ec1dcb81bb55","modified":1682257844445},{"_id":"public/js/search/algolia.js","hash":"5f4294337c28324e088908ed0ceb237a2a360ae5","modified":1682257844445},{"_id":"public/css/index.css","hash":"edb5772580f5f8486495b863124ca7a3afde4925","modified":1682257844445},{"_id":"public/js/main.js","hash":"c0a3093c2485fa2121c10741e256170f211c7398","modified":1682257844445},{"_id":"public/js/tw_cn.js","hash":"76d0c5c172cae44b34b0bd3125fd068b2c3cbd4a","modified":1682257844445},{"_id":"public/img/digit-lg.png","hash":"a9518a4025d2c2db68210494ae518fa67ff5ad63","modified":1682257844445},{"_id":"public/fonts/NinoNuemann.ttf","hash":"2357da9903fae0a9864ab208f01c705063d03542","modified":1682257844445}],"Category":[{"name":"学习笔记","_id":"clgtgvwm40004bsuo3upj3gi6"},{"name":"Algorithm","_id":"clgtgvwm8000bbsuocpeyc8gh"},{"name":"一个计科生的考研二战日记","_id":"clgtgvwmd000nbsuohxdedjbh"},{"name":"算法","_id":"clgtgvwmh0017bsuodhxae7if"}],"Data":[],"Page":[{"title":"archives","type":"archives","date":"2023-03-22T02:54:04.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ntype: \"archives\"\ndate: 2023-03-22 10:54:04\n---\n","updated":"2023-03-22T02:55:00.401Z","path":"archives/index.html","comments":1,"layout":"page","_id":"clgtgvwlw0000bsuo6t3uf0wx","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"categories","type":"categories","date":"2023-03-22T02:54:05.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\ndate: 2023-03-22 10:54:05\n---\n","updated":"2023-03-24T03:43:27.982Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clgtgvwm10002bsuo2t0zeoyz","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"tags","type":"tags","date":"2023-03-22T02:54:03.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\ndate: 2023-03-22 10:54:03\n---\n","updated":"2023-03-24T03:43:23.323Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clgtgvwm50006bsuo4a6d3cqo","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"link","type":"link","date":"2023-03-22T02:54:06.000Z","_content":"","source":"link/index.md","raw":"---\ntitle: link\ntype: \"link\"\ndate: 2023-03-22 10:54:06\n---\n","updated":"2023-03-22T02:55:25.231Z","path":"link/index.html","comments":1,"layout":"page","_id":"clgtgvwm70008bsuo9iribxhh","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"CMU15445_learning","copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-03-27T04:58:26.000Z","updated":"2023-03-27T04:58:26.000Z","keywords":"CMU15445","description":"记录CMU15445学习过程","cover":"https://my-blog-pics-repo.oss-cn-shanghai.aliyuncs.com/Cover_img/106446680_p0.png","_content":"\n\n\n{% timeline 2023,orange %}\n<!-- timeline 03-27 -->\n初步完成了homework1 但是上传测试结果不理想\n<!-- endtimeline -->\n\n<!-- timeline 03-28 -->\n今天来找homework中的错误，争取这次满分通过测试.\n\n<!-- endtimeline -->\n\n<!-- timeline 03-29 -->\n完成project-0\n\n<!-- endtimeline -->\n\n<!-- timeline 03-30 -->\nproject0 终于运行起来了，哭。\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n\n\n\n\n[TOC]\n\n# 数据库基本介绍\n\n## SQL语句基础\n\n### SQL 中的基本数据类型\n\n- char(n)\n- varchar(n)  指定最长为n的字符串\n- numeric(p,q)   一共有p位 q位位小数位\n- int   \n- smallint\n- real precision / double precision  单精度/双精度 浮点数\n- float(n)  精度至少为n的浮点数\n\n### 完整性约束 概念\n\n- primary key  主键 主码 属性： 虽然在create table时是可选的，每个元组的主键的值是不能重复的。\n\n```sql\nprimary key (colunm)\n```\n\n- foreign key reference： 外键\n\n```sql\nforeign key (column) reference (table)\n```\n\n- not null  非空\n\n```sql\ncreate table stus(\n\tstu_id int not null,\n\tstu_name varchar(20) not null,\n\tprimary key (stu_id)\n);\n```\n\n==sql 禁止破环完整性约束的操作出现==\n\n如果任意一条插入到当前关系中的元组有违反完整性约束的条件存在 sql就会报错。\n\n### sql 插入元组操作\n\n```sql\ninsert into (table) values ([v1,[v2,[v3...]]]);\n```\n\n### sql 删除一个关系（表）中所有元组操作\n\n```sql\ndelete from table_name; # 这种方式会保留表（关系）可以继续对这个表进行操作\n```\n\n### sql 删除关系操作（删除表？）\n\n```sql\ndrop table table_name; # 删除关系\n```\n\ndrop 删除了一个table 和这个table相关的外键会怎样呢？\n\n### sql 为关系增加/删除 属性\n\n```sql\nalter table table_name add (column_name) (column_domain); #  属性的域就是数据类型吧\n```\n\n```sql\nalter table table_name drop (column_name);\n```\n\n## SQL 查询操作\n\n### 查询操作简介\n\n在一个关系上进行“查询操作”将查询结果构建成一个关系 作为返回。=> 关系\n\n### 单关系查询\n\n### 多关系查询\n\n## SQL index 索引\n\n\n\n\n\n## SQL  AGGREGATES 聚集函数\n\n作用将从结果中计算整个集合中的一些类似 sum average 这样的函数\n\n聚集函数最后返回的是一个值，你得保证这次查询的东西都在这个结果中\n\n- AVG()  \t    支持DISTINCT\n- MIN()\n- MAX()\n- SUM()        支持DISTINCT\n- COUNT()   支持DISTINCT  \n  - count(*) 是有优化的 这个更快！\n\n```sql\nselect count(distinct column_name) from table_name where column_name like \"正则\";\n```\n\n### GROUP BY + 聚集函数的使用技巧\n\n### HAVING\n\n### ORDER BY\n\nASC \n\nDESC\n\n## SQL中的模糊查询\n\n使用LIKE 以及 正则匹配来进行模糊查询（匹配）\n\n## SQLite JOIN\n\n### 交叉连接 CROSS JOIN\n\n将第一个表的每一行与第二个表的每一行进行匹配 假设两个表是x y行，那么输出就是x*y行\n\n语法示例\n\n```sql\nSELECT * FROM T1 CROSS JOIN T2;\n```\n\n### 内连接\n\n和cross join差不多，但是在连接两个表的时候对每一次的匹配进行比较，当满足连接谓词的时候才会形成一个结果行。\n\n语法示例\t\n\n```sql\nSELECT * FROM T1 (INNER) JOIN T2 ON condition;\n```\n\n自然连接\n\n```sql\nSELECT * FROM T1 NATURAL JOIN T2;\n```\n\n\n\n### 外连接\n\n## UNION 操作\n\nUNION\n\n`UNION`是一种操作符，它用于将两个或多个`SELECT`语句的结果集合并为一个结果集。具体来说，`UNION`操作符会将多个`SELECT`语句的结果集合并成一个结果集，并自动去除其中的重复行。\n\n```sql\nSELECT column1, column2, ... FROM table1\nUNION\nSELECT column1, column2, ... FROM table2\nUNION\nSELECT column1, column2, ... FROM table3\n...\n\n```\n\n\n\n`UNION ALL`是一种用于将两个或多个`SELECT`语句的结果集合并为一个结果集的操作符。它与`UNION`操作符不同的是，它不会自动去除结果集中的重复行，而是将所有的行都保留下来。\n\n```sql\nSELECT column1, column2, ... FROM table1\nUNION ALL\nSELECT column1, column2, ... FROM table2\nUNION ALL\nSELECT column1, column2, ... FROM table3\n...\n\n```\n\n## 递归查询\n\n递归查询的结构\n\n- 初始查询\n- 递归查询\n\n\n\n\n\n# CMU15445-HomeWork-1\n\n==任务==：写sql脚本，使用sql语句在IMDb dataset里面查询/完成指定任务\n\n## 环境配置\n\n本机环境：VMware ==Ubuntu 22.04.2 server==\n\n- 安装sqlite3\n\n```bash\n# 查看当前linuxOS 是否默认安装了sqlite3\n> sqlite3\n# 如果没有就sudo 安装\n> sudo apt install sqlite3\n```\n\n- 下载数据\n\n```bash\n> wget https://15445.courses.cs.cmu.edu/fall2022/files/imdb-cmudb2022.db.gz\n```\n\n- (可选) 检查数据的完整性\n- 给各个表创建索引\n- 了解数据中的各个表\n\n![schema](https://15445.courses.cs.cmu.edu/fall2022/files/schema2022.png)\n\n\n\n- people\n\n- title\n\n- akas\n- rating\n- crew\n\n> TIPS:\n>\n> 本次作业中，将title表称作 works\n>\n> 在akas表中不会使用 `region`, `types`, `attributes` 或者`is_original_title`\n>\n> 对于crew表，不会使用  `job` or `characters`，当考虑一个人的职责的时候指的就是 `category`\n\n## 作业准备\n\n### placeholder folder 的构建\n\n```bash\n$ mkdir placeholder\n$ cd placeholder\n$ touch \\\n  q1_sample.sql \\\n  q2_sci_fi.sql \\\n  q3_oldest_people.sql \\\n  q4_crew_appears_most.sql \\\n  q5_decade_ratings.sql \\\n  q6_cruiseing_altitude.sql \\\n  q7_year_of_thieves.sql \\\n  q8_kidman_colleagues.sql \\\n  q9_9th_decile_ratings.sql \\\n  q10_house_of_the_dragon.sql\n$ cd ..\n```\n\n### Q1 [0 point] 提交示例\n\n例如按照如下的sql代码为样例写你的作业。\n\n### Q2 [5 points] 找最长时间sci_fi\n\n要求：\n\n- 10个最长时间的works  grenre 是SCI_FI\n- 输出 title  premiere date（首映日期） 电影时长+（min）\n\n{% tabs %}\n<!-- tab 第一次提交（存在错误） -->\n\n```sql\nSELECT primary_title, premiered, CAST(runtime_minutes AS VARCHAR) || \"(mins)\"\nFROM title\nWHERE genres LIKE \"%Sci-Fi%\"\nORDER BY runtime_mins DESC;\n```\n\n不会是少了一个空格吧\n\n<!-- endtab -->\n\n<!-- tab 第二次提交 -->\n\n```sql\nSELECT primary_title, premiered, CAST(runtime_minutes AS VARCHAR) || \" (mins)\"\nFROM title\nWHERE genres LIKE \"%Sci-Fi%\"\nORDER BY runtime_mins DESC;\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n如何在输出的东西上任意添加想要附加的字符串？\n\n将int类型的数据映射成字符串 CAST（）然后使用字符串连接符号 || 连接\n\n### Q3 [5 points] 最老的人\n\n要求：\n\n- 这些人需要在1900年之后出生\n- 你需要考虑没死的人\n- 输出：首先按照年龄排序，相同年龄按照名字的字典序排序\n- 输出20个结果  并且按照 name|age 的格式输出\n\n分析：\n\n显然考察的是运算操作。people中born的字段是int died字段也一样。先看没死的人died是不是null\n\n如何计算没死的人的年龄 并将他们放到一起\n\n```sql\nCASE\n\tWHEN died IS NOT NULL\n\tTHEN died - born\n\tELSE 2022 - born\nEND AS age\n```\n\n{% tabs test1 %}\n<!-- tab 第一次提交（出错） -->\n\n```sql\nSELECT name,\n\tCASE\n\t\tWHEN died IS NULL\n\t\tTHEN 2023-died\n\t\tELSE died-born\n    END AS age\nFROM people\nWHERE born>=1900\nORDER BY age DESC, name ASC\nLIMIT 20;\n```\n\n可能是时间上出错了 今年是2023年\n\n<!-- endtab -->\n\n<!-- tab 第二次提交 -->\n\n```\nSELECT name,\n\tCASE\n\t\tWHEN died IS NULL\n\t\tTHEN 2022-born\n\t\tELSE died-born\n    END AS age\nFROM people\nWHERE born>=1900\nORDER BY age DESC, name ASC\nLIMIT 20;\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n### Q4 [10 points] 出现次数最多的人\n\n要求：\n\n- 出现次数最多的人\n- 输出格式 name 出现次数\n- 最多的前20人\n\n分析：\n\n- 将titles 和 crew join到一起\n\n```sql\nSELECT p.name,count(p.person_id) AS appear_times\nFROM crew AS c, people AS p\nWHERE c.person_id==p.person_id\nGROUP BY p.person_id\nORDER BY appear_times DESC\nLIMIT 20;\n```\n\n- 使用inner join 也是一个不错的选择\n\n```sql\nSELECT name,count(*) AS appear_times\nFROM people AS p JOIN crew AS c\nON p.person_id==c.person_id\nGROUP BY p.person_id\nORDER BY appear_times DESC\nLIMIT 20;\n```\n\n出错原因：有些细节没注意。\n\n### Q5 [10 points]\n\n要求：\n\n- 每十年的平均评分、最高评分、最低评分、上映的电影数量\n- 按照平均评分降序排序，同分按照年份升序排序，average rating 保留两位小数\n\n分析：\n\n- 将rating 和 title做一个inner join\n\n```sql\nSELECT \n\tCAST(premiered/10*10 AS VARCHAR) || \"s\" AS year, \n\tROUND(AVG(rating),2) AS avg_rating,\n    MAX(rating),\n    MIN(rating),\n    count(*)\nFROM \n\ttitles AS t\nINNER JOIN \n\tratings AS r \nON t.title_id=r.title_id\nWHERE premiered IS NOT NULL\nGROUP BY year\nORDER BY avg_rating DESC, year ASC;\n```\n\nsqlite 整除  / 就是整除\n\nsqlite 保留n位小数 round \n\nsqlite 取整 ceil floor\n\n\n\n### Q6  [10 points] 找人\n\n要求：\n\n- 一个人 名字里有 Cruise  生于1962\n- vote 数量最多的作品 前十 \n- 输出格式： 作品名称 | 投票数\n\n分析：\n\n- 多表联合查询\n\n```sql\nSELECT t.primary_title,votes\nFROM \n\tratings AS r\nJOIN\n\ttitles AS t\nON t.title_id = r.title_id\nJOIN\n\tcrew AS c\nON t.title_id = c.title_id\nJOIN \n\tpeople AS p\nON c.person_id = p.person_id\nWHERE p.name LIKE \"%Cruise%\" AND p.born==1962\nORDER BY votes DESC\nLIMIT 10;\n```\n\n感觉有点慢\n\n```sql\nWITH cruise_movies AS (\n     SELECT\n          crew.title_id AS title_id\n     FROM crew\n     INNER JOIN\n          people ON crew.person_id = people.person_id\n     WHERE people.name LIKE \"%Cruise%\" AND people.born = 1962\n)\nSELECT\n     titles.primary_title as name,\n     ratings.votes as votes\nFROM\n     cruise_movies\nINNER JOIN\n     ratings ON cruise_movies.title_id = ratings.title_id\nINNER JOIN\n     titles ON cruise_movies.title_id = titles.title_id\nORDER BY votes DESC\nLIMIT 10;\n```\n\n### Q7 [15 points] 找特定年份的数据\n\n要求：\n\n- 找和Army of Thieves同年上映的电影数量\n- 输出这一年的电影数量\n\n分析：\n\n- 嵌套查询、子查询\n\n```sql\nSELECT COUNT(DISTINCT title_id) \nFROM titles\nWHERE premiered = (\nSELECT premiered\nFROM titles\nWHERE primary_title = \"Army of Thieves\"\n);\n```\n\n### Q8 [15 points]\n\n要求：\n\n- 找到所有与Nicole Kidman  (1967 出生的) 共同出演的演员\n- 将所有的actor / actress按照名字的字典序排序\n\nwith 前置条件的运用\n\n分析（过程）：\n\n- 首先将这个人的出演过的作品id列出\n- 通过这个作品id查所有出现过的人的person -id （使用distinct去重）\n- 查people表找上述person-id里面的人的名字\n\n```sql\nSELECT title_id \nFROM \n\tcrew AS c\nJOIN\n\tpeople AS p\nON c.person_id = p.person_id\nWHERE p.name = \"Nicole Kidman\"\n```\n\n```sql\nWITH kidman_titles AS (\nSELECT title_id \nFROM crew JOIN people ON crew.person_id = people.person_id\nWHERE people.name = \"Nicole Kidman\" AND people.born == 1967\n),\nWITH kidman_colleagues AS(\nSELECT DISTINCT(person_id) AS id\nFROM crew \nWHERE (category = \"actor\" or category = \"actress\") AND crew.title_id in kidman_titles\n)\nSELECT name\nFROM people\nWHERE people.person_id in kidman_colleagues.id\nORDER BY name ASC;\n```\n\n### Q9 [15 points]\n\n要求：\n\n- 出生于1955年的演员\n\n\n\n```sql\nWITH actors_and_movies_1955 AS (\n     SELECT\n          people.person_id,\n          people.name,\n          titles.title_id,\n          titles.primary_title\n     FROM\n          people\n     INNER JOIN\n          crew ON people.person_id = crew.person_id\n     INNER JOIN\n          titles ON crew.title_id = titles.title_id\n     WHERE people.born = 1955 AND titles.type = \"movie\"\n),\nactor_ratings AS (\n     SELECT\n          name,\n          ROUND(AVG(ratings.rating), 2) as rating\n     FROM ratings\n     INNER JOIN actors_and_movies_1955 ON ratings.title_id = actors_and_movies_1955.title_id\n     GROUP BY actors_and_movies_1955.person_id\n),\nquartiles AS (\n     SELECT *, NTILE(10) OVER (ORDER BY rating ASC) AS RatingQuartile FROM actor_ratings\n)\nSELECT name, rating\nFROM quartiles\nWHERE RatingQuartile = 9\nORDER BY rating DESC, name ASC;\n```\n\n### Q10 [15 points]\n\n要求：\n\n- 使用逗号和空格连接TV 龙之家族的 所有unique titles 这些titles必须要按照字典序来\n\n```sql\nwith p as (\n      select titles.primary_title as name, akas.title as dubbed\n      from titles\n      inner join akas on titles.title_id = akas.title_id\n      where titles.primary_title = \"House of the Dragon\" AND titles.type = 'tvSeries'\n      group by titles.primary_title, akas.title\n      order by akas.title\n),\nc as (\n      select row_number() over (order by p.name asc) as seqnum, p.dubbed as dubbed\n      from p\n),\nflattened as (\n      select seqnum, dubbed\n      from c\n      where seqnum = 1\n      union all\n      select c.seqnum, f.dubbed || ', ' || c.dubbed\n      from c join\n            flattened f\n            on c.seqnum = f.seqnum + 1\n)\nselect dubbed from flattened\norder by seqnum desc limit 1;\n\n```\n\n\n\n\n\n\n\n### 完成后将sql文件打包\n\n```bash\n$ zip -j submission.zip placeholder/*.sql\n```\n\n\n\n# CMU15445-PROJECT-0\n\n## project-0 任务介绍\n\n目标：\n\n> implement a key-value store backed by a concurrent [trie](https://zh.wikipedia.org/wiki/Trie)\n\n## 环境搭建：\n\n使用的是本地的VMware里面的Ubuntu server 22.04.x版本的\n\nIDE：CLion 通过ssh连接虚拟机\n\n## 前置知识的学习\n\ntrie也叫 前缀树、字典树。之前没接触过。先做一下leetcode上的有关前缀树的定义的题目熟悉一下前缀树 \n\n## 前缀树\n\n### 数据结构\n\nis_end bool 表示是否是单词的结束 true表示当前节点为单词的结束\n\nmap<char,Trie*> children_nodes; 子节点的连接。\n\n```c++\nclass Trie {\nprivate:\n    // 存储前缀树的存储数据结构\n    map<char,Trie*> children_node;\n    bool is_End;\n    // 内置的搜索前缀的工具函数\n    Trie* searchPrefix(string prefix){\n        Trie* current_node = this;\n        for(auto c:prefix){\n            if(current_node->children_node.find(c)==current_node->children_node.end()){\n                return nullptr;\n            }\n            current_node = current_node->children_node[c];\n        }\n        return current_node;\n    }\npublic:\n    Trie() {\n        is_End = false;\n    }\n    \n    void insert(string word) {\n        Trie* current_node = this;  // 初始指针指向当前根节点\n        for(auto c:word){\n            if(current_node->children_node.find(c)==current_node->children_node.end()){\n                // 表示当前字节点集合中没有这个  所以创建一个\n                current_node->children_node[c] = new Trie();\n            }\n            current_node = current_node->children_node[c];\n        }\n        current_node->is_End = true;\n    }\n    \n    bool search(string word) {\n        Trie* current_node = this->searchPrefix(word);\n        return current_node!=nullptr && current_node->is_End;\n    }\n    \n    bool startsWith(string prefix) {\n        return this->searchPrefix(prefix)!=nullptr;\n    }\n};\n```\n\n### 左值、右值、左值引用、右值引用\n\n左值：可以放在赋值号的左边充当被赋值的对象，也可以在右边做赋值对象，充当左值的“东西”必须要有在内存上的存储空间。\n\n右值：智能在赋值号的右边，做赋值对象，可以没有存储空间，可以只是一个在cpu寄存器上的一个数据。右值不能被修改\n\n左值引用：引用的是一个对象。\n\n右值引用：引用的是一个数据。这个只能作为右值，他不在内存上占有存储空间。\n\n作用用来提高程序运行效率，避免多余的拷贝操作。\n\nstd::move()  将一个左值变为右值\n\n使用临时对象使用的空间，赋值到目标对象中可以节省对内存的释放。\n\n==例如==\n\n```c++\nint main() { \n\tMyString a; \n\ta = MyString(\"Hello\"); \n\tstd::vector<MyString> vec; \n\tvec.push_back(MyString(\"World\")); \n}\n```\n\n这个函数在程序结束时一共调用了四次析构函数\n\n```\nCopy Assignment is called! source: Hello\nDestructor is called!\nCopy Constructor is called! source: World\nDestructor is called!\nDestructor is called!  // 最后两次的析构函数时a 和 vector0 被释放\nDestructor is called!\n```\n\n\n\n####  智能指针\n\nunique_ptr()\n\n独占资源所有权指针，该指针式moveonly的 也就是智能通过move函数将其给赋值到一个左值中\n\n创建：\n\nshared_ptr()\n\n共享资源所有权指针\n\nweak_ptr()\n\n共享资源观察者\n\n### dynamic_cast\n\n将一个基类的指针/引用 指向继承类的指针/引用，dynamic_cast将会判断该基类是否真的指向继承类，如果否则返回null 或者报错\n\n\n\n\n\n\n\n# Linux 一些命令的小记\n\n创建目录：\n\n```bash\n> mkdir  path/directory-name\n```\n\n创建文件：\n\n``` bash\n> touch  path/file-name\n```\n\n创建多个文件：\n\n```bash\n> touch \\\n\nfile-name1 \\\n\nfile-name2 \\\n\n....\n\n```\n\nsqlite 执行sql文件\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/CMU15445-learning.md","raw":"---\ntitle: CMU15445_learning\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-03-27 12:58:26\nupdated: 2023-03-27 12:58:26\ntags: \n- CMU15445\n- database\ncategories:\n- 学习笔记\nkeywords: CMU15445\ndescription: 记录CMU15445学习过程\ncover: https://my-blog-pics-repo.oss-cn-shanghai.aliyuncs.com/Cover_img/106446680_p0.png\n---\n\n\n\n{% timeline 2023,orange %}\n<!-- timeline 03-27 -->\n初步完成了homework1 但是上传测试结果不理想\n<!-- endtimeline -->\n\n<!-- timeline 03-28 -->\n今天来找homework中的错误，争取这次满分通过测试.\n\n<!-- endtimeline -->\n\n<!-- timeline 03-29 -->\n完成project-0\n\n<!-- endtimeline -->\n\n<!-- timeline 03-30 -->\nproject0 终于运行起来了，哭。\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n\n\n\n\n[TOC]\n\n# 数据库基本介绍\n\n## SQL语句基础\n\n### SQL 中的基本数据类型\n\n- char(n)\n- varchar(n)  指定最长为n的字符串\n- numeric(p,q)   一共有p位 q位位小数位\n- int   \n- smallint\n- real precision / double precision  单精度/双精度 浮点数\n- float(n)  精度至少为n的浮点数\n\n### 完整性约束 概念\n\n- primary key  主键 主码 属性： 虽然在create table时是可选的，每个元组的主键的值是不能重复的。\n\n```sql\nprimary key (colunm)\n```\n\n- foreign key reference： 外键\n\n```sql\nforeign key (column) reference (table)\n```\n\n- not null  非空\n\n```sql\ncreate table stus(\n\tstu_id int not null,\n\tstu_name varchar(20) not null,\n\tprimary key (stu_id)\n);\n```\n\n==sql 禁止破环完整性约束的操作出现==\n\n如果任意一条插入到当前关系中的元组有违反完整性约束的条件存在 sql就会报错。\n\n### sql 插入元组操作\n\n```sql\ninsert into (table) values ([v1,[v2,[v3...]]]);\n```\n\n### sql 删除一个关系（表）中所有元组操作\n\n```sql\ndelete from table_name; # 这种方式会保留表（关系）可以继续对这个表进行操作\n```\n\n### sql 删除关系操作（删除表？）\n\n```sql\ndrop table table_name; # 删除关系\n```\n\ndrop 删除了一个table 和这个table相关的外键会怎样呢？\n\n### sql 为关系增加/删除 属性\n\n```sql\nalter table table_name add (column_name) (column_domain); #  属性的域就是数据类型吧\n```\n\n```sql\nalter table table_name drop (column_name);\n```\n\n## SQL 查询操作\n\n### 查询操作简介\n\n在一个关系上进行“查询操作”将查询结果构建成一个关系 作为返回。=> 关系\n\n### 单关系查询\n\n### 多关系查询\n\n## SQL index 索引\n\n\n\n\n\n## SQL  AGGREGATES 聚集函数\n\n作用将从结果中计算整个集合中的一些类似 sum average 这样的函数\n\n聚集函数最后返回的是一个值，你得保证这次查询的东西都在这个结果中\n\n- AVG()  \t    支持DISTINCT\n- MIN()\n- MAX()\n- SUM()        支持DISTINCT\n- COUNT()   支持DISTINCT  \n  - count(*) 是有优化的 这个更快！\n\n```sql\nselect count(distinct column_name) from table_name where column_name like \"正则\";\n```\n\n### GROUP BY + 聚集函数的使用技巧\n\n### HAVING\n\n### ORDER BY\n\nASC \n\nDESC\n\n## SQL中的模糊查询\n\n使用LIKE 以及 正则匹配来进行模糊查询（匹配）\n\n## SQLite JOIN\n\n### 交叉连接 CROSS JOIN\n\n将第一个表的每一行与第二个表的每一行进行匹配 假设两个表是x y行，那么输出就是x*y行\n\n语法示例\n\n```sql\nSELECT * FROM T1 CROSS JOIN T2;\n```\n\n### 内连接\n\n和cross join差不多，但是在连接两个表的时候对每一次的匹配进行比较，当满足连接谓词的时候才会形成一个结果行。\n\n语法示例\t\n\n```sql\nSELECT * FROM T1 (INNER) JOIN T2 ON condition;\n```\n\n自然连接\n\n```sql\nSELECT * FROM T1 NATURAL JOIN T2;\n```\n\n\n\n### 外连接\n\n## UNION 操作\n\nUNION\n\n`UNION`是一种操作符，它用于将两个或多个`SELECT`语句的结果集合并为一个结果集。具体来说，`UNION`操作符会将多个`SELECT`语句的结果集合并成一个结果集，并自动去除其中的重复行。\n\n```sql\nSELECT column1, column2, ... FROM table1\nUNION\nSELECT column1, column2, ... FROM table2\nUNION\nSELECT column1, column2, ... FROM table3\n...\n\n```\n\n\n\n`UNION ALL`是一种用于将两个或多个`SELECT`语句的结果集合并为一个结果集的操作符。它与`UNION`操作符不同的是，它不会自动去除结果集中的重复行，而是将所有的行都保留下来。\n\n```sql\nSELECT column1, column2, ... FROM table1\nUNION ALL\nSELECT column1, column2, ... FROM table2\nUNION ALL\nSELECT column1, column2, ... FROM table3\n...\n\n```\n\n## 递归查询\n\n递归查询的结构\n\n- 初始查询\n- 递归查询\n\n\n\n\n\n# CMU15445-HomeWork-1\n\n==任务==：写sql脚本，使用sql语句在IMDb dataset里面查询/完成指定任务\n\n## 环境配置\n\n本机环境：VMware ==Ubuntu 22.04.2 server==\n\n- 安装sqlite3\n\n```bash\n# 查看当前linuxOS 是否默认安装了sqlite3\n> sqlite3\n# 如果没有就sudo 安装\n> sudo apt install sqlite3\n```\n\n- 下载数据\n\n```bash\n> wget https://15445.courses.cs.cmu.edu/fall2022/files/imdb-cmudb2022.db.gz\n```\n\n- (可选) 检查数据的完整性\n- 给各个表创建索引\n- 了解数据中的各个表\n\n![schema](https://15445.courses.cs.cmu.edu/fall2022/files/schema2022.png)\n\n\n\n- people\n\n- title\n\n- akas\n- rating\n- crew\n\n> TIPS:\n>\n> 本次作业中，将title表称作 works\n>\n> 在akas表中不会使用 `region`, `types`, `attributes` 或者`is_original_title`\n>\n> 对于crew表，不会使用  `job` or `characters`，当考虑一个人的职责的时候指的就是 `category`\n\n## 作业准备\n\n### placeholder folder 的构建\n\n```bash\n$ mkdir placeholder\n$ cd placeholder\n$ touch \\\n  q1_sample.sql \\\n  q2_sci_fi.sql \\\n  q3_oldest_people.sql \\\n  q4_crew_appears_most.sql \\\n  q5_decade_ratings.sql \\\n  q6_cruiseing_altitude.sql \\\n  q7_year_of_thieves.sql \\\n  q8_kidman_colleagues.sql \\\n  q9_9th_decile_ratings.sql \\\n  q10_house_of_the_dragon.sql\n$ cd ..\n```\n\n### Q1 [0 point] 提交示例\n\n例如按照如下的sql代码为样例写你的作业。\n\n### Q2 [5 points] 找最长时间sci_fi\n\n要求：\n\n- 10个最长时间的works  grenre 是SCI_FI\n- 输出 title  premiere date（首映日期） 电影时长+（min）\n\n{% tabs %}\n<!-- tab 第一次提交（存在错误） -->\n\n```sql\nSELECT primary_title, premiered, CAST(runtime_minutes AS VARCHAR) || \"(mins)\"\nFROM title\nWHERE genres LIKE \"%Sci-Fi%\"\nORDER BY runtime_mins DESC;\n```\n\n不会是少了一个空格吧\n\n<!-- endtab -->\n\n<!-- tab 第二次提交 -->\n\n```sql\nSELECT primary_title, premiered, CAST(runtime_minutes AS VARCHAR) || \" (mins)\"\nFROM title\nWHERE genres LIKE \"%Sci-Fi%\"\nORDER BY runtime_mins DESC;\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n如何在输出的东西上任意添加想要附加的字符串？\n\n将int类型的数据映射成字符串 CAST（）然后使用字符串连接符号 || 连接\n\n### Q3 [5 points] 最老的人\n\n要求：\n\n- 这些人需要在1900年之后出生\n- 你需要考虑没死的人\n- 输出：首先按照年龄排序，相同年龄按照名字的字典序排序\n- 输出20个结果  并且按照 name|age 的格式输出\n\n分析：\n\n显然考察的是运算操作。people中born的字段是int died字段也一样。先看没死的人died是不是null\n\n如何计算没死的人的年龄 并将他们放到一起\n\n```sql\nCASE\n\tWHEN died IS NOT NULL\n\tTHEN died - born\n\tELSE 2022 - born\nEND AS age\n```\n\n{% tabs test1 %}\n<!-- tab 第一次提交（出错） -->\n\n```sql\nSELECT name,\n\tCASE\n\t\tWHEN died IS NULL\n\t\tTHEN 2023-died\n\t\tELSE died-born\n    END AS age\nFROM people\nWHERE born>=1900\nORDER BY age DESC, name ASC\nLIMIT 20;\n```\n\n可能是时间上出错了 今年是2023年\n\n<!-- endtab -->\n\n<!-- tab 第二次提交 -->\n\n```\nSELECT name,\n\tCASE\n\t\tWHEN died IS NULL\n\t\tTHEN 2022-born\n\t\tELSE died-born\n    END AS age\nFROM people\nWHERE born>=1900\nORDER BY age DESC, name ASC\nLIMIT 20;\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n### Q4 [10 points] 出现次数最多的人\n\n要求：\n\n- 出现次数最多的人\n- 输出格式 name 出现次数\n- 最多的前20人\n\n分析：\n\n- 将titles 和 crew join到一起\n\n```sql\nSELECT p.name,count(p.person_id) AS appear_times\nFROM crew AS c, people AS p\nWHERE c.person_id==p.person_id\nGROUP BY p.person_id\nORDER BY appear_times DESC\nLIMIT 20;\n```\n\n- 使用inner join 也是一个不错的选择\n\n```sql\nSELECT name,count(*) AS appear_times\nFROM people AS p JOIN crew AS c\nON p.person_id==c.person_id\nGROUP BY p.person_id\nORDER BY appear_times DESC\nLIMIT 20;\n```\n\n出错原因：有些细节没注意。\n\n### Q5 [10 points]\n\n要求：\n\n- 每十年的平均评分、最高评分、最低评分、上映的电影数量\n- 按照平均评分降序排序，同分按照年份升序排序，average rating 保留两位小数\n\n分析：\n\n- 将rating 和 title做一个inner join\n\n```sql\nSELECT \n\tCAST(premiered/10*10 AS VARCHAR) || \"s\" AS year, \n\tROUND(AVG(rating),2) AS avg_rating,\n    MAX(rating),\n    MIN(rating),\n    count(*)\nFROM \n\ttitles AS t\nINNER JOIN \n\tratings AS r \nON t.title_id=r.title_id\nWHERE premiered IS NOT NULL\nGROUP BY year\nORDER BY avg_rating DESC, year ASC;\n```\n\nsqlite 整除  / 就是整除\n\nsqlite 保留n位小数 round \n\nsqlite 取整 ceil floor\n\n\n\n### Q6  [10 points] 找人\n\n要求：\n\n- 一个人 名字里有 Cruise  生于1962\n- vote 数量最多的作品 前十 \n- 输出格式： 作品名称 | 投票数\n\n分析：\n\n- 多表联合查询\n\n```sql\nSELECT t.primary_title,votes\nFROM \n\tratings AS r\nJOIN\n\ttitles AS t\nON t.title_id = r.title_id\nJOIN\n\tcrew AS c\nON t.title_id = c.title_id\nJOIN \n\tpeople AS p\nON c.person_id = p.person_id\nWHERE p.name LIKE \"%Cruise%\" AND p.born==1962\nORDER BY votes DESC\nLIMIT 10;\n```\n\n感觉有点慢\n\n```sql\nWITH cruise_movies AS (\n     SELECT\n          crew.title_id AS title_id\n     FROM crew\n     INNER JOIN\n          people ON crew.person_id = people.person_id\n     WHERE people.name LIKE \"%Cruise%\" AND people.born = 1962\n)\nSELECT\n     titles.primary_title as name,\n     ratings.votes as votes\nFROM\n     cruise_movies\nINNER JOIN\n     ratings ON cruise_movies.title_id = ratings.title_id\nINNER JOIN\n     titles ON cruise_movies.title_id = titles.title_id\nORDER BY votes DESC\nLIMIT 10;\n```\n\n### Q7 [15 points] 找特定年份的数据\n\n要求：\n\n- 找和Army of Thieves同年上映的电影数量\n- 输出这一年的电影数量\n\n分析：\n\n- 嵌套查询、子查询\n\n```sql\nSELECT COUNT(DISTINCT title_id) \nFROM titles\nWHERE premiered = (\nSELECT premiered\nFROM titles\nWHERE primary_title = \"Army of Thieves\"\n);\n```\n\n### Q8 [15 points]\n\n要求：\n\n- 找到所有与Nicole Kidman  (1967 出生的) 共同出演的演员\n- 将所有的actor / actress按照名字的字典序排序\n\nwith 前置条件的运用\n\n分析（过程）：\n\n- 首先将这个人的出演过的作品id列出\n- 通过这个作品id查所有出现过的人的person -id （使用distinct去重）\n- 查people表找上述person-id里面的人的名字\n\n```sql\nSELECT title_id \nFROM \n\tcrew AS c\nJOIN\n\tpeople AS p\nON c.person_id = p.person_id\nWHERE p.name = \"Nicole Kidman\"\n```\n\n```sql\nWITH kidman_titles AS (\nSELECT title_id \nFROM crew JOIN people ON crew.person_id = people.person_id\nWHERE people.name = \"Nicole Kidman\" AND people.born == 1967\n),\nWITH kidman_colleagues AS(\nSELECT DISTINCT(person_id) AS id\nFROM crew \nWHERE (category = \"actor\" or category = \"actress\") AND crew.title_id in kidman_titles\n)\nSELECT name\nFROM people\nWHERE people.person_id in kidman_colleagues.id\nORDER BY name ASC;\n```\n\n### Q9 [15 points]\n\n要求：\n\n- 出生于1955年的演员\n\n\n\n```sql\nWITH actors_and_movies_1955 AS (\n     SELECT\n          people.person_id,\n          people.name,\n          titles.title_id,\n          titles.primary_title\n     FROM\n          people\n     INNER JOIN\n          crew ON people.person_id = crew.person_id\n     INNER JOIN\n          titles ON crew.title_id = titles.title_id\n     WHERE people.born = 1955 AND titles.type = \"movie\"\n),\nactor_ratings AS (\n     SELECT\n          name,\n          ROUND(AVG(ratings.rating), 2) as rating\n     FROM ratings\n     INNER JOIN actors_and_movies_1955 ON ratings.title_id = actors_and_movies_1955.title_id\n     GROUP BY actors_and_movies_1955.person_id\n),\nquartiles AS (\n     SELECT *, NTILE(10) OVER (ORDER BY rating ASC) AS RatingQuartile FROM actor_ratings\n)\nSELECT name, rating\nFROM quartiles\nWHERE RatingQuartile = 9\nORDER BY rating DESC, name ASC;\n```\n\n### Q10 [15 points]\n\n要求：\n\n- 使用逗号和空格连接TV 龙之家族的 所有unique titles 这些titles必须要按照字典序来\n\n```sql\nwith p as (\n      select titles.primary_title as name, akas.title as dubbed\n      from titles\n      inner join akas on titles.title_id = akas.title_id\n      where titles.primary_title = \"House of the Dragon\" AND titles.type = 'tvSeries'\n      group by titles.primary_title, akas.title\n      order by akas.title\n),\nc as (\n      select row_number() over (order by p.name asc) as seqnum, p.dubbed as dubbed\n      from p\n),\nflattened as (\n      select seqnum, dubbed\n      from c\n      where seqnum = 1\n      union all\n      select c.seqnum, f.dubbed || ', ' || c.dubbed\n      from c join\n            flattened f\n            on c.seqnum = f.seqnum + 1\n)\nselect dubbed from flattened\norder by seqnum desc limit 1;\n\n```\n\n\n\n\n\n\n\n### 完成后将sql文件打包\n\n```bash\n$ zip -j submission.zip placeholder/*.sql\n```\n\n\n\n# CMU15445-PROJECT-0\n\n## project-0 任务介绍\n\n目标：\n\n> implement a key-value store backed by a concurrent [trie](https://zh.wikipedia.org/wiki/Trie)\n\n## 环境搭建：\n\n使用的是本地的VMware里面的Ubuntu server 22.04.x版本的\n\nIDE：CLion 通过ssh连接虚拟机\n\n## 前置知识的学习\n\ntrie也叫 前缀树、字典树。之前没接触过。先做一下leetcode上的有关前缀树的定义的题目熟悉一下前缀树 \n\n## 前缀树\n\n### 数据结构\n\nis_end bool 表示是否是单词的结束 true表示当前节点为单词的结束\n\nmap<char,Trie*> children_nodes; 子节点的连接。\n\n```c++\nclass Trie {\nprivate:\n    // 存储前缀树的存储数据结构\n    map<char,Trie*> children_node;\n    bool is_End;\n    // 内置的搜索前缀的工具函数\n    Trie* searchPrefix(string prefix){\n        Trie* current_node = this;\n        for(auto c:prefix){\n            if(current_node->children_node.find(c)==current_node->children_node.end()){\n                return nullptr;\n            }\n            current_node = current_node->children_node[c];\n        }\n        return current_node;\n    }\npublic:\n    Trie() {\n        is_End = false;\n    }\n    \n    void insert(string word) {\n        Trie* current_node = this;  // 初始指针指向当前根节点\n        for(auto c:word){\n            if(current_node->children_node.find(c)==current_node->children_node.end()){\n                // 表示当前字节点集合中没有这个  所以创建一个\n                current_node->children_node[c] = new Trie();\n            }\n            current_node = current_node->children_node[c];\n        }\n        current_node->is_End = true;\n    }\n    \n    bool search(string word) {\n        Trie* current_node = this->searchPrefix(word);\n        return current_node!=nullptr && current_node->is_End;\n    }\n    \n    bool startsWith(string prefix) {\n        return this->searchPrefix(prefix)!=nullptr;\n    }\n};\n```\n\n### 左值、右值、左值引用、右值引用\n\n左值：可以放在赋值号的左边充当被赋值的对象，也可以在右边做赋值对象，充当左值的“东西”必须要有在内存上的存储空间。\n\n右值：智能在赋值号的右边，做赋值对象，可以没有存储空间，可以只是一个在cpu寄存器上的一个数据。右值不能被修改\n\n左值引用：引用的是一个对象。\n\n右值引用：引用的是一个数据。这个只能作为右值，他不在内存上占有存储空间。\n\n作用用来提高程序运行效率，避免多余的拷贝操作。\n\nstd::move()  将一个左值变为右值\n\n使用临时对象使用的空间，赋值到目标对象中可以节省对内存的释放。\n\n==例如==\n\n```c++\nint main() { \n\tMyString a; \n\ta = MyString(\"Hello\"); \n\tstd::vector<MyString> vec; \n\tvec.push_back(MyString(\"World\")); \n}\n```\n\n这个函数在程序结束时一共调用了四次析构函数\n\n```\nCopy Assignment is called! source: Hello\nDestructor is called!\nCopy Constructor is called! source: World\nDestructor is called!\nDestructor is called!  // 最后两次的析构函数时a 和 vector0 被释放\nDestructor is called!\n```\n\n\n\n####  智能指针\n\nunique_ptr()\n\n独占资源所有权指针，该指针式moveonly的 也就是智能通过move函数将其给赋值到一个左值中\n\n创建：\n\nshared_ptr()\n\n共享资源所有权指针\n\nweak_ptr()\n\n共享资源观察者\n\n### dynamic_cast\n\n将一个基类的指针/引用 指向继承类的指针/引用，dynamic_cast将会判断该基类是否真的指向继承类，如果否则返回null 或者报错\n\n\n\n\n\n\n\n# Linux 一些命令的小记\n\n创建目录：\n\n```bash\n> mkdir  path/directory-name\n```\n\n创建文件：\n\n``` bash\n> touch  path/file-name\n```\n\n创建多个文件：\n\n```bash\n> touch \\\n\nfile-name1 \\\n\nfile-name2 \\\n\n....\n\n```\n\nsqlite 执行sql文件\n\n\n\n\n\n\n\n\n\n\n\n","slug":"CMU15445-learning","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwly0001bsuo9jhab3hj","content":"<div class=\"timeline orange\"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p>\n</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-27</p>\n</div></div><div class='timeline-item-content'><p>初步完成了homework1 但是上传测试结果不理想</p>\n</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-28</p>\n</div></div><div class='timeline-item-content'><p>今天来找homework中的错误，争取这次满分通过测试.</p>\n</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-29</p>\n</div></div><div class='timeline-item-content'><p>完成project-0</p>\n</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-30</p>\n</div></div><div class='timeline-item-content'><p>project0 终于运行起来了，哭。</p>\n</div></div></div>\n<p>[TOC]</p>\n<h1 id=\"数据库基本介绍\"><a href=\"#数据库基本介绍\" class=\"headerlink\" title=\"数据库基本介绍\"></a>数据库基本介绍</h1><h2 id=\"SQL语句基础\"><a href=\"#SQL语句基础\" class=\"headerlink\" title=\"SQL语句基础\"></a>SQL语句基础</h2><h3 id=\"SQL-中的基本数据类型\"><a href=\"#SQL-中的基本数据类型\" class=\"headerlink\" title=\"SQL 中的基本数据类型\"></a>SQL 中的基本数据类型</h3><ul>\n<li>char(n)</li>\n<li>varchar(n)  指定最长为n的字符串</li>\n<li>numeric(p,q)   一共有p位 q位位小数位</li>\n<li>int   </li>\n<li>smallint</li>\n<li>real precision / double precision  单精度/双精度 浮点数</li>\n<li>float(n)  精度至少为n的浮点数</li>\n</ul>\n<h3 id=\"完整性约束-概念\"><a href=\"#完整性约束-概念\" class=\"headerlink\" title=\"完整性约束 概念\"></a>完整性约束 概念</h3><ul>\n<li>primary key  主键 主码 属性： 虽然在create table时是可选的，每个元组的主键的值是不能重复的。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">primary</span> key (colunm)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>foreign key reference： 外键</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">foreign</span> key (<span class=\"keyword\">column</span>) reference (<span class=\"keyword\">table</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>not null  非空</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> stus(</span><br><span class=\"line\">\tstu_id <span class=\"type\">int</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">\tstu_name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">primary</span> key (stu_id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>==sql 禁止破环完整性约束的操作出现==</p>\n<p>如果任意一条插入到当前关系中的元组有违反完整性约束的条件存在 sql就会报错。</p>\n<h3 id=\"sql-插入元组操作\"><a href=\"#sql-插入元组操作\" class=\"headerlink\" title=\"sql 插入元组操作\"></a>sql 插入元组操作</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> (<span class=\"keyword\">table</span>) <span class=\"keyword\">values</span> ([v1,[v2,[v3...]]]);</span><br></pre></td></tr></table></figure>\n<h3 id=\"sql-删除一个关系（表）中所有元组操作\"><a href=\"#sql-删除一个关系（表）中所有元组操作\" class=\"headerlink\" title=\"sql 删除一个关系（表）中所有元组操作\"></a>sql 删除一个关系（表）中所有元组操作</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> table_name; # 这种方式会保留表（关系）可以继续对这个表进行操作</span><br></pre></td></tr></table></figure>\n<h3 id=\"sql-删除关系操作（删除表？）\"><a href=\"#sql-删除关系操作（删除表？）\" class=\"headerlink\" title=\"sql 删除关系操作（删除表？）\"></a>sql 删除关系操作（删除表？）</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> table_name; # 删除关系</span><br></pre></td></tr></table></figure>\n<p>drop 删除了一个table 和这个table相关的外键会怎样呢？</p>\n<h3 id=\"sql-为关系增加-删除-属性\"><a href=\"#sql-为关系增加-删除-属性\" class=\"headerlink\" title=\"sql 为关系增加/删除 属性\"></a>sql 为关系增加/删除 属性</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> table_name <span class=\"keyword\">add</span> (column_name) (column_domain); #  属性的域就是数据类型吧</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> table_name <span class=\"keyword\">drop</span> (column_name);</span><br></pre></td></tr></table></figure>\n<h2 id=\"SQL-查询操作\"><a href=\"#SQL-查询操作\" class=\"headerlink\" title=\"SQL 查询操作\"></a>SQL 查询操作</h2><h3 id=\"查询操作简介\"><a href=\"#查询操作简介\" class=\"headerlink\" title=\"查询操作简介\"></a>查询操作简介</h3><p>在一个关系上进行“查询操作”将查询结果构建成一个关系 作为返回。=&gt; 关系</p>\n<h3 id=\"单关系查询\"><a href=\"#单关系查询\" class=\"headerlink\" title=\"单关系查询\"></a>单关系查询</h3><h3 id=\"多关系查询\"><a href=\"#多关系查询\" class=\"headerlink\" title=\"多关系查询\"></a>多关系查询</h3><h2 id=\"SQL-index-索引\"><a href=\"#SQL-index-索引\" class=\"headerlink\" title=\"SQL index 索引\"></a>SQL index 索引</h2><h2 id=\"SQL-AGGREGATES-聚集函数\"><a href=\"#SQL-AGGREGATES-聚集函数\" class=\"headerlink\" title=\"SQL  AGGREGATES 聚集函数\"></a>SQL  AGGREGATES 聚集函数</h2><p>作用将从结果中计算整个集合中的一些类似 sum average 这样的函数</p>\n<p>聚集函数最后返回的是一个值，你得保证这次查询的东西都在这个结果中</p>\n<ul>\n<li>AVG()          支持DISTINCT</li>\n<li>MIN()</li>\n<li>MAX()</li>\n<li>SUM()        支持DISTINCT</li>\n<li>COUNT()   支持DISTINCT  <ul>\n<li>count(*) 是有优化的 这个更快！</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> column_name) <span class=\"keyword\">from</span> table_name <span class=\"keyword\">where</span> column_name <span class=\"keyword\">like</span> &quot;正则&quot;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GROUP-BY-聚集函数的使用技巧\"><a href=\"#GROUP-BY-聚集函数的使用技巧\" class=\"headerlink\" title=\"GROUP BY + 聚集函数的使用技巧\"></a>GROUP BY + 聚集函数的使用技巧</h3><h3 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h3><h3 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a>ORDER BY</h3><p>ASC </p>\n<p>DESC</p>\n<h2 id=\"SQL中的模糊查询\"><a href=\"#SQL中的模糊查询\" class=\"headerlink\" title=\"SQL中的模糊查询\"></a>SQL中的模糊查询</h2><p>使用LIKE 以及 正则匹配来进行模糊查询（匹配）</p>\n<h2 id=\"SQLite-JOIN\"><a href=\"#SQLite-JOIN\" class=\"headerlink\" title=\"SQLite JOIN\"></a>SQLite JOIN</h2><h3 id=\"交叉连接-CROSS-JOIN\"><a href=\"#交叉连接-CROSS-JOIN\" class=\"headerlink\" title=\"交叉连接 CROSS JOIN\"></a>交叉连接 CROSS JOIN</h3><p>将第一个表的每一行与第二个表的每一行进行匹配 假设两个表是x y行，那么输出就是x*y行</p>\n<p>语法示例</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T1 <span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> T2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3><p>和cross join差不多，但是在连接两个表的时候对每一次的匹配进行比较，当满足连接谓词的时候才会形成一个结果行。</p>\n<p>语法示例    </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T1 (<span class=\"keyword\">INNER</span>) <span class=\"keyword\">JOIN</span> T2 <span class=\"keyword\">ON</span> <span class=\"keyword\">condition</span>;</span><br></pre></td></tr></table></figure>\n<p>自然连接</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T1 <span class=\"keyword\">NATURAL</span> <span class=\"keyword\">JOIN</span> T2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><h2 id=\"UNION-操作\"><a href=\"#UNION-操作\" class=\"headerlink\" title=\"UNION 操作\"></a>UNION 操作</h2><p>UNION</p>\n<p><code>UNION</code>是一种操作符，它用于将两个或多个<code>SELECT</code>语句的结果集合并为一个结果集。具体来说，<code>UNION</code>操作符会将多个<code>SELECT</code>语句的结果集合并成一个结果集，并自动去除其中的重复行。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table2</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table3</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>UNION ALL</code>是一种用于将两个或多个<code>SELECT</code>语句的结果集合并为一个结果集的操作符。它与<code>UNION</code>操作符不同的是，它不会自动去除结果集中的重复行，而是将所有的行都保留下来。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table2</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table3</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"递归查询\"><a href=\"#递归查询\" class=\"headerlink\" title=\"递归查询\"></a>递归查询</h2><p>递归查询的结构</p>\n<ul>\n<li>初始查询</li>\n<li>递归查询</li>\n</ul>\n<h1 id=\"CMU15445-HomeWork-1\"><a href=\"#CMU15445-HomeWork-1\" class=\"headerlink\" title=\"CMU15445-HomeWork-1\"></a>CMU15445-HomeWork-1</h1><p>==任务==：写sql脚本，使用sql语句在IMDb dataset里面查询/完成指定任务</p>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>本机环境：VMware ==Ubuntu 22.04.2 server==</p>\n<ul>\n<li>安装sqlite3</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前linuxOS 是否默认安装了sqlite3</span></span><br><span class=\"line\">&gt; sqlite3</span><br><span class=\"line\"><span class=\"comment\"># 如果没有就sudo 安装</span></span><br><span class=\"line\">&gt; sudo apt install sqlite3</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下载数据</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; wget https://15445.courses.cs.cmu.edu/fall2022/files/imdb-cmudb2022.db.gz</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(可选) 检查数据的完整性</li>\n<li>给各个表创建索引</li>\n<li>了解数据中的各个表</li>\n</ul>\n<p><img src=\"https://15445.courses.cs.cmu.edu/fall2022/files/schema2022.png\" alt=\"schema\"></p>\n<ul>\n<li><p>people</p>\n</li>\n<li><p>title</p>\n</li>\n<li><p>akas</p>\n</li>\n<li>rating</li>\n<li>crew</li>\n</ul>\n<blockquote>\n<p>TIPS:</p>\n<p>本次作业中，将title表称作 works</p>\n<p>在akas表中不会使用 <code>region</code>, <code>types</code>, <code>attributes</code> 或者<code>is_original_title</code></p>\n<p>对于crew表，不会使用  <code>job</code> or <code>characters</code>，当考虑一个人的职责的时候指的就是 <code>category</code></p>\n</blockquote>\n<h2 id=\"作业准备\"><a href=\"#作业准备\" class=\"headerlink\" title=\"作业准备\"></a>作业准备</h2><h3 id=\"placeholder-folder-的构建\"><a href=\"#placeholder-folder-的构建\" class=\"headerlink\" title=\"placeholder folder 的构建\"></a>placeholder folder 的构建</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">mkdir</span> placeholder</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> placeholder</span><br><span class=\"line\">$ <span class=\"built_in\">touch</span> \\</span><br><span class=\"line\">  q1_sample.sql \\</span><br><span class=\"line\">  q2_sci_fi.sql \\</span><br><span class=\"line\">  q3_oldest_people.sql \\</span><br><span class=\"line\">  q4_crew_appears_most.sql \\</span><br><span class=\"line\">  q5_decade_ratings.sql \\</span><br><span class=\"line\">  q6_cruiseing_altitude.sql \\</span><br><span class=\"line\">  q7_year_of_thieves.sql \\</span><br><span class=\"line\">  q8_kidman_colleagues.sql \\</span><br><span class=\"line\">  q9_9th_decile_ratings.sql \\</span><br><span class=\"line\">  q10_house_of_the_dragon.sql</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> ..</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q1-0-point-提交示例\"><a href=\"#Q1-0-point-提交示例\" class=\"headerlink\" title=\"Q1 [0 point] 提交示例\"></a>Q1 [0 point] 提交示例</h3><p>例如按照如下的sql代码为样例写你的作业。</p>\n<h3 id=\"Q2-5-points-找最长时间sci-fi\"><a href=\"#Q2-5-points-找最长时间sci-fi\" class=\"headerlink\" title=\"Q2 [5 points] 找最长时间sci_fi\"></a>Q2 [5 points] 找最长时间sci_fi</h3><p>要求：</p>\n<ul>\n<li>10个最长时间的works  grenre 是SCI_FI</li>\n<li>输出 title  premiere date（首映日期） 电影时长+（min）</li>\n</ul>\n<div class=\"tabs\" id=\"\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#-1\">第一次提交（存在错误）</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#-2\">第二次提交</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"-1\"><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> primary_title, premiered, <span class=\"built_in\">CAST</span>(runtime_minutes <span class=\"keyword\">AS</span> <span class=\"type\">VARCHAR</span>) <span class=\"operator\">||</span> &quot;(mins)&quot;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> title</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> genres <span class=\"keyword\">LIKE</span> &quot;%Sci-Fi%&quot;</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> runtime_mins <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<p>不会是少了一个空格吧</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"-2\"><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> primary_title, premiered, <span class=\"built_in\">CAST</span>(runtime_minutes <span class=\"keyword\">AS</span> <span class=\"type\">VARCHAR</span>) <span class=\"operator\">||</span> &quot; (mins)&quot;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> title</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> genres <span class=\"keyword\">LIKE</span> &quot;%Sci-Fi%&quot;</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> runtime_mins <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<p>如何在输出的东西上任意添加想要附加的字符串？</p>\n<p>将int类型的数据映射成字符串 CAST（）然后使用字符串连接符号 || 连接</p>\n<h3 id=\"Q3-5-points-最老的人\"><a href=\"#Q3-5-points-最老的人\" class=\"headerlink\" title=\"Q3 [5 points] 最老的人\"></a>Q3 [5 points] 最老的人</h3><p>要求：</p>\n<ul>\n<li>这些人需要在1900年之后出生</li>\n<li>你需要考虑没死的人</li>\n<li>输出：首先按照年龄排序，相同年龄按照名字的字典序排序</li>\n<li>输出20个结果  并且按照 name|age 的格式输出</li>\n</ul>\n<p>分析：</p>\n<p>显然考察的是运算操作。people中born的字段是int died字段也一样。先看没死的人died是不是null</p>\n<p>如何计算没死的人的年龄 并将他们放到一起</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\">\t<span class=\"keyword\">WHEN</span> died <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">\t<span class=\"keyword\">THEN</span> died <span class=\"operator\">-</span> born</span><br><span class=\"line\">\t<span class=\"keyword\">ELSE</span> <span class=\"number\">2022</span> <span class=\"operator\">-</span> born</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> age</span><br></pre></td></tr></table></figure>\n<div class=\"tabs\" id=\"test1\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#test1-1\">第一次提交（出错）</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#test1-2\">第二次提交</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"test1-1\"><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> name,</span><br><span class=\"line\">\t<span class=\"keyword\">CASE</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">WHEN</span> died <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">THEN</span> <span class=\"number\">2023</span><span class=\"operator\">-</span>died</span><br><span class=\"line\">\t\t<span class=\"keyword\">ELSE</span> died<span class=\"operator\">-</span>born</span><br><span class=\"line\">    <span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> age</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> people</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> born<span class=\"operator\">&gt;=</span><span class=\"number\">1900</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>, name <span class=\"keyword\">ASC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<p>可能是时间上出错了 今年是2023年</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"test1-2\"><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT name,</span><br><span class=\"line\">\tCASE</span><br><span class=\"line\">\t\tWHEN died IS NULL</span><br><span class=\"line\">\t\tTHEN 2022-born</span><br><span class=\"line\">\t\tELSE died-born</span><br><span class=\"line\">    END AS age</span><br><span class=\"line\">FROM people</span><br><span class=\"line\">WHERE born&gt;=1900</span><br><span class=\"line\">ORDER BY age DESC, name ASC</span><br><span class=\"line\">LIMIT 20;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"Q4-10-points-出现次数最多的人\"><a href=\"#Q4-10-points-出现次数最多的人\" class=\"headerlink\" title=\"Q4 [10 points] 出现次数最多的人\"></a>Q4 [10 points] 出现次数最多的人</h3><p>要求：</p>\n<ul>\n<li>出现次数最多的人</li>\n<li>输出格式 name 出现次数</li>\n<li>最多的前20人</li>\n</ul>\n<p>分析：</p>\n<ul>\n<li>将titles 和 crew join到一起</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p.name,<span class=\"built_in\">count</span>(p.person_id) <span class=\"keyword\">AS</span> appear_times</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> crew <span class=\"keyword\">AS</span> c, people <span class=\"keyword\">AS</span> p</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> c.person_id<span class=\"operator\">=</span><span class=\"operator\">=</span>p.person_id</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> p.person_id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> appear_times <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用inner join 也是一个不错的选择</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> name,<span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> appear_times</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> people <span class=\"keyword\">AS</span> p <span class=\"keyword\">JOIN</span> crew <span class=\"keyword\">AS</span> c</span><br><span class=\"line\"><span class=\"keyword\">ON</span> p.person_id<span class=\"operator\">=</span><span class=\"operator\">=</span>c.person_id</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> p.person_id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> appear_times <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<p>出错原因：有些细节没注意。</p>\n<h3 id=\"Q5-10-points\"><a href=\"#Q5-10-points\" class=\"headerlink\" title=\"Q5 [10 points]\"></a>Q5 [10 points]</h3><p>要求：</p>\n<ul>\n<li>每十年的平均评分、最高评分、最低评分、上映的电影数量</li>\n<li>按照平均评分降序排序，同分按照年份升序排序，average rating 保留两位小数</li>\n</ul>\n<p>分析：</p>\n<ul>\n<li>将rating 和 title做一个inner join</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">\t<span class=\"built_in\">CAST</span>(premiered<span class=\"operator\">/</span><span class=\"number\">10</span><span class=\"operator\">*</span><span class=\"number\">10</span> <span class=\"keyword\">AS</span> <span class=\"type\">VARCHAR</span>) <span class=\"operator\">||</span> &quot;s&quot; <span class=\"keyword\">AS</span> <span class=\"keyword\">year</span>, </span><br><span class=\"line\">\tROUND(<span class=\"built_in\">AVG</span>(rating),<span class=\"number\">2</span>) <span class=\"keyword\">AS</span> avg_rating,</span><br><span class=\"line\">    <span class=\"built_in\">MAX</span>(rating),</span><br><span class=\"line\">    <span class=\"built_in\">MIN</span>(rating),</span><br><span class=\"line\">    <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">\ttitles <span class=\"keyword\">AS</span> t</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> </span><br><span class=\"line\">\tratings <span class=\"keyword\">AS</span> r </span><br><span class=\"line\"><span class=\"keyword\">ON</span> t.title_id<span class=\"operator\">=</span>r.title_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> premiered <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">year</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> avg_rating <span class=\"keyword\">DESC</span>, <span class=\"keyword\">year</span> <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n<p>sqlite 整除  / 就是整除</p>\n<p>sqlite 保留n位小数 round </p>\n<p>sqlite 取整 ceil floor</p>\n<h3 id=\"Q6-10-points-找人\"><a href=\"#Q6-10-points-找人\" class=\"headerlink\" title=\"Q6  [10 points] 找人\"></a>Q6  [10 points] 找人</h3><p>要求：</p>\n<ul>\n<li>一个人 名字里有 Cruise  生于1962</li>\n<li>vote 数量最多的作品 前十 </li>\n<li>输出格式： 作品名称 | 投票数</li>\n</ul>\n<p>分析：</p>\n<ul>\n<li>多表联合查询</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> t.primary_title,votes</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">\tratings <span class=\"keyword\">AS</span> r</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span></span><br><span class=\"line\">\ttitles <span class=\"keyword\">AS</span> t</span><br><span class=\"line\"><span class=\"keyword\">ON</span> t.title_id <span class=\"operator\">=</span> r.title_id</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span></span><br><span class=\"line\">\tcrew <span class=\"keyword\">AS</span> c</span><br><span class=\"line\"><span class=\"keyword\">ON</span> t.title_id <span class=\"operator\">=</span> c.title_id</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> </span><br><span class=\"line\">\tpeople <span class=\"keyword\">AS</span> p</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.person_id <span class=\"operator\">=</span> p.person_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> p.name <span class=\"keyword\">LIKE</span> &quot;%Cruise%&quot; <span class=\"keyword\">AND</span> p.born<span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"number\">1962</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> votes <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>感觉有点慢</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WITH</span> cruise_movies <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">          crew.title_id <span class=\"keyword\">AS</span> title_id</span><br><span class=\"line\">     <span class=\"keyword\">FROM</span> crew</span><br><span class=\"line\">     <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">          people <span class=\"keyword\">ON</span> crew.person_id <span class=\"operator\">=</span> people.person_id</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> people.name <span class=\"keyword\">LIKE</span> &quot;%Cruise%&quot; <span class=\"keyword\">AND</span> people.born <span class=\"operator\">=</span> <span class=\"number\">1962</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">     titles.primary_title <span class=\"keyword\">as</span> name,</span><br><span class=\"line\">     ratings.votes <span class=\"keyword\">as</span> votes</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">     cruise_movies</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">     ratings <span class=\"keyword\">ON</span> cruise_movies.title_id <span class=\"operator\">=</span> ratings.title_id</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">     titles <span class=\"keyword\">ON</span> cruise_movies.title_id <span class=\"operator\">=</span> titles.title_id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> votes <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q7-15-points-找特定年份的数据\"><a href=\"#Q7-15-points-找特定年份的数据\" class=\"headerlink\" title=\"Q7 [15 points] 找特定年份的数据\"></a>Q7 [15 points] 找特定年份的数据</h3><p>要求：</p>\n<ul>\n<li>找和Army of Thieves同年上映的电影数量</li>\n<li>输出这一年的电影数量</li>\n</ul>\n<p>分析：</p>\n<ul>\n<li>嵌套查询、子查询</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> title_id) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> titles</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> premiered <span class=\"operator\">=</span> (</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> premiered</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> titles</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> primary_title <span class=\"operator\">=</span> &quot;Army of Thieves&quot;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q8-15-points\"><a href=\"#Q8-15-points\" class=\"headerlink\" title=\"Q8 [15 points]\"></a>Q8 [15 points]</h3><p>要求：</p>\n<ul>\n<li>找到所有与Nicole Kidman  (1967 出生的) 共同出演的演员</li>\n<li>将所有的actor / actress按照名字的字典序排序</li>\n</ul>\n<p>with 前置条件的运用</p>\n<p>分析（过程）：</p>\n<ul>\n<li>首先将这个人的出演过的作品id列出</li>\n<li>通过这个作品id查所有出现过的人的person -id （使用distinct去重）</li>\n<li>查people表找上述person-id里面的人的名字</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> title_id </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">\tcrew <span class=\"keyword\">AS</span> c</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span></span><br><span class=\"line\">\tpeople <span class=\"keyword\">AS</span> p</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.person_id <span class=\"operator\">=</span> p.person_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> p.name <span class=\"operator\">=</span> &quot;Nicole Kidman&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WITH</span> kidman_titles <span class=\"keyword\">AS</span> (</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> title_id </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> crew <span class=\"keyword\">JOIN</span> people <span class=\"keyword\">ON</span> crew.person_id <span class=\"operator\">=</span> people.person_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> people.name <span class=\"operator\">=</span> &quot;Nicole Kidman&quot; <span class=\"keyword\">AND</span> people.born <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">1967</span></span><br><span class=\"line\">),</span><br><span class=\"line\"><span class=\"keyword\">WITH</span> kidman_colleagues <span class=\"keyword\">AS</span>(</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span>(person_id) <span class=\"keyword\">AS</span> id</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> crew </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> (category <span class=\"operator\">=</span> &quot;actor&quot; <span class=\"keyword\">or</span> category <span class=\"operator\">=</span> &quot;actress&quot;) <span class=\"keyword\">AND</span> crew.title_id <span class=\"keyword\">in</span> kidman_titles</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> people</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> people.person_id <span class=\"keyword\">in</span> kidman_colleagues.id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q9-15-points\"><a href=\"#Q9-15-points\" class=\"headerlink\" title=\"Q9 [15 points]\"></a>Q9 [15 points]</h3><p>要求：</p>\n<ul>\n<li>出生于1955年的演员</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WITH</span> actors_and_movies_1955 <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">          people.person_id,</span><br><span class=\"line\">          people.name,</span><br><span class=\"line\">          titles.title_id,</span><br><span class=\"line\">          titles.primary_title</span><br><span class=\"line\">     <span class=\"keyword\">FROM</span></span><br><span class=\"line\">          people</span><br><span class=\"line\">     <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">          crew <span class=\"keyword\">ON</span> people.person_id <span class=\"operator\">=</span> crew.person_id</span><br><span class=\"line\">     <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">          titles <span class=\"keyword\">ON</span> crew.title_id <span class=\"operator\">=</span> titles.title_id</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> people.born <span class=\"operator\">=</span> <span class=\"number\">1955</span> <span class=\"keyword\">AND</span> titles.type <span class=\"operator\">=</span> &quot;movie&quot;</span><br><span class=\"line\">),</span><br><span class=\"line\">actor_ratings <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">          name,</span><br><span class=\"line\">          ROUND(<span class=\"built_in\">AVG</span>(ratings.rating), <span class=\"number\">2</span>) <span class=\"keyword\">as</span> rating</span><br><span class=\"line\">     <span class=\"keyword\">FROM</span> ratings</span><br><span class=\"line\">     <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> actors_and_movies_1955 <span class=\"keyword\">ON</span> ratings.title_id <span class=\"operator\">=</span> actors_and_movies_1955.title_id</span><br><span class=\"line\">     <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> actors_and_movies_1955.person_id</span><br><span class=\"line\">),</span><br><span class=\"line\">quartiles <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span>, <span class=\"built_in\">NTILE</span>(<span class=\"number\">10</span>) <span class=\"keyword\">OVER</span> (<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> rating <span class=\"keyword\">ASC</span>) <span class=\"keyword\">AS</span> RatingQuartile <span class=\"keyword\">FROM</span> actor_ratings</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name, rating</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> quartiles</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> RatingQuartile <span class=\"operator\">=</span> <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> rating <span class=\"keyword\">DESC</span>, name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q10-15-points\"><a href=\"#Q10-15-points\" class=\"headerlink\" title=\"Q10 [15 points]\"></a>Q10 [15 points]</h3><p>要求：</p>\n<ul>\n<li>使用逗号和空格连接TV 龙之家族的 所有unique titles 这些titles必须要按照字典序来</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> p <span class=\"keyword\">as</span> (</span><br><span class=\"line\">      <span class=\"keyword\">select</span> titles.primary_title <span class=\"keyword\">as</span> name, akas.title <span class=\"keyword\">as</span> dubbed</span><br><span class=\"line\">      <span class=\"keyword\">from</span> titles</span><br><span class=\"line\">      <span class=\"keyword\">inner</span> <span class=\"keyword\">join</span> akas <span class=\"keyword\">on</span> titles.title_id <span class=\"operator\">=</span> akas.title_id</span><br><span class=\"line\">      <span class=\"keyword\">where</span> titles.primary_title <span class=\"operator\">=</span> &quot;House of the Dragon&quot; <span class=\"keyword\">AND</span> titles.type <span class=\"operator\">=</span> <span class=\"string\">&#x27;tvSeries&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> titles.primary_title, akas.title</span><br><span class=\"line\">      <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> akas.title</span><br><span class=\"line\">),</span><br><span class=\"line\">c <span class=\"keyword\">as</span> (</span><br><span class=\"line\">      <span class=\"keyword\">select</span> <span class=\"built_in\">row_number</span>() <span class=\"keyword\">over</span> (<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> p.name <span class=\"keyword\">asc</span>) <span class=\"keyword\">as</span> seqnum, p.dubbed <span class=\"keyword\">as</span> dubbed</span><br><span class=\"line\">      <span class=\"keyword\">from</span> p</span><br><span class=\"line\">),</span><br><span class=\"line\">flattened <span class=\"keyword\">as</span> (</span><br><span class=\"line\">      <span class=\"keyword\">select</span> seqnum, dubbed</span><br><span class=\"line\">      <span class=\"keyword\">from</span> c</span><br><span class=\"line\">      <span class=\"keyword\">where</span> seqnum <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\">      <span class=\"keyword\">select</span> c.seqnum, f.dubbed <span class=\"operator\">||</span> <span class=\"string\">&#x27;, &#x27;</span> <span class=\"operator\">||</span> c.dubbed</span><br><span class=\"line\">      <span class=\"keyword\">from</span> c <span class=\"keyword\">join</span></span><br><span class=\"line\">            flattened f</span><br><span class=\"line\">            <span class=\"keyword\">on</span> c.seqnum <span class=\"operator\">=</span> f.seqnum <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">select</span> dubbed <span class=\"keyword\">from</span> flattened</span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> seqnum <span class=\"keyword\">desc</span> limit <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"完成后将sql文件打包\"><a href=\"#完成后将sql文件打包\" class=\"headerlink\" title=\"完成后将sql文件打包\"></a>完成后将sql文件打包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ zip -j submission.zip placeholder/*.sql</span><br></pre></td></tr></table></figure>\n<h1 id=\"CMU15445-PROJECT-0\"><a href=\"#CMU15445-PROJECT-0\" class=\"headerlink\" title=\"CMU15445-PROJECT-0\"></a>CMU15445-PROJECT-0</h1><h2 id=\"project-0-任务介绍\"><a href=\"#project-0-任务介绍\" class=\"headerlink\" title=\"project-0 任务介绍\"></a>project-0 任务介绍</h2><p>目标：</p>\n<blockquote>\n<p>implement a key-value store backed by a concurrent <a href=\"https://zh.wikipedia.org/wiki/Trie\">trie</a></p>\n</blockquote>\n<h2 id=\"环境搭建：\"><a href=\"#环境搭建：\" class=\"headerlink\" title=\"环境搭建：\"></a>环境搭建：</h2><p>使用的是本地的VMware里面的Ubuntu server 22.04.x版本的</p>\n<p>IDE：CLion 通过ssh连接虚拟机</p>\n<h2 id=\"前置知识的学习\"><a href=\"#前置知识的学习\" class=\"headerlink\" title=\"前置知识的学习\"></a>前置知识的学习</h2><p>trie也叫 前缀树、字典树。之前没接触过。先做一下leetcode上的有关前缀树的定义的题目熟悉一下前缀树 </p>\n<h2 id=\"前缀树\"><a href=\"#前缀树\" class=\"headerlink\" title=\"前缀树\"></a>前缀树</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>is_end bool 表示是否是单词的结束 true表示当前节点为单词的结束</p>\n<p>map<char,Trie*> children_nodes; 子节点的连接。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Trie</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 存储前缀树的存储数据结构</span></span><br><span class=\"line\">    map&lt;<span class=\"type\">char</span>,Trie*&gt; children_node;</span><br><span class=\"line\">    <span class=\"type\">bool</span> is_End;</span><br><span class=\"line\">    <span class=\"comment\">// 内置的搜索前缀的工具函数</span></span><br><span class=\"line\">    <span class=\"function\">Trie* <span class=\"title\">searchPrefix</span><span class=\"params\">(string prefix)</span></span>&#123;</span><br><span class=\"line\">        Trie* current_node = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:prefix)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(current_node-&gt;children_node.<span class=\"built_in\">find</span>(c)==current_node-&gt;children_node.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            current_node = current_node-&gt;children_node[c];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> current_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Trie</span>() &#123;</span><br><span class=\"line\">        is_End = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(string word)</span> </span>&#123;</span><br><span class=\"line\">        Trie* current_node = <span class=\"keyword\">this</span>;  <span class=\"comment\">// 初始指针指向当前根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:word)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(current_node-&gt;children_node.<span class=\"built_in\">find</span>(c)==current_node-&gt;children_node.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 表示当前字节点集合中没有这个  所以创建一个</span></span><br><span class=\"line\">                current_node-&gt;children_node[c] = <span class=\"keyword\">new</span> <span class=\"built_in\">Trie</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            current_node = current_node-&gt;children_node[c];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current_node-&gt;is_End = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">search</span><span class=\"params\">(string word)</span> </span>&#123;</span><br><span class=\"line\">        Trie* current_node = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">searchPrefix</span>(word);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> current_node!=<span class=\"literal\">nullptr</span> &amp;&amp; current_node-&gt;is_End;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">startsWith</span><span class=\"params\">(string prefix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">searchPrefix</span>(prefix)!=<span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"左值、右值、左值引用、右值引用\"><a href=\"#左值、右值、左值引用、右值引用\" class=\"headerlink\" title=\"左值、右值、左值引用、右值引用\"></a>左值、右值、左值引用、右值引用</h3><p>左值：可以放在赋值号的左边充当被赋值的对象，也可以在右边做赋值对象，充当左值的“东西”必须要有在内存上的存储空间。</p>\n<p>右值：智能在赋值号的右边，做赋值对象，可以没有存储空间，可以只是一个在cpu寄存器上的一个数据。右值不能被修改</p>\n<p>左值引用：引用的是一个对象。</p>\n<p>右值引用：引用的是一个数据。这个只能作为右值，他不在内存上占有存储空间。</p>\n<p>作用用来提高程序运行效率，避免多余的拷贝操作。</p>\n<p>std::move()  将一个左值变为右值</p>\n<p>使用临时对象使用的空间，赋值到目标对象中可以节省对内存的释放。</p>\n<p>==例如==</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\tMyString a; </span><br><span class=\"line\">\ta = <span class=\"built_in\">MyString</span>(<span class=\"string\">&quot;Hello&quot;</span>); </span><br><span class=\"line\">\tstd::vector&lt;MyString&gt; vec; </span><br><span class=\"line\">\tvec.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">MyString</span>(<span class=\"string\">&quot;World&quot;</span>)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数在程序结束时一共调用了四次析构函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy Assignment is called! source: Hello</span><br><span class=\"line\">Destructor is called!</span><br><span class=\"line\">Copy Constructor is called! source: World</span><br><span class=\"line\">Destructor is called!</span><br><span class=\"line\">Destructor is called!  // 最后两次的析构函数时a 和 vector0 被释放</span><br><span class=\"line\">Destructor is called!</span><br></pre></td></tr></table></figure>\n<h4 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h4><p>unique_ptr()</p>\n<p>独占资源所有权指针，该指针式moveonly的 也就是智能通过move函数将其给赋值到一个左值中</p>\n<p>创建：</p>\n<p>shared_ptr()</p>\n<p>共享资源所有权指针</p>\n<p>weak_ptr()</p>\n<p>共享资源观察者</p>\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>将一个基类的指针/引用 指向继承类的指针/引用，dynamic_cast将会判断该基类是否真的指向继承类，如果否则返回null 或者报错</p>\n<h1 id=\"Linux-一些命令的小记\"><a href=\"#Linux-一些命令的小记\" class=\"headerlink\" title=\"Linux 一些命令的小记\"></a>Linux 一些命令的小记</h1><p>创建目录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">mkdir</span>  path/directory-name</span><br></pre></td></tr></table></figure>\n<p>创建文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">touch</span>  path/file-name</span><br></pre></td></tr></table></figure>\n<p>创建多个文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">touch</span> \\</span><br><span class=\"line\"></span><br><span class=\"line\">file-name1 \\</span><br><span class=\"line\"></span><br><span class=\"line\">file-name2 \\</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>sqlite 执行sql文件</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline orange\"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p>\n</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-27</p>\n</div></div><div class='timeline-item-content'><p>初步完成了homework1 但是上传测试结果不理想</p>\n</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-28</p>\n</div></div><div class='timeline-item-content'><p>今天来找homework中的错误，争取这次满分通过测试.</p>\n</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-29</p>\n</div></div><div class='timeline-item-content'><p>完成project-0</p>\n</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-30</p>\n</div></div><div class='timeline-item-content'><p>project0 终于运行起来了，哭。</p>\n</div></div></div>\n<p>[TOC]</p>\n<h1 id=\"数据库基本介绍\"><a href=\"#数据库基本介绍\" class=\"headerlink\" title=\"数据库基本介绍\"></a>数据库基本介绍</h1><h2 id=\"SQL语句基础\"><a href=\"#SQL语句基础\" class=\"headerlink\" title=\"SQL语句基础\"></a>SQL语句基础</h2><h3 id=\"SQL-中的基本数据类型\"><a href=\"#SQL-中的基本数据类型\" class=\"headerlink\" title=\"SQL 中的基本数据类型\"></a>SQL 中的基本数据类型</h3><ul>\n<li>char(n)</li>\n<li>varchar(n)  指定最长为n的字符串</li>\n<li>numeric(p,q)   一共有p位 q位位小数位</li>\n<li>int   </li>\n<li>smallint</li>\n<li>real precision / double precision  单精度/双精度 浮点数</li>\n<li>float(n)  精度至少为n的浮点数</li>\n</ul>\n<h3 id=\"完整性约束-概念\"><a href=\"#完整性约束-概念\" class=\"headerlink\" title=\"完整性约束 概念\"></a>完整性约束 概念</h3><ul>\n<li>primary key  主键 主码 属性： 虽然在create table时是可选的，每个元组的主键的值是不能重复的。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">primary</span> key (colunm)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>foreign key reference： 外键</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">foreign</span> key (<span class=\"keyword\">column</span>) reference (<span class=\"keyword\">table</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>not null  非空</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> stus(</span><br><span class=\"line\">\tstu_id <span class=\"type\">int</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">\tstu_name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">primary</span> key (stu_id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>==sql 禁止破环完整性约束的操作出现==</p>\n<p>如果任意一条插入到当前关系中的元组有违反完整性约束的条件存在 sql就会报错。</p>\n<h3 id=\"sql-插入元组操作\"><a href=\"#sql-插入元组操作\" class=\"headerlink\" title=\"sql 插入元组操作\"></a>sql 插入元组操作</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> (<span class=\"keyword\">table</span>) <span class=\"keyword\">values</span> ([v1,[v2,[v3...]]]);</span><br></pre></td></tr></table></figure>\n<h3 id=\"sql-删除一个关系（表）中所有元组操作\"><a href=\"#sql-删除一个关系（表）中所有元组操作\" class=\"headerlink\" title=\"sql 删除一个关系（表）中所有元组操作\"></a>sql 删除一个关系（表）中所有元组操作</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> table_name; # 这种方式会保留表（关系）可以继续对这个表进行操作</span><br></pre></td></tr></table></figure>\n<h3 id=\"sql-删除关系操作（删除表？）\"><a href=\"#sql-删除关系操作（删除表？）\" class=\"headerlink\" title=\"sql 删除关系操作（删除表？）\"></a>sql 删除关系操作（删除表？）</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> table_name; # 删除关系</span><br></pre></td></tr></table></figure>\n<p>drop 删除了一个table 和这个table相关的外键会怎样呢？</p>\n<h3 id=\"sql-为关系增加-删除-属性\"><a href=\"#sql-为关系增加-删除-属性\" class=\"headerlink\" title=\"sql 为关系增加/删除 属性\"></a>sql 为关系增加/删除 属性</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> table_name <span class=\"keyword\">add</span> (column_name) (column_domain); #  属性的域就是数据类型吧</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> table_name <span class=\"keyword\">drop</span> (column_name);</span><br></pre></td></tr></table></figure>\n<h2 id=\"SQL-查询操作\"><a href=\"#SQL-查询操作\" class=\"headerlink\" title=\"SQL 查询操作\"></a>SQL 查询操作</h2><h3 id=\"查询操作简介\"><a href=\"#查询操作简介\" class=\"headerlink\" title=\"查询操作简介\"></a>查询操作简介</h3><p>在一个关系上进行“查询操作”将查询结果构建成一个关系 作为返回。=&gt; 关系</p>\n<h3 id=\"单关系查询\"><a href=\"#单关系查询\" class=\"headerlink\" title=\"单关系查询\"></a>单关系查询</h3><h3 id=\"多关系查询\"><a href=\"#多关系查询\" class=\"headerlink\" title=\"多关系查询\"></a>多关系查询</h3><h2 id=\"SQL-index-索引\"><a href=\"#SQL-index-索引\" class=\"headerlink\" title=\"SQL index 索引\"></a>SQL index 索引</h2><h2 id=\"SQL-AGGREGATES-聚集函数\"><a href=\"#SQL-AGGREGATES-聚集函数\" class=\"headerlink\" title=\"SQL  AGGREGATES 聚集函数\"></a>SQL  AGGREGATES 聚集函数</h2><p>作用将从结果中计算整个集合中的一些类似 sum average 这样的函数</p>\n<p>聚集函数最后返回的是一个值，你得保证这次查询的东西都在这个结果中</p>\n<ul>\n<li>AVG()          支持DISTINCT</li>\n<li>MIN()</li>\n<li>MAX()</li>\n<li>SUM()        支持DISTINCT</li>\n<li>COUNT()   支持DISTINCT  <ul>\n<li>count(*) 是有优化的 这个更快！</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> column_name) <span class=\"keyword\">from</span> table_name <span class=\"keyword\">where</span> column_name <span class=\"keyword\">like</span> &quot;正则&quot;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GROUP-BY-聚集函数的使用技巧\"><a href=\"#GROUP-BY-聚集函数的使用技巧\" class=\"headerlink\" title=\"GROUP BY + 聚集函数的使用技巧\"></a>GROUP BY + 聚集函数的使用技巧</h3><h3 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h3><h3 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a>ORDER BY</h3><p>ASC </p>\n<p>DESC</p>\n<h2 id=\"SQL中的模糊查询\"><a href=\"#SQL中的模糊查询\" class=\"headerlink\" title=\"SQL中的模糊查询\"></a>SQL中的模糊查询</h2><p>使用LIKE 以及 正则匹配来进行模糊查询（匹配）</p>\n<h2 id=\"SQLite-JOIN\"><a href=\"#SQLite-JOIN\" class=\"headerlink\" title=\"SQLite JOIN\"></a>SQLite JOIN</h2><h3 id=\"交叉连接-CROSS-JOIN\"><a href=\"#交叉连接-CROSS-JOIN\" class=\"headerlink\" title=\"交叉连接 CROSS JOIN\"></a>交叉连接 CROSS JOIN</h3><p>将第一个表的每一行与第二个表的每一行进行匹配 假设两个表是x y行，那么输出就是x*y行</p>\n<p>语法示例</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T1 <span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> T2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3><p>和cross join差不多，但是在连接两个表的时候对每一次的匹配进行比较，当满足连接谓词的时候才会形成一个结果行。</p>\n<p>语法示例    </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T1 (<span class=\"keyword\">INNER</span>) <span class=\"keyword\">JOIN</span> T2 <span class=\"keyword\">ON</span> <span class=\"keyword\">condition</span>;</span><br></pre></td></tr></table></figure>\n<p>自然连接</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T1 <span class=\"keyword\">NATURAL</span> <span class=\"keyword\">JOIN</span> T2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><h2 id=\"UNION-操作\"><a href=\"#UNION-操作\" class=\"headerlink\" title=\"UNION 操作\"></a>UNION 操作</h2><p>UNION</p>\n<p><code>UNION</code>是一种操作符，它用于将两个或多个<code>SELECT</code>语句的结果集合并为一个结果集。具体来说，<code>UNION</code>操作符会将多个<code>SELECT</code>语句的结果集合并成一个结果集，并自动去除其中的重复行。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table2</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table3</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>UNION ALL</code>是一种用于将两个或多个<code>SELECT</code>语句的结果集合并为一个结果集的操作符。它与<code>UNION</code>操作符不同的是，它不会自动去除结果集中的重复行，而是将所有的行都保留下来。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table2</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ... <span class=\"keyword\">FROM</span> table3</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"递归查询\"><a href=\"#递归查询\" class=\"headerlink\" title=\"递归查询\"></a>递归查询</h2><p>递归查询的结构</p>\n<ul>\n<li>初始查询</li>\n<li>递归查询</li>\n</ul>\n<h1 id=\"CMU15445-HomeWork-1\"><a href=\"#CMU15445-HomeWork-1\" class=\"headerlink\" title=\"CMU15445-HomeWork-1\"></a>CMU15445-HomeWork-1</h1><p>==任务==：写sql脚本，使用sql语句在IMDb dataset里面查询/完成指定任务</p>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>本机环境：VMware ==Ubuntu 22.04.2 server==</p>\n<ul>\n<li>安装sqlite3</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前linuxOS 是否默认安装了sqlite3</span></span><br><span class=\"line\">&gt; sqlite3</span><br><span class=\"line\"><span class=\"comment\"># 如果没有就sudo 安装</span></span><br><span class=\"line\">&gt; sudo apt install sqlite3</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下载数据</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; wget https://15445.courses.cs.cmu.edu/fall2022/files/imdb-cmudb2022.db.gz</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(可选) 检查数据的完整性</li>\n<li>给各个表创建索引</li>\n<li>了解数据中的各个表</li>\n</ul>\n<p><img src=\"https://15445.courses.cs.cmu.edu/fall2022/files/schema2022.png\" alt=\"schema\"></p>\n<ul>\n<li><p>people</p>\n</li>\n<li><p>title</p>\n</li>\n<li><p>akas</p>\n</li>\n<li>rating</li>\n<li>crew</li>\n</ul>\n<blockquote>\n<p>TIPS:</p>\n<p>本次作业中，将title表称作 works</p>\n<p>在akas表中不会使用 <code>region</code>, <code>types</code>, <code>attributes</code> 或者<code>is_original_title</code></p>\n<p>对于crew表，不会使用  <code>job</code> or <code>characters</code>，当考虑一个人的职责的时候指的就是 <code>category</code></p>\n</blockquote>\n<h2 id=\"作业准备\"><a href=\"#作业准备\" class=\"headerlink\" title=\"作业准备\"></a>作业准备</h2><h3 id=\"placeholder-folder-的构建\"><a href=\"#placeholder-folder-的构建\" class=\"headerlink\" title=\"placeholder folder 的构建\"></a>placeholder folder 的构建</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">mkdir</span> placeholder</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> placeholder</span><br><span class=\"line\">$ <span class=\"built_in\">touch</span> \\</span><br><span class=\"line\">  q1_sample.sql \\</span><br><span class=\"line\">  q2_sci_fi.sql \\</span><br><span class=\"line\">  q3_oldest_people.sql \\</span><br><span class=\"line\">  q4_crew_appears_most.sql \\</span><br><span class=\"line\">  q5_decade_ratings.sql \\</span><br><span class=\"line\">  q6_cruiseing_altitude.sql \\</span><br><span class=\"line\">  q7_year_of_thieves.sql \\</span><br><span class=\"line\">  q8_kidman_colleagues.sql \\</span><br><span class=\"line\">  q9_9th_decile_ratings.sql \\</span><br><span class=\"line\">  q10_house_of_the_dragon.sql</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> ..</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q1-0-point-提交示例\"><a href=\"#Q1-0-point-提交示例\" class=\"headerlink\" title=\"Q1 [0 point] 提交示例\"></a>Q1 [0 point] 提交示例</h3><p>例如按照如下的sql代码为样例写你的作业。</p>\n<h3 id=\"Q2-5-points-找最长时间sci-fi\"><a href=\"#Q2-5-points-找最长时间sci-fi\" class=\"headerlink\" title=\"Q2 [5 points] 找最长时间sci_fi\"></a>Q2 [5 points] 找最长时间sci_fi</h3><p>要求：</p>\n<ul>\n<li>10个最长时间的works  grenre 是SCI_FI</li>\n<li>输出 title  premiere date（首映日期） 电影时长+（min）</li>\n</ul>\n<div class=\"tabs\" id=\"\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#-1\">第一次提交（存在错误）</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#-2\">第二次提交</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"-1\"><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> primary_title, premiered, <span class=\"built_in\">CAST</span>(runtime_minutes <span class=\"keyword\">AS</span> <span class=\"type\">VARCHAR</span>) <span class=\"operator\">||</span> &quot;(mins)&quot;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> title</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> genres <span class=\"keyword\">LIKE</span> &quot;%Sci-Fi%&quot;</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> runtime_mins <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<p>不会是少了一个空格吧</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"-2\"><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> primary_title, premiered, <span class=\"built_in\">CAST</span>(runtime_minutes <span class=\"keyword\">AS</span> <span class=\"type\">VARCHAR</span>) <span class=\"operator\">||</span> &quot; (mins)&quot;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> title</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> genres <span class=\"keyword\">LIKE</span> &quot;%Sci-Fi%&quot;</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> runtime_mins <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<p>如何在输出的东西上任意添加想要附加的字符串？</p>\n<p>将int类型的数据映射成字符串 CAST（）然后使用字符串连接符号 || 连接</p>\n<h3 id=\"Q3-5-points-最老的人\"><a href=\"#Q3-5-points-最老的人\" class=\"headerlink\" title=\"Q3 [5 points] 最老的人\"></a>Q3 [5 points] 最老的人</h3><p>要求：</p>\n<ul>\n<li>这些人需要在1900年之后出生</li>\n<li>你需要考虑没死的人</li>\n<li>输出：首先按照年龄排序，相同年龄按照名字的字典序排序</li>\n<li>输出20个结果  并且按照 name|age 的格式输出</li>\n</ul>\n<p>分析：</p>\n<p>显然考察的是运算操作。people中born的字段是int died字段也一样。先看没死的人died是不是null</p>\n<p>如何计算没死的人的年龄 并将他们放到一起</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\">\t<span class=\"keyword\">WHEN</span> died <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">\t<span class=\"keyword\">THEN</span> died <span class=\"operator\">-</span> born</span><br><span class=\"line\">\t<span class=\"keyword\">ELSE</span> <span class=\"number\">2022</span> <span class=\"operator\">-</span> born</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> age</span><br></pre></td></tr></table></figure>\n<div class=\"tabs\" id=\"test1\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#test1-1\">第一次提交（出错）</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#test1-2\">第二次提交</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"test1-1\"><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> name,</span><br><span class=\"line\">\t<span class=\"keyword\">CASE</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">WHEN</span> died <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">THEN</span> <span class=\"number\">2023</span><span class=\"operator\">-</span>died</span><br><span class=\"line\">\t\t<span class=\"keyword\">ELSE</span> died<span class=\"operator\">-</span>born</span><br><span class=\"line\">    <span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> age</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> people</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> born<span class=\"operator\">&gt;=</span><span class=\"number\">1900</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>, name <span class=\"keyword\">ASC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<p>可能是时间上出错了 今年是2023年</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"test1-2\"><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT name,</span><br><span class=\"line\">\tCASE</span><br><span class=\"line\">\t\tWHEN died IS NULL</span><br><span class=\"line\">\t\tTHEN 2022-born</span><br><span class=\"line\">\t\tELSE died-born</span><br><span class=\"line\">    END AS age</span><br><span class=\"line\">FROM people</span><br><span class=\"line\">WHERE born&gt;=1900</span><br><span class=\"line\">ORDER BY age DESC, name ASC</span><br><span class=\"line\">LIMIT 20;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"Q4-10-points-出现次数最多的人\"><a href=\"#Q4-10-points-出现次数最多的人\" class=\"headerlink\" title=\"Q4 [10 points] 出现次数最多的人\"></a>Q4 [10 points] 出现次数最多的人</h3><p>要求：</p>\n<ul>\n<li>出现次数最多的人</li>\n<li>输出格式 name 出现次数</li>\n<li>最多的前20人</li>\n</ul>\n<p>分析：</p>\n<ul>\n<li>将titles 和 crew join到一起</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p.name,<span class=\"built_in\">count</span>(p.person_id) <span class=\"keyword\">AS</span> appear_times</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> crew <span class=\"keyword\">AS</span> c, people <span class=\"keyword\">AS</span> p</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> c.person_id<span class=\"operator\">=</span><span class=\"operator\">=</span>p.person_id</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> p.person_id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> appear_times <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用inner join 也是一个不错的选择</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> name,<span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> appear_times</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> people <span class=\"keyword\">AS</span> p <span class=\"keyword\">JOIN</span> crew <span class=\"keyword\">AS</span> c</span><br><span class=\"line\"><span class=\"keyword\">ON</span> p.person_id<span class=\"operator\">=</span><span class=\"operator\">=</span>c.person_id</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> p.person_id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> appear_times <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<p>出错原因：有些细节没注意。</p>\n<h3 id=\"Q5-10-points\"><a href=\"#Q5-10-points\" class=\"headerlink\" title=\"Q5 [10 points]\"></a>Q5 [10 points]</h3><p>要求：</p>\n<ul>\n<li>每十年的平均评分、最高评分、最低评分、上映的电影数量</li>\n<li>按照平均评分降序排序，同分按照年份升序排序，average rating 保留两位小数</li>\n</ul>\n<p>分析：</p>\n<ul>\n<li>将rating 和 title做一个inner join</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">\t<span class=\"built_in\">CAST</span>(premiered<span class=\"operator\">/</span><span class=\"number\">10</span><span class=\"operator\">*</span><span class=\"number\">10</span> <span class=\"keyword\">AS</span> <span class=\"type\">VARCHAR</span>) <span class=\"operator\">||</span> &quot;s&quot; <span class=\"keyword\">AS</span> <span class=\"keyword\">year</span>, </span><br><span class=\"line\">\tROUND(<span class=\"built_in\">AVG</span>(rating),<span class=\"number\">2</span>) <span class=\"keyword\">AS</span> avg_rating,</span><br><span class=\"line\">    <span class=\"built_in\">MAX</span>(rating),</span><br><span class=\"line\">    <span class=\"built_in\">MIN</span>(rating),</span><br><span class=\"line\">    <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">\ttitles <span class=\"keyword\">AS</span> t</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> </span><br><span class=\"line\">\tratings <span class=\"keyword\">AS</span> r </span><br><span class=\"line\"><span class=\"keyword\">ON</span> t.title_id<span class=\"operator\">=</span>r.title_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> premiered <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">year</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> avg_rating <span class=\"keyword\">DESC</span>, <span class=\"keyword\">year</span> <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n<p>sqlite 整除  / 就是整除</p>\n<p>sqlite 保留n位小数 round </p>\n<p>sqlite 取整 ceil floor</p>\n<h3 id=\"Q6-10-points-找人\"><a href=\"#Q6-10-points-找人\" class=\"headerlink\" title=\"Q6  [10 points] 找人\"></a>Q6  [10 points] 找人</h3><p>要求：</p>\n<ul>\n<li>一个人 名字里有 Cruise  生于1962</li>\n<li>vote 数量最多的作品 前十 </li>\n<li>输出格式： 作品名称 | 投票数</li>\n</ul>\n<p>分析：</p>\n<ul>\n<li>多表联合查询</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> t.primary_title,votes</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">\tratings <span class=\"keyword\">AS</span> r</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span></span><br><span class=\"line\">\ttitles <span class=\"keyword\">AS</span> t</span><br><span class=\"line\"><span class=\"keyword\">ON</span> t.title_id <span class=\"operator\">=</span> r.title_id</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span></span><br><span class=\"line\">\tcrew <span class=\"keyword\">AS</span> c</span><br><span class=\"line\"><span class=\"keyword\">ON</span> t.title_id <span class=\"operator\">=</span> c.title_id</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> </span><br><span class=\"line\">\tpeople <span class=\"keyword\">AS</span> p</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.person_id <span class=\"operator\">=</span> p.person_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> p.name <span class=\"keyword\">LIKE</span> &quot;%Cruise%&quot; <span class=\"keyword\">AND</span> p.born<span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"number\">1962</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> votes <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>感觉有点慢</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WITH</span> cruise_movies <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">          crew.title_id <span class=\"keyword\">AS</span> title_id</span><br><span class=\"line\">     <span class=\"keyword\">FROM</span> crew</span><br><span class=\"line\">     <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">          people <span class=\"keyword\">ON</span> crew.person_id <span class=\"operator\">=</span> people.person_id</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> people.name <span class=\"keyword\">LIKE</span> &quot;%Cruise%&quot; <span class=\"keyword\">AND</span> people.born <span class=\"operator\">=</span> <span class=\"number\">1962</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">     titles.primary_title <span class=\"keyword\">as</span> name,</span><br><span class=\"line\">     ratings.votes <span class=\"keyword\">as</span> votes</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">     cruise_movies</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">     ratings <span class=\"keyword\">ON</span> cruise_movies.title_id <span class=\"operator\">=</span> ratings.title_id</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">     titles <span class=\"keyword\">ON</span> cruise_movies.title_id <span class=\"operator\">=</span> titles.title_id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> votes <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q7-15-points-找特定年份的数据\"><a href=\"#Q7-15-points-找特定年份的数据\" class=\"headerlink\" title=\"Q7 [15 points] 找特定年份的数据\"></a>Q7 [15 points] 找特定年份的数据</h3><p>要求：</p>\n<ul>\n<li>找和Army of Thieves同年上映的电影数量</li>\n<li>输出这一年的电影数量</li>\n</ul>\n<p>分析：</p>\n<ul>\n<li>嵌套查询、子查询</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> title_id) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> titles</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> premiered <span class=\"operator\">=</span> (</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> premiered</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> titles</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> primary_title <span class=\"operator\">=</span> &quot;Army of Thieves&quot;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q8-15-points\"><a href=\"#Q8-15-points\" class=\"headerlink\" title=\"Q8 [15 points]\"></a>Q8 [15 points]</h3><p>要求：</p>\n<ul>\n<li>找到所有与Nicole Kidman  (1967 出生的) 共同出演的演员</li>\n<li>将所有的actor / actress按照名字的字典序排序</li>\n</ul>\n<p>with 前置条件的运用</p>\n<p>分析（过程）：</p>\n<ul>\n<li>首先将这个人的出演过的作品id列出</li>\n<li>通过这个作品id查所有出现过的人的person -id （使用distinct去重）</li>\n<li>查people表找上述person-id里面的人的名字</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> title_id </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">\tcrew <span class=\"keyword\">AS</span> c</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span></span><br><span class=\"line\">\tpeople <span class=\"keyword\">AS</span> p</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.person_id <span class=\"operator\">=</span> p.person_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> p.name <span class=\"operator\">=</span> &quot;Nicole Kidman&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WITH</span> kidman_titles <span class=\"keyword\">AS</span> (</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> title_id </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> crew <span class=\"keyword\">JOIN</span> people <span class=\"keyword\">ON</span> crew.person_id <span class=\"operator\">=</span> people.person_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> people.name <span class=\"operator\">=</span> &quot;Nicole Kidman&quot; <span class=\"keyword\">AND</span> people.born <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">1967</span></span><br><span class=\"line\">),</span><br><span class=\"line\"><span class=\"keyword\">WITH</span> kidman_colleagues <span class=\"keyword\">AS</span>(</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span>(person_id) <span class=\"keyword\">AS</span> id</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> crew </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> (category <span class=\"operator\">=</span> &quot;actor&quot; <span class=\"keyword\">or</span> category <span class=\"operator\">=</span> &quot;actress&quot;) <span class=\"keyword\">AND</span> crew.title_id <span class=\"keyword\">in</span> kidman_titles</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> people</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> people.person_id <span class=\"keyword\">in</span> kidman_colleagues.id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q9-15-points\"><a href=\"#Q9-15-points\" class=\"headerlink\" title=\"Q9 [15 points]\"></a>Q9 [15 points]</h3><p>要求：</p>\n<ul>\n<li>出生于1955年的演员</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WITH</span> actors_and_movies_1955 <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">          people.person_id,</span><br><span class=\"line\">          people.name,</span><br><span class=\"line\">          titles.title_id,</span><br><span class=\"line\">          titles.primary_title</span><br><span class=\"line\">     <span class=\"keyword\">FROM</span></span><br><span class=\"line\">          people</span><br><span class=\"line\">     <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">          crew <span class=\"keyword\">ON</span> people.person_id <span class=\"operator\">=</span> crew.person_id</span><br><span class=\"line\">     <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">          titles <span class=\"keyword\">ON</span> crew.title_id <span class=\"operator\">=</span> titles.title_id</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> people.born <span class=\"operator\">=</span> <span class=\"number\">1955</span> <span class=\"keyword\">AND</span> titles.type <span class=\"operator\">=</span> &quot;movie&quot;</span><br><span class=\"line\">),</span><br><span class=\"line\">actor_ratings <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">          name,</span><br><span class=\"line\">          ROUND(<span class=\"built_in\">AVG</span>(ratings.rating), <span class=\"number\">2</span>) <span class=\"keyword\">as</span> rating</span><br><span class=\"line\">     <span class=\"keyword\">FROM</span> ratings</span><br><span class=\"line\">     <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> actors_and_movies_1955 <span class=\"keyword\">ON</span> ratings.title_id <span class=\"operator\">=</span> actors_and_movies_1955.title_id</span><br><span class=\"line\">     <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> actors_and_movies_1955.person_id</span><br><span class=\"line\">),</span><br><span class=\"line\">quartiles <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span>, <span class=\"built_in\">NTILE</span>(<span class=\"number\">10</span>) <span class=\"keyword\">OVER</span> (<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> rating <span class=\"keyword\">ASC</span>) <span class=\"keyword\">AS</span> RatingQuartile <span class=\"keyword\">FROM</span> actor_ratings</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name, rating</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> quartiles</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> RatingQuartile <span class=\"operator\">=</span> <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> rating <span class=\"keyword\">DESC</span>, name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Q10-15-points\"><a href=\"#Q10-15-points\" class=\"headerlink\" title=\"Q10 [15 points]\"></a>Q10 [15 points]</h3><p>要求：</p>\n<ul>\n<li>使用逗号和空格连接TV 龙之家族的 所有unique titles 这些titles必须要按照字典序来</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> p <span class=\"keyword\">as</span> (</span><br><span class=\"line\">      <span class=\"keyword\">select</span> titles.primary_title <span class=\"keyword\">as</span> name, akas.title <span class=\"keyword\">as</span> dubbed</span><br><span class=\"line\">      <span class=\"keyword\">from</span> titles</span><br><span class=\"line\">      <span class=\"keyword\">inner</span> <span class=\"keyword\">join</span> akas <span class=\"keyword\">on</span> titles.title_id <span class=\"operator\">=</span> akas.title_id</span><br><span class=\"line\">      <span class=\"keyword\">where</span> titles.primary_title <span class=\"operator\">=</span> &quot;House of the Dragon&quot; <span class=\"keyword\">AND</span> titles.type <span class=\"operator\">=</span> <span class=\"string\">&#x27;tvSeries&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> titles.primary_title, akas.title</span><br><span class=\"line\">      <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> akas.title</span><br><span class=\"line\">),</span><br><span class=\"line\">c <span class=\"keyword\">as</span> (</span><br><span class=\"line\">      <span class=\"keyword\">select</span> <span class=\"built_in\">row_number</span>() <span class=\"keyword\">over</span> (<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> p.name <span class=\"keyword\">asc</span>) <span class=\"keyword\">as</span> seqnum, p.dubbed <span class=\"keyword\">as</span> dubbed</span><br><span class=\"line\">      <span class=\"keyword\">from</span> p</span><br><span class=\"line\">),</span><br><span class=\"line\">flattened <span class=\"keyword\">as</span> (</span><br><span class=\"line\">      <span class=\"keyword\">select</span> seqnum, dubbed</span><br><span class=\"line\">      <span class=\"keyword\">from</span> c</span><br><span class=\"line\">      <span class=\"keyword\">where</span> seqnum <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\">      <span class=\"keyword\">select</span> c.seqnum, f.dubbed <span class=\"operator\">||</span> <span class=\"string\">&#x27;, &#x27;</span> <span class=\"operator\">||</span> c.dubbed</span><br><span class=\"line\">      <span class=\"keyword\">from</span> c <span class=\"keyword\">join</span></span><br><span class=\"line\">            flattened f</span><br><span class=\"line\">            <span class=\"keyword\">on</span> c.seqnum <span class=\"operator\">=</span> f.seqnum <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">select</span> dubbed <span class=\"keyword\">from</span> flattened</span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> seqnum <span class=\"keyword\">desc</span> limit <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"完成后将sql文件打包\"><a href=\"#完成后将sql文件打包\" class=\"headerlink\" title=\"完成后将sql文件打包\"></a>完成后将sql文件打包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ zip -j submission.zip placeholder/*.sql</span><br></pre></td></tr></table></figure>\n<h1 id=\"CMU15445-PROJECT-0\"><a href=\"#CMU15445-PROJECT-0\" class=\"headerlink\" title=\"CMU15445-PROJECT-0\"></a>CMU15445-PROJECT-0</h1><h2 id=\"project-0-任务介绍\"><a href=\"#project-0-任务介绍\" class=\"headerlink\" title=\"project-0 任务介绍\"></a>project-0 任务介绍</h2><p>目标：</p>\n<blockquote>\n<p>implement a key-value store backed by a concurrent <a href=\"https://zh.wikipedia.org/wiki/Trie\">trie</a></p>\n</blockquote>\n<h2 id=\"环境搭建：\"><a href=\"#环境搭建：\" class=\"headerlink\" title=\"环境搭建：\"></a>环境搭建：</h2><p>使用的是本地的VMware里面的Ubuntu server 22.04.x版本的</p>\n<p>IDE：CLion 通过ssh连接虚拟机</p>\n<h2 id=\"前置知识的学习\"><a href=\"#前置知识的学习\" class=\"headerlink\" title=\"前置知识的学习\"></a>前置知识的学习</h2><p>trie也叫 前缀树、字典树。之前没接触过。先做一下leetcode上的有关前缀树的定义的题目熟悉一下前缀树 </p>\n<h2 id=\"前缀树\"><a href=\"#前缀树\" class=\"headerlink\" title=\"前缀树\"></a>前缀树</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>is_end bool 表示是否是单词的结束 true表示当前节点为单词的结束</p>\n<p>map<char,Trie*> children_nodes; 子节点的连接。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Trie</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 存储前缀树的存储数据结构</span></span><br><span class=\"line\">    map&lt;<span class=\"type\">char</span>,Trie*&gt; children_node;</span><br><span class=\"line\">    <span class=\"type\">bool</span> is_End;</span><br><span class=\"line\">    <span class=\"comment\">// 内置的搜索前缀的工具函数</span></span><br><span class=\"line\">    <span class=\"function\">Trie* <span class=\"title\">searchPrefix</span><span class=\"params\">(string prefix)</span></span>&#123;</span><br><span class=\"line\">        Trie* current_node = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:prefix)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(current_node-&gt;children_node.<span class=\"built_in\">find</span>(c)==current_node-&gt;children_node.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            current_node = current_node-&gt;children_node[c];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> current_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Trie</span>() &#123;</span><br><span class=\"line\">        is_End = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(string word)</span> </span>&#123;</span><br><span class=\"line\">        Trie* current_node = <span class=\"keyword\">this</span>;  <span class=\"comment\">// 初始指针指向当前根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:word)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(current_node-&gt;children_node.<span class=\"built_in\">find</span>(c)==current_node-&gt;children_node.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 表示当前字节点集合中没有这个  所以创建一个</span></span><br><span class=\"line\">                current_node-&gt;children_node[c] = <span class=\"keyword\">new</span> <span class=\"built_in\">Trie</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            current_node = current_node-&gt;children_node[c];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current_node-&gt;is_End = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">search</span><span class=\"params\">(string word)</span> </span>&#123;</span><br><span class=\"line\">        Trie* current_node = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">searchPrefix</span>(word);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> current_node!=<span class=\"literal\">nullptr</span> &amp;&amp; current_node-&gt;is_End;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">startsWith</span><span class=\"params\">(string prefix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">searchPrefix</span>(prefix)!=<span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"左值、右值、左值引用、右值引用\"><a href=\"#左值、右值、左值引用、右值引用\" class=\"headerlink\" title=\"左值、右值、左值引用、右值引用\"></a>左值、右值、左值引用、右值引用</h3><p>左值：可以放在赋值号的左边充当被赋值的对象，也可以在右边做赋值对象，充当左值的“东西”必须要有在内存上的存储空间。</p>\n<p>右值：智能在赋值号的右边，做赋值对象，可以没有存储空间，可以只是一个在cpu寄存器上的一个数据。右值不能被修改</p>\n<p>左值引用：引用的是一个对象。</p>\n<p>右值引用：引用的是一个数据。这个只能作为右值，他不在内存上占有存储空间。</p>\n<p>作用用来提高程序运行效率，避免多余的拷贝操作。</p>\n<p>std::move()  将一个左值变为右值</p>\n<p>使用临时对象使用的空间，赋值到目标对象中可以节省对内存的释放。</p>\n<p>==例如==</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\tMyString a; </span><br><span class=\"line\">\ta = <span class=\"built_in\">MyString</span>(<span class=\"string\">&quot;Hello&quot;</span>); </span><br><span class=\"line\">\tstd::vector&lt;MyString&gt; vec; </span><br><span class=\"line\">\tvec.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">MyString</span>(<span class=\"string\">&quot;World&quot;</span>)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数在程序结束时一共调用了四次析构函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy Assignment is called! source: Hello</span><br><span class=\"line\">Destructor is called!</span><br><span class=\"line\">Copy Constructor is called! source: World</span><br><span class=\"line\">Destructor is called!</span><br><span class=\"line\">Destructor is called!  // 最后两次的析构函数时a 和 vector0 被释放</span><br><span class=\"line\">Destructor is called!</span><br></pre></td></tr></table></figure>\n<h4 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h4><p>unique_ptr()</p>\n<p>独占资源所有权指针，该指针式moveonly的 也就是智能通过move函数将其给赋值到一个左值中</p>\n<p>创建：</p>\n<p>shared_ptr()</p>\n<p>共享资源所有权指针</p>\n<p>weak_ptr()</p>\n<p>共享资源观察者</p>\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>将一个基类的指针/引用 指向继承类的指针/引用，dynamic_cast将会判断该基类是否真的指向继承类，如果否则返回null 或者报错</p>\n<h1 id=\"Linux-一些命令的小记\"><a href=\"#Linux-一些命令的小记\" class=\"headerlink\" title=\"Linux 一些命令的小记\"></a>Linux 一些命令的小记</h1><p>创建目录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">mkdir</span>  path/directory-name</span><br></pre></td></tr></table></figure>\n<p>创建文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">touch</span>  path/file-name</span><br></pre></td></tr></table></figure>\n<p>创建多个文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">touch</span> \\</span><br><span class=\"line\"></span><br><span class=\"line\">file-name1 \\</span><br><span class=\"line\"></span><br><span class=\"line\">file-name2 \\</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>sqlite 执行sql文件</p>\n"},{"title":"acwing算法每日一题记录","copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-09T12:17:33.000Z","updated":"2023-04-09T12:17:33.000Z","mathjax":true,"keywords":"acwing","description":"考PAT甲级的每日一题","cover":"https://resource.ninoneumann.cn/Cover_img/90611592_p0.jpg","_content":"\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-09 -->\n\n根据先序序列输出中序序列。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-10 -->\n\n冶炼金属，一道数学题。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-14 -->\n\n最长上升子序列的变形。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-15 -->\n\n子矩阵、接龙数列、skew数\n\n<!-- endtimeline -->\n\n<!-- timeline 04-18 -->\n\n整数奇偶排序\n\n<!-- endtimeline -->\n\n<!-- timeline 04-19 -->\n\n最长公共子串。\n\n<!-- endtimeline -->\n\n\n\n<!-- timeline 04-20 -->\n\n很简单的一道题目，三重循环\n\n- 三元组。\n\n- 分组统计\n\n<!-- endtimeline -->\n\n<!-- timeline 04-22 -->\n\n- 高精度进制转换\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n[toc]\n\n\n\n\n\n# 每日一题\n\n## 3384 二叉树遍历\n\n```c++\n#include<iostream>\nusing namespace std;\n\nvoid dfs(){\n    char x;\n    scanf(\"%c\",&x);\n    if(x>='a' && x<='z'){\n        dfs();\n        printf(\"%c \",x);\n        dfs();\n    }\n}\nint main(){\n    dfs();\n    return 0;\n}\n```\n\n## 4956冶炼金属\n\n{% tabs 题解 %}\n<!-- tab 最简单的答案--数学推导 -->\n$$\n(暴力枚举) O\\left(n^2\\right)\n设答案为 x, 则有 b \\leqslant \\frac{a}{x}<b+1\n即 \\frac{a}{b+1}<x \\leqslant \\frac{a}{b}\n最小值 \\frac{a}{b+1}+1, 最大值 \\frac{a}{b}\n多组数据取一个交集\n$$\n最后答案也很好看\n\n```C++\n#include<iostream>\nusing namespace std;\nint res_max,res_min;\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    res_min = 0;\n    res_max = 1e9+100;\n    for(int i = 0;i<n;++i){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        res_max = min(a/b,res_max);\n        res_min = max(a/(b+1)+1,res_min);\n        \n    }\n    printf(\"%d %d\",res_min,res_max);\n    \n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n\n<!-- tab 我自己想的，二分查找，只能过前八个样例-->\n\n基本思路是，给定的两个数能找到其范围内的最大值和最小值。不详细说明了，反正是一个很傻瓜的算法，后面不知道什么原因过不了最后两个样例。\n\n```c++\n#include<iostream>\nusing namespace std;\n\n\nbool judge_ceil(int a,int b,int c){\n    return b>(double)a/c;\n}\n\nbool judge_floor(int a,int b,int c){\n    return b>=(double)a/c-1;\n}\n\nvoid get_range(int a,int b,int &mn,int &mx){\n    mn = mx = 0;\n    \n    \n    int l = 0,r = a;\n    while(l<r){\n        int mid = (l+r)>>1;\n        if(judge_floor(a,b,mid)) r = mid;\n        else l = mid+1;\n    }\n    if(judge_floor(a,b,l)) mn = l;\n    else mn = l+1;\n    \n    \n    l = 0,r = a;\n    while(l<r){\n        int mid = (l+r)>>1;\n        if(judge_ceil(a,b,mid)) r = mid;\n        else l = mid+1;\n    }\n    if(judge_ceil(a,b,l)) mx = l-1;\n    else mx = l;\n    // mx = l;\n}\n\nint res_max,res_min;\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    res_min = 0;\n    res_max = 1e9+100;\n    for(int i = 0;i<n;++i){\n        int a,b,tmp_max,tmp_min;\n        scanf(\"%d%d\",&a,&b);\n        \n        get_range(a,b,tmp_min,tmp_max);\n        // cout<<a<<\" \"<<b<<endl;\n        // cout<<\"tmp_max&min: \"<<tmp_max<<\" \"<<tmp_min<<endl;\n        res_max = min(tmp_max,res_max);\n        res_min = max(tmp_min,res_min);\n        \n    }\n    cout<<res_min<<\" \"<<res_max<<endl;\n    \n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n## 4958 接龙数列\n\n先复习一下模板（我又忘得差不多了）\n\n{% tabs 最长上升子序列问题 %}\n<!-- tab acwing-895.最长上升子序列 -->\n\n```C++\n#include<iostream>\nusing namespace std;\n\nconst int N = 1010;\nint f[N];  // fi 表示以i结尾的 上升子序列的集合  属性 子序列的长度最大值  \n            // 状态计算：fi = sigma（fk+1）\nint g[N];\nint n;\n\n\n\nint main(){\n    cin>>n;\n    \n    int mx = 0;\n    for(int i = 1;i<=n;++i)cin>>g[i];\n    for(int i = 1;i<=n;++i){\n        f[i] = 1;\n        for(int j = 0;j<=i-1;++j)\n            if(g[i]>f[j]) f[i] = max(f[i],f[j]+1);\n        mx = max(mx,f[i]);\n    }\n    cout<<mx<<endl;\n\n    return 0;\n}\n```\n\n关键在于理解这一部分\n\n```c++\nfor(int i = 1;i<=n;++i){\n \tf[i] = 1;\n \tfor(int j = 0;j<=i-1;++j)\n     \tif(g[i]>g[j]) f[i] = max(f[i],f[j]+1);\n \tmx = max(mx,f[i]);\n}\n// 这里内层循环的顺序对这道题的结果无影响\nfor(int i = 1;i<=n;++i){\n    f[i] = 1;\n    for(int j = i-1;j>0;--j)\n        if(g[i]>g[j]) f[i] = max(f[i],f[j]+1);\n    mx = max(mx,f[i]);\n        // cout<<\"f_\"<<i<<\": \"<<f[i]<<endl;\n}\n```\n\n按从1--n的次序更新f（n）的值 $$ f(n): 以第n个数为结尾的最长上升子序列的长度 $$ \n\n\n\n<!-- endtab -->\n\n<!-- tab 第一次尝试：递推-->\n\n```c++\n#include<iostream>\nusing namespace std;\n\n// 动态规划\n// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！\n// 运算 f [n] f[n-1]\n\nconst int N = 1e5+10;\n\nint d[N];\nint f[N];\n\nint num[N];\nint n;\n\nbool check(int a,int b){\n    int tail = a%10;  // a的最后一个数\n    int head = 0;\n    while(b){\n        head = b%10;\n        b/=10;\n    }\n    return tail==head;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;++i)scanf(\"%d\",&num[i]);\n    int last = num[1];\n    f[1] = 1;\n    for(int i = 2;i<=n;++i){\n        if(check(last,num[i])){//最长接龙尾部的数和当前数满足接龙条件 则f(i+1) = f(i)+1) 还要更新当前最长接龙尾部的值  否则 f(i+1) = f(i)\n            last = num[i];\n            f[i] = f[i-1]+1;\n        }else{\n            f[i] = f[i-1];\n        }\n    }\n    \n    cout<<n-f[n]<<endl;\n    \n    \n    \n    \n    \n    return 0;\n}\n```\n\n具体思路：\n\n由第一个往后推，如果后一个是当前最长接龙的下一个位置，则更新当前最长接龙尾部的数为当前数并且将fi = length++ 否则 fi = length。\n\n问题：贪心思想没法找到全局最优解。当前这个可以是最长接龙的尾巴但是不是最好的。\n\n<!-- endtab -->\n\n<!-- tab 第二次尝试：最长上升子序列的变体（时间复杂度太高）-->\n\n```c++\n#include<iostream>\nusing namespace std;\n\n// 动态规划\n// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！\n// 运算 f [n] f[n-1]\n\nconst int N = 1e5+10;\n\nint d[N];\nint f[N];\n\nint num[N];\nint n;\n\nbool check(int a,int b){\n    int tail = a%10;  // a的最后一个数\n    int head = 0;\n    while(b){\n        head = b%10;\n        b/=10;\n    }\n    return tail==head;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;++i)scanf(\"%d\",&num[i]);\n    f[1] = 1;\n    int mx = 0;\n    for(int i = 1;i<=n;++i){\n        f[i] = 1;\n        for(int j = i-1;j>0;--j){\n            if(check(num[j],num[i])) f[i] = max(f[i],f[j]+1);\n        }\n        mx = max(f[i],mx);\n    }\n    \n    cout<<n-mx<<endl\n    return 0;\n}\n```\n\nTLE 时间复杂度为$$O(n^2)$$ 超时了。\n\n<!-- endtab -->\n\n<!-- tab 第三次尝试（Y总的思路）：-->\n\n对于前面的最长上升子序列的优化，主要优化部分是两重循环。\n\n分析：第二层循环是在前i-1个数据中找到以第i个数头结尾的最长的子序列长度，所以只要记录这个值就ok，因为：==以i个数头结尾的最长的子序列长度是可以穷举，有限的（只有十个）==，而最长子序列无法使用这种方法是因为他需要遍历前面所有的数据找到最值，而这个最值是无法有限次记录的。\n\n```C++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n// 动态规划\n// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！\n// 运算 f [n] f[n-1]\nconst int N = 1e5+10;\nint h[N],l[N],G[11];\nint f[N];\nint n;\n\nint main(){\n    scanf(\"%d\",&n);\n    int mx = 0;\n    for(int i = 1;i<=n;++i){\n        char s[11];\n        scanf(\"%s\",s);\n        h[i] = s[0]-'0';\n        l[i] = s[strlen(s)-1]-'0';\n        f[i] = 1;\n        f[i] = max(f[i],G[h[i]]+1);\n        G[l[i]] = max(f[i],G[l[i]]);\n        mx = max(f[i],mx);\n    }\n    cout<<n-mx<<endl;\n    return 0;\n}\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n\n\n## 4964 子矩阵\n\n数位DP、单调队列。\n\n{% tabs 子矩阵 %}\n\n<!-- tab 暴力方法 -->\n\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nconst int N = 1010;\nconst int mod = 998244353;\nconst int INF = 1e9+10;\n\nint g[N][N];\n\nint m,n,a,b;\n\nint main(){\n    // 暴力\n    scanf(\"%d%d%d%d\",&n,&m,&a,&b);\n    for(int i = 1;i<=n;++i)\n        for(int j = 1;j<=m;++j)scanf(\"%d\",&g[i][j]);\n    \n    int sum = 0;\n    for(int i = 1;i<=n-a+1;++i){\n        for(int j = 1;j<=m-b+1;++j){\n            int mx = 0;\n            int mi = INF;\n            for(int q = i;q<i+a;++q){\n                for(int p = j;p<j+b;p++){\n                    mx = max(mx,g[q][p]);\n                    mi = min(mi,g[q][p]);\n                }\n            }\n            sum=(sum+(mx*mi))%mod;\n        }\n    }\n    printf(\"%d\",sum);\n    \n    return 0;\n}\n```\n\n时间复杂度可能要到$$500^4 = 62,500,000,000 \\approx 10^8 $$ \n\n<!-- endtab -->\n\n<!-- tab 暴力解法的优化 -->\n**This is Tab 2.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n\n## 3431 skew数\n\n很简单的一道字符串模拟题目\n\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint main(){\n    string str;\n    while(getline(cin,str)){\n        int res = 0;\n        for(int i = str.length()-1,k = 2;i>=0;--i,k<<=1)\n            res += (str[i]-'0')*(k-1);\n        cout<<res<<endl;\n    }\n}\n```\n\n## 3446 整数奇偶排序\n\n一道很简单的排序题\n\n```C++\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n\nvector<int> odd,even;\n\nbool cmp(int &a,int &b){\n    return a>b;\n}\n\nint main(){\n    \n    int t;\n    while(cin>>t){\n        // cout<<t<<\" \";\n        if(t%2) odd.push_back(t);\n        else even.push_back(t);\n        \n    }\n    sort(odd.begin(),odd.end(),cmp);\n    sort(even.begin(),even.end());\n    for(auto x:odd){\n        cout<<x<<\" \";\n    }\n    for(auto x:even){\n        cout<<x<<\" \";\n    }\n    \n    return 0;\n}\n```\n\n\n\n## 3508 最长公共子串\n\n:exclamation: 求的是公共子串！！！\n\n```c++\n//\n// Created by Nino Neumann on 2023/3/8.\n//\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int N = 1e4+10;\n\nint f[N]; // 定义 fij a的以第i个char结尾的 和 b的以第j个char结尾的 构成的公共子串  数值：长度的最大值\nchar a[N],b[N];\n\nint main(){\n    scanf(\"%s%s\",a+1,b+1);\n    int a_length = strlen(a+1);\n    int b_length = strlen(b+1);\n    int mx = 0;\n   \n    \n    for(int i = 1;i<=a_length;++i){\n        for(int j = b_length;j>=1;--j){\n            if(a[i]==b[j] && a[i]>='a') f[j] = f[j-1]+1;\n            else f[j] = 0;  // 这里不太理解\n            mx = max(mx,f[j]);\n        }\n    }\n    cout<<mx<<endl;\n\n    return 0;\n}\n\n```\n\n## 3543 三元组\n\n时间复杂度分析：找一个长度为m中的满足条件的三元组。时间复杂度为$$O(m^3)$$ m最大为50，n最大为10；所以$$T(n) = 50^3 10= 1.25 \\times10^6 $$ 暴力做法完全可行啊！ 可以做的优化就是将第三重循环做一个二分。这样就可以少一层，但是要先排序。\n\n```c++\n#include<iostream>\nusing namespace std;\n\n// 三重循环遍历\n\nconst int N = 51;\n\nint num[N];\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        int m;\n        int cnt = 0;\n        cin>>m;\n        for(int i = 0;i<m;++i){\n            cin>>num[i];\n        }\n        \n        for(int i = 0;i<m;++i){\n            for(int j = 0;j<m;++j){\n                for(int k = 0;k<m;++k){\n                    if(num[i]+num[j] == num[k]) cnt++;\n                }\n            }\n        }\n        \n        cout<<cnt<<endl;\n        \n    }\n    \n    return 0;\n}\n```\n\n## 3576 分组统计\n\n```C++\n#include<iostream>\n#include<unordered_map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n// 小组数连续且不为空  需要保存一个数值的集合\n\nconst int N = 110;\n\n// vector<int> set[N];\n\n\n\n\nint main(){\n    int t,n;\n    cin>>t;\n    while(t--){\n        unordered_map<int,int> set[N];\n        int number[N];\n        int gs[N];\n        cin>>n;\n        int mx_group = 0;\n        for(int i = 0;i<n;++i)cin>>number[i];\n        for(int i = 0;i<n;++i) cin>>gs[i];\n        for(int i = 0;i<n;++i){\n            set[gs[i]][number[i]]++;\n            mx_group = max(mx_group,gs[i]);\n        }\n        sort(number,number+n);\n        int k = unique(number,number+n)-number;\n        // 输出\n        \n        for(int g = 1;g<=mx_group;++g){\n            cout<<g<<\"={\";\n            for(int i = 0;i<k;++i){\n                cout<<number[i]<<\"=\"<<set[g][number[i]];\n                if(i+1<k)cout<<\",\";\n                else cout<<\"}\\n\";\n            }\n        }\n        \n    }\n    \n    return 0;\n}\n\n```\n\n简单模拟。\n\n## 3395 10进制 VS 2进制\n\n这是一道典型的高精度运算的题目\n\n{% tabs 高精度相关的板子 %}\n<!-- tab 高精度加法 -->\n\n```C++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> add(vector<int> &A,vector<int> &B){\n    \n    if(A.size()<B.size()) return add(B,A);\n    \n    vector<int> C;\n    int t = 0;\n    for(int i = 0;i<A.size();++i){\n        \n        t+=A[i];\n        if(i<B.size()) t+=B[i];\n        C.push_back(t%10);\n        t/=10;\n    }\n    \n    if(t) C.push_back(t);\n    return C;\n}\n\n\nint main(){\n    string a,b;\n    vector<int> A,B,C;\n    cin>>a>>b;\n    // cout<<a<<endl;\n    for(int i = a.length()-1;i>=0;--i) A.push_back(a[i]-'0');\n    for(int i = b.length()-1;i>=0;--i) B.push_back(b[i]-'0');\n    C = add(A,B);\n    for(int i = C.size()-1;i>=0;--i)cout<<C[i];\n    return 0;\n}\n```\n\n没啥好说的，注意输入和输出的数组顺序。add函数在处理加法的时候是从低位处理到高位，所以在输入的时候需要将低位放在前面，这和我们日常的书写顺序是相反的。\n\n<!-- endtab -->\n\n\n\n<!-- tab 高精度减法-->\n\n和加法差不多（差得不太多）\n\n- 判断两个数的大小，用大的减去小的。\n- 由于减法并不像加法有交换律所以定义减法的函数中减数和被减数的位置是固定的。\n- 对于前导0 的处理。\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n\nbool cmp(vector<int> &a,vector<int> &b){\n    if(a.size()!=b.size()) return a.size()>b.size();\n    \n    for(int i = a.size()-1;i>=0;--i)\n        if(a[i]!=b[i]) return a[i]>b[i];\n    \n    return true;\n    // 比较两个数的大小，返回a>=b；\n}\n\n\nvector<int> sub(vector<int> &a,vector<int> &b){\n    vector<int> c;\n    int t = 0;\n    for(int i = 0;i<a.size();++i){\n        t = a[i]-t;\n        if(i<b.size()) t-=b[i];\n        c.push_back((t+10)%10);  // 因为t可能是个负数，所以取其10 的mod 是借位后的数位。\n        if(t<0) t = 1;\n        else t = 0;\n    }\n    \n    while(c.size()>1 && c.back()==0) c.pop_back();\n    \n    return c;\n}\n\n\n\nint main(){\n    string a_s,b_s;\n    vector<int> a,b,c;\n    cin>>a_s>>b_s;\n    for(int i = a_s.length()-1;i>=0;--i) a.push_back(a_s[i]-'0');\n    for(int i = b_s.length()-1;i>=0;--i) b.push_back(b_s[i]-'0');\n    \n    if(cmp(a,b)){\n        c = sub(a,b);\n    }else{\n        c = sub(b,a);\n        cout<<\"-\";\n    }\n    \n    for(int i = c.size()-1;i>=0;--i) cout<<c[i];\n    \n    \n    \n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n\n\n\n<!-- tab 高精度乘法-->\n\n需要注意的是：\n\n- 对于结果的前导0的处理\n- 结果一定会大于原式，如何处理多出原本被乘数size的数位。\n\n\n\n```C++\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nvector<int> multi(vector<int> &a,int b){\n    vector<int> c;\n    int t = 0;\n    for(int i = 0;i<a.size()||t>0;++i){\n        if(i<a.size()) t += b*a[i];\n        c.push_back(t%10);\n        t/=10;\n    }\n    \n    while(c.size()>1 && c.back()==0) c.pop_back();\n    \n    return c;\n}\n\nint main(){\n    \n    string a;\n    int b;\n    vector<int> A;\n    cin>>a>>b;\n    if(b==0){\n        cout<<\"0\";\n        return 0;\n    }\n    for(int i = a.length()-1;i>-1;--i){\n        A.push_back(a[i]-'0');\n    }\n    \n    vector<int> C = multi(A,b);\n    \n    for(int i = C.size()-1;i>-1;--i)cout<<C[i];\n    \n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n\n\n\n<!-- tab 高精度除法-->\n\n```C++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> div(vector<int> &A, int b, int &r)\n{\n    vector<int> C;\n    r = 0;\n    for (int i = A.size() - 1; i >= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() > 1 && C.back() == 0) C.pop_back();\n    return C;\n}\n\nint main()\n{\n    string a;\n    vector<int> A;\n\n    int B;\n    cin >> a >> B;\n    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');\n\n    int r;\n    auto C = div(A, B, r);\n\n    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];\n\n    cout << endl << r << endl;\n\n    return 0;\n}\n\n```\n\n\n\n<!-- endtab -->\n\n{% endtabs %}\n\n\n\n> 题目描述：\n>\n> 对于一个十进制数 A，将 A转换为二进制数，然后按位逆序排列，再转换为十进制数 B，我们称 B为 A 的二进制逆序数。\n>\n> 例如对于十进制数 173173，它的二进制形式为 1010110110101101，逆序排列得到 1011010110110101，其十进制数为 181181，181181 即为 173173 的二进制逆序数。\n\n注意：二进制转十进制的加法表示！！！秦九韶算法\n\n\n\n```C++\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nvector<int> div_2(vector<int> &a,int &r){\n    vector<int> c;\n    r = 0;\n    for(int i = a.size()-1;i>-1;--i){\n        r = r*10+a[i];\n        c.push_back(r>>1);\n        r%=2;\n    }\n    reverse(c.begin(),c.end());\n    while(c.size()>1 && c.back()==0) c.pop_back();\n    return c;\n}\n\nvector<int> add(vector<int> a,vector<int> b){\n    if(a.size()<b.size()) return add(b,a);\n    \n    vector<int> c;\n    int t = 0;\n    for(int i = 0;i<a.size();++i){\n        t += a[i];\n        if(i<b.size()) t+=b[i];\n        c.push_back(t%10);\n        t/=10;\n    }\n    \n    if(t) c.push_back(t);\n    return c;\n}\n\nbool cmp(vector<int> a){\n    if(a.size()>1) return true;\n    else return a[0];\n}\n\nvector<int> dec_to_bin(vector<int> &a){\n    vector<int> b;\n    while(cmp(a)){\n        int r;\n        a = div_2(a,r);\n        b.push_back(r);\n    }\n    return b;\n}\n\nvector<int> bin_to_dec(vector<int> &b){  //二进制转十进制的算法很香。 秦九韶算法\n    vector<int> d;\n    d.push_back(0);\n    for(int i = 0;i<b.size();++i){\n        d = add(add(d,d),{b[i]});\n    }\n    return d;\n}\n\n\n\nint main(){\n    string a_s;\n    vector<int> a,b,d;\n    cin>>a_s;\n    \n    for(int i = a_s.length()-1;i>-1;--i) a.push_back(a_s[i]-'0');\n    b = dec_to_bin(a);\n\n    d = bin_to_dec(b);\n\n    for(int i = d.size() - 1; i >= 0; i --) cout << d[i];\n\n    cout << endl;\n    \n    \n    return 0;\n}\n```\n\n详解一下如何计算大数二进制转大数十进制：\n$$\n假设 当前二进制的数组为: \\ \\  b_i, b_{i-1},\\cdots,b_{1},b_{0};   \\ \\ (ps : 从高位到低位。)\\\\\n正常的计算方法是: \\ \\ \\  res = \\sum_{k=0}^{i}{2^{k}b_{k}} \\\\\n对于这个算法显然不适合大数计算，因为计算2^k 是一个乘法运算，在这个算法里面，乘法和加法的混合运算显然会使得算法的时间复杂度上升\\\\\n因此 我们可以使用秦九韶算法来简化步骤将所有的乘法运算都化简为加法运算\\\\\n由res = \\sum_{k=0}^{i}{2^{k}b_{k}},我们不妨拿出前四项: res_{前四项} = b_{3}2^3+ b_{2}2^2+ b_{1}2^1+ b_{0}2^0 = \n\\{[b_{3}2+b_{2}]2+b_1\\}2+b_0; \\\\\n故可以使用秦九韶算法化简步骤\n$$\n\n```C++\nvector<int> bin_to_dec(vector<int> &b){  //二进制转十进制的算法很香。 秦九韶算法\n    vector<int> d;\n    d.push_back(0);\n    for(int i = 0;i<b.size();++i){\n        d = add(add(d,d),{b[i]});\n    }\n    return d;\n}\n```\n\n\n\n","source":"_posts/acwing算法每日一题记录.md","raw":"---\ntitle: acwing算法每日一题记录\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-09 20:17:33\nupdated: 2023-04-09 20:17:33\nmathjax: true\ntags:\n- algorithm\n- PAT certificate\ncategories: \"Algorithm\"\nkeywords: acwing\ndescription: 考PAT甲级的每日一题\ncover: https://resource.ninoneumann.cn/Cover_img/90611592_p0.jpg\n---\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-09 -->\n\n根据先序序列输出中序序列。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-10 -->\n\n冶炼金属，一道数学题。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-14 -->\n\n最长上升子序列的变形。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-15 -->\n\n子矩阵、接龙数列、skew数\n\n<!-- endtimeline -->\n\n<!-- timeline 04-18 -->\n\n整数奇偶排序\n\n<!-- endtimeline -->\n\n<!-- timeline 04-19 -->\n\n最长公共子串。\n\n<!-- endtimeline -->\n\n\n\n<!-- timeline 04-20 -->\n\n很简单的一道题目，三重循环\n\n- 三元组。\n\n- 分组统计\n\n<!-- endtimeline -->\n\n<!-- timeline 04-22 -->\n\n- 高精度进制转换\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n[toc]\n\n\n\n\n\n# 每日一题\n\n## 3384 二叉树遍历\n\n```c++\n#include<iostream>\nusing namespace std;\n\nvoid dfs(){\n    char x;\n    scanf(\"%c\",&x);\n    if(x>='a' && x<='z'){\n        dfs();\n        printf(\"%c \",x);\n        dfs();\n    }\n}\nint main(){\n    dfs();\n    return 0;\n}\n```\n\n## 4956冶炼金属\n\n{% tabs 题解 %}\n<!-- tab 最简单的答案--数学推导 -->\n$$\n(暴力枚举) O\\left(n^2\\right)\n设答案为 x, 则有 b \\leqslant \\frac{a}{x}<b+1\n即 \\frac{a}{b+1}<x \\leqslant \\frac{a}{b}\n最小值 \\frac{a}{b+1}+1, 最大值 \\frac{a}{b}\n多组数据取一个交集\n$$\n最后答案也很好看\n\n```C++\n#include<iostream>\nusing namespace std;\nint res_max,res_min;\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    res_min = 0;\n    res_max = 1e9+100;\n    for(int i = 0;i<n;++i){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        res_max = min(a/b,res_max);\n        res_min = max(a/(b+1)+1,res_min);\n        \n    }\n    printf(\"%d %d\",res_min,res_max);\n    \n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n\n<!-- tab 我自己想的，二分查找，只能过前八个样例-->\n\n基本思路是，给定的两个数能找到其范围内的最大值和最小值。不详细说明了，反正是一个很傻瓜的算法，后面不知道什么原因过不了最后两个样例。\n\n```c++\n#include<iostream>\nusing namespace std;\n\n\nbool judge_ceil(int a,int b,int c){\n    return b>(double)a/c;\n}\n\nbool judge_floor(int a,int b,int c){\n    return b>=(double)a/c-1;\n}\n\nvoid get_range(int a,int b,int &mn,int &mx){\n    mn = mx = 0;\n    \n    \n    int l = 0,r = a;\n    while(l<r){\n        int mid = (l+r)>>1;\n        if(judge_floor(a,b,mid)) r = mid;\n        else l = mid+1;\n    }\n    if(judge_floor(a,b,l)) mn = l;\n    else mn = l+1;\n    \n    \n    l = 0,r = a;\n    while(l<r){\n        int mid = (l+r)>>1;\n        if(judge_ceil(a,b,mid)) r = mid;\n        else l = mid+1;\n    }\n    if(judge_ceil(a,b,l)) mx = l-1;\n    else mx = l;\n    // mx = l;\n}\n\nint res_max,res_min;\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    res_min = 0;\n    res_max = 1e9+100;\n    for(int i = 0;i<n;++i){\n        int a,b,tmp_max,tmp_min;\n        scanf(\"%d%d\",&a,&b);\n        \n        get_range(a,b,tmp_min,tmp_max);\n        // cout<<a<<\" \"<<b<<endl;\n        // cout<<\"tmp_max&min: \"<<tmp_max<<\" \"<<tmp_min<<endl;\n        res_max = min(tmp_max,res_max);\n        res_min = max(tmp_min,res_min);\n        \n    }\n    cout<<res_min<<\" \"<<res_max<<endl;\n    \n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n## 4958 接龙数列\n\n先复习一下模板（我又忘得差不多了）\n\n{% tabs 最长上升子序列问题 %}\n<!-- tab acwing-895.最长上升子序列 -->\n\n```C++\n#include<iostream>\nusing namespace std;\n\nconst int N = 1010;\nint f[N];  // fi 表示以i结尾的 上升子序列的集合  属性 子序列的长度最大值  \n            // 状态计算：fi = sigma（fk+1）\nint g[N];\nint n;\n\n\n\nint main(){\n    cin>>n;\n    \n    int mx = 0;\n    for(int i = 1;i<=n;++i)cin>>g[i];\n    for(int i = 1;i<=n;++i){\n        f[i] = 1;\n        for(int j = 0;j<=i-1;++j)\n            if(g[i]>f[j]) f[i] = max(f[i],f[j]+1);\n        mx = max(mx,f[i]);\n    }\n    cout<<mx<<endl;\n\n    return 0;\n}\n```\n\n关键在于理解这一部分\n\n```c++\nfor(int i = 1;i<=n;++i){\n \tf[i] = 1;\n \tfor(int j = 0;j<=i-1;++j)\n     \tif(g[i]>g[j]) f[i] = max(f[i],f[j]+1);\n \tmx = max(mx,f[i]);\n}\n// 这里内层循环的顺序对这道题的结果无影响\nfor(int i = 1;i<=n;++i){\n    f[i] = 1;\n    for(int j = i-1;j>0;--j)\n        if(g[i]>g[j]) f[i] = max(f[i],f[j]+1);\n    mx = max(mx,f[i]);\n        // cout<<\"f_\"<<i<<\": \"<<f[i]<<endl;\n}\n```\n\n按从1--n的次序更新f（n）的值 $$ f(n): 以第n个数为结尾的最长上升子序列的长度 $$ \n\n\n\n<!-- endtab -->\n\n<!-- tab 第一次尝试：递推-->\n\n```c++\n#include<iostream>\nusing namespace std;\n\n// 动态规划\n// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！\n// 运算 f [n] f[n-1]\n\nconst int N = 1e5+10;\n\nint d[N];\nint f[N];\n\nint num[N];\nint n;\n\nbool check(int a,int b){\n    int tail = a%10;  // a的最后一个数\n    int head = 0;\n    while(b){\n        head = b%10;\n        b/=10;\n    }\n    return tail==head;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;++i)scanf(\"%d\",&num[i]);\n    int last = num[1];\n    f[1] = 1;\n    for(int i = 2;i<=n;++i){\n        if(check(last,num[i])){//最长接龙尾部的数和当前数满足接龙条件 则f(i+1) = f(i)+1) 还要更新当前最长接龙尾部的值  否则 f(i+1) = f(i)\n            last = num[i];\n            f[i] = f[i-1]+1;\n        }else{\n            f[i] = f[i-1];\n        }\n    }\n    \n    cout<<n-f[n]<<endl;\n    \n    \n    \n    \n    \n    return 0;\n}\n```\n\n具体思路：\n\n由第一个往后推，如果后一个是当前最长接龙的下一个位置，则更新当前最长接龙尾部的数为当前数并且将fi = length++ 否则 fi = length。\n\n问题：贪心思想没法找到全局最优解。当前这个可以是最长接龙的尾巴但是不是最好的。\n\n<!-- endtab -->\n\n<!-- tab 第二次尝试：最长上升子序列的变体（时间复杂度太高）-->\n\n```c++\n#include<iostream>\nusing namespace std;\n\n// 动态规划\n// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！\n// 运算 f [n] f[n-1]\n\nconst int N = 1e5+10;\n\nint d[N];\nint f[N];\n\nint num[N];\nint n;\n\nbool check(int a,int b){\n    int tail = a%10;  // a的最后一个数\n    int head = 0;\n    while(b){\n        head = b%10;\n        b/=10;\n    }\n    return tail==head;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;++i)scanf(\"%d\",&num[i]);\n    f[1] = 1;\n    int mx = 0;\n    for(int i = 1;i<=n;++i){\n        f[i] = 1;\n        for(int j = i-1;j>0;--j){\n            if(check(num[j],num[i])) f[i] = max(f[i],f[j]+1);\n        }\n        mx = max(f[i],mx);\n    }\n    \n    cout<<n-mx<<endl\n    return 0;\n}\n```\n\nTLE 时间复杂度为$$O(n^2)$$ 超时了。\n\n<!-- endtab -->\n\n<!-- tab 第三次尝试（Y总的思路）：-->\n\n对于前面的最长上升子序列的优化，主要优化部分是两重循环。\n\n分析：第二层循环是在前i-1个数据中找到以第i个数头结尾的最长的子序列长度，所以只要记录这个值就ok，因为：==以i个数头结尾的最长的子序列长度是可以穷举，有限的（只有十个）==，而最长子序列无法使用这种方法是因为他需要遍历前面所有的数据找到最值，而这个最值是无法有限次记录的。\n\n```C++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n// 动态规划\n// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！\n// 运算 f [n] f[n-1]\nconst int N = 1e5+10;\nint h[N],l[N],G[11];\nint f[N];\nint n;\n\nint main(){\n    scanf(\"%d\",&n);\n    int mx = 0;\n    for(int i = 1;i<=n;++i){\n        char s[11];\n        scanf(\"%s\",s);\n        h[i] = s[0]-'0';\n        l[i] = s[strlen(s)-1]-'0';\n        f[i] = 1;\n        f[i] = max(f[i],G[h[i]]+1);\n        G[l[i]] = max(f[i],G[l[i]]);\n        mx = max(f[i],mx);\n    }\n    cout<<n-mx<<endl;\n    return 0;\n}\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n\n\n## 4964 子矩阵\n\n数位DP、单调队列。\n\n{% tabs 子矩阵 %}\n\n<!-- tab 暴力方法 -->\n\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nconst int N = 1010;\nconst int mod = 998244353;\nconst int INF = 1e9+10;\n\nint g[N][N];\n\nint m,n,a,b;\n\nint main(){\n    // 暴力\n    scanf(\"%d%d%d%d\",&n,&m,&a,&b);\n    for(int i = 1;i<=n;++i)\n        for(int j = 1;j<=m;++j)scanf(\"%d\",&g[i][j]);\n    \n    int sum = 0;\n    for(int i = 1;i<=n-a+1;++i){\n        for(int j = 1;j<=m-b+1;++j){\n            int mx = 0;\n            int mi = INF;\n            for(int q = i;q<i+a;++q){\n                for(int p = j;p<j+b;p++){\n                    mx = max(mx,g[q][p]);\n                    mi = min(mi,g[q][p]);\n                }\n            }\n            sum=(sum+(mx*mi))%mod;\n        }\n    }\n    printf(\"%d\",sum);\n    \n    return 0;\n}\n```\n\n时间复杂度可能要到$$500^4 = 62,500,000,000 \\approx 10^8 $$ \n\n<!-- endtab -->\n\n<!-- tab 暴力解法的优化 -->\n**This is Tab 2.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n\n## 3431 skew数\n\n很简单的一道字符串模拟题目\n\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint main(){\n    string str;\n    while(getline(cin,str)){\n        int res = 0;\n        for(int i = str.length()-1,k = 2;i>=0;--i,k<<=1)\n            res += (str[i]-'0')*(k-1);\n        cout<<res<<endl;\n    }\n}\n```\n\n## 3446 整数奇偶排序\n\n一道很简单的排序题\n\n```C++\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n\nvector<int> odd,even;\n\nbool cmp(int &a,int &b){\n    return a>b;\n}\n\nint main(){\n    \n    int t;\n    while(cin>>t){\n        // cout<<t<<\" \";\n        if(t%2) odd.push_back(t);\n        else even.push_back(t);\n        \n    }\n    sort(odd.begin(),odd.end(),cmp);\n    sort(even.begin(),even.end());\n    for(auto x:odd){\n        cout<<x<<\" \";\n    }\n    for(auto x:even){\n        cout<<x<<\" \";\n    }\n    \n    return 0;\n}\n```\n\n\n\n## 3508 最长公共子串\n\n:exclamation: 求的是公共子串！！！\n\n```c++\n//\n// Created by Nino Neumann on 2023/3/8.\n//\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int N = 1e4+10;\n\nint f[N]; // 定义 fij a的以第i个char结尾的 和 b的以第j个char结尾的 构成的公共子串  数值：长度的最大值\nchar a[N],b[N];\n\nint main(){\n    scanf(\"%s%s\",a+1,b+1);\n    int a_length = strlen(a+1);\n    int b_length = strlen(b+1);\n    int mx = 0;\n   \n    \n    for(int i = 1;i<=a_length;++i){\n        for(int j = b_length;j>=1;--j){\n            if(a[i]==b[j] && a[i]>='a') f[j] = f[j-1]+1;\n            else f[j] = 0;  // 这里不太理解\n            mx = max(mx,f[j]);\n        }\n    }\n    cout<<mx<<endl;\n\n    return 0;\n}\n\n```\n\n## 3543 三元组\n\n时间复杂度分析：找一个长度为m中的满足条件的三元组。时间复杂度为$$O(m^3)$$ m最大为50，n最大为10；所以$$T(n) = 50^3 10= 1.25 \\times10^6 $$ 暴力做法完全可行啊！ 可以做的优化就是将第三重循环做一个二分。这样就可以少一层，但是要先排序。\n\n```c++\n#include<iostream>\nusing namespace std;\n\n// 三重循环遍历\n\nconst int N = 51;\n\nint num[N];\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        int m;\n        int cnt = 0;\n        cin>>m;\n        for(int i = 0;i<m;++i){\n            cin>>num[i];\n        }\n        \n        for(int i = 0;i<m;++i){\n            for(int j = 0;j<m;++j){\n                for(int k = 0;k<m;++k){\n                    if(num[i]+num[j] == num[k]) cnt++;\n                }\n            }\n        }\n        \n        cout<<cnt<<endl;\n        \n    }\n    \n    return 0;\n}\n```\n\n## 3576 分组统计\n\n```C++\n#include<iostream>\n#include<unordered_map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n// 小组数连续且不为空  需要保存一个数值的集合\n\nconst int N = 110;\n\n// vector<int> set[N];\n\n\n\n\nint main(){\n    int t,n;\n    cin>>t;\n    while(t--){\n        unordered_map<int,int> set[N];\n        int number[N];\n        int gs[N];\n        cin>>n;\n        int mx_group = 0;\n        for(int i = 0;i<n;++i)cin>>number[i];\n        for(int i = 0;i<n;++i) cin>>gs[i];\n        for(int i = 0;i<n;++i){\n            set[gs[i]][number[i]]++;\n            mx_group = max(mx_group,gs[i]);\n        }\n        sort(number,number+n);\n        int k = unique(number,number+n)-number;\n        // 输出\n        \n        for(int g = 1;g<=mx_group;++g){\n            cout<<g<<\"={\";\n            for(int i = 0;i<k;++i){\n                cout<<number[i]<<\"=\"<<set[g][number[i]];\n                if(i+1<k)cout<<\",\";\n                else cout<<\"}\\n\";\n            }\n        }\n        \n    }\n    \n    return 0;\n}\n\n```\n\n简单模拟。\n\n## 3395 10进制 VS 2进制\n\n这是一道典型的高精度运算的题目\n\n{% tabs 高精度相关的板子 %}\n<!-- tab 高精度加法 -->\n\n```C++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> add(vector<int> &A,vector<int> &B){\n    \n    if(A.size()<B.size()) return add(B,A);\n    \n    vector<int> C;\n    int t = 0;\n    for(int i = 0;i<A.size();++i){\n        \n        t+=A[i];\n        if(i<B.size()) t+=B[i];\n        C.push_back(t%10);\n        t/=10;\n    }\n    \n    if(t) C.push_back(t);\n    return C;\n}\n\n\nint main(){\n    string a,b;\n    vector<int> A,B,C;\n    cin>>a>>b;\n    // cout<<a<<endl;\n    for(int i = a.length()-1;i>=0;--i) A.push_back(a[i]-'0');\n    for(int i = b.length()-1;i>=0;--i) B.push_back(b[i]-'0');\n    C = add(A,B);\n    for(int i = C.size()-1;i>=0;--i)cout<<C[i];\n    return 0;\n}\n```\n\n没啥好说的，注意输入和输出的数组顺序。add函数在处理加法的时候是从低位处理到高位，所以在输入的时候需要将低位放在前面，这和我们日常的书写顺序是相反的。\n\n<!-- endtab -->\n\n\n\n<!-- tab 高精度减法-->\n\n和加法差不多（差得不太多）\n\n- 判断两个数的大小，用大的减去小的。\n- 由于减法并不像加法有交换律所以定义减法的函数中减数和被减数的位置是固定的。\n- 对于前导0 的处理。\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n\nbool cmp(vector<int> &a,vector<int> &b){\n    if(a.size()!=b.size()) return a.size()>b.size();\n    \n    for(int i = a.size()-1;i>=0;--i)\n        if(a[i]!=b[i]) return a[i]>b[i];\n    \n    return true;\n    // 比较两个数的大小，返回a>=b；\n}\n\n\nvector<int> sub(vector<int> &a,vector<int> &b){\n    vector<int> c;\n    int t = 0;\n    for(int i = 0;i<a.size();++i){\n        t = a[i]-t;\n        if(i<b.size()) t-=b[i];\n        c.push_back((t+10)%10);  // 因为t可能是个负数，所以取其10 的mod 是借位后的数位。\n        if(t<0) t = 1;\n        else t = 0;\n    }\n    \n    while(c.size()>1 && c.back()==0) c.pop_back();\n    \n    return c;\n}\n\n\n\nint main(){\n    string a_s,b_s;\n    vector<int> a,b,c;\n    cin>>a_s>>b_s;\n    for(int i = a_s.length()-1;i>=0;--i) a.push_back(a_s[i]-'0');\n    for(int i = b_s.length()-1;i>=0;--i) b.push_back(b_s[i]-'0');\n    \n    if(cmp(a,b)){\n        c = sub(a,b);\n    }else{\n        c = sub(b,a);\n        cout<<\"-\";\n    }\n    \n    for(int i = c.size()-1;i>=0;--i) cout<<c[i];\n    \n    \n    \n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n\n\n\n<!-- tab 高精度乘法-->\n\n需要注意的是：\n\n- 对于结果的前导0的处理\n- 结果一定会大于原式，如何处理多出原本被乘数size的数位。\n\n\n\n```C++\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nvector<int> multi(vector<int> &a,int b){\n    vector<int> c;\n    int t = 0;\n    for(int i = 0;i<a.size()||t>0;++i){\n        if(i<a.size()) t += b*a[i];\n        c.push_back(t%10);\n        t/=10;\n    }\n    \n    while(c.size()>1 && c.back()==0) c.pop_back();\n    \n    return c;\n}\n\nint main(){\n    \n    string a;\n    int b;\n    vector<int> A;\n    cin>>a>>b;\n    if(b==0){\n        cout<<\"0\";\n        return 0;\n    }\n    for(int i = a.length()-1;i>-1;--i){\n        A.push_back(a[i]-'0');\n    }\n    \n    vector<int> C = multi(A,b);\n    \n    for(int i = C.size()-1;i>-1;--i)cout<<C[i];\n    \n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n\n\n\n<!-- tab 高精度除法-->\n\n```C++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> div(vector<int> &A, int b, int &r)\n{\n    vector<int> C;\n    r = 0;\n    for (int i = A.size() - 1; i >= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() > 1 && C.back() == 0) C.pop_back();\n    return C;\n}\n\nint main()\n{\n    string a;\n    vector<int> A;\n\n    int B;\n    cin >> a >> B;\n    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');\n\n    int r;\n    auto C = div(A, B, r);\n\n    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];\n\n    cout << endl << r << endl;\n\n    return 0;\n}\n\n```\n\n\n\n<!-- endtab -->\n\n{% endtabs %}\n\n\n\n> 题目描述：\n>\n> 对于一个十进制数 A，将 A转换为二进制数，然后按位逆序排列，再转换为十进制数 B，我们称 B为 A 的二进制逆序数。\n>\n> 例如对于十进制数 173173，它的二进制形式为 1010110110101101，逆序排列得到 1011010110110101，其十进制数为 181181，181181 即为 173173 的二进制逆序数。\n\n注意：二进制转十进制的加法表示！！！秦九韶算法\n\n\n\n```C++\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nvector<int> div_2(vector<int> &a,int &r){\n    vector<int> c;\n    r = 0;\n    for(int i = a.size()-1;i>-1;--i){\n        r = r*10+a[i];\n        c.push_back(r>>1);\n        r%=2;\n    }\n    reverse(c.begin(),c.end());\n    while(c.size()>1 && c.back()==0) c.pop_back();\n    return c;\n}\n\nvector<int> add(vector<int> a,vector<int> b){\n    if(a.size()<b.size()) return add(b,a);\n    \n    vector<int> c;\n    int t = 0;\n    for(int i = 0;i<a.size();++i){\n        t += a[i];\n        if(i<b.size()) t+=b[i];\n        c.push_back(t%10);\n        t/=10;\n    }\n    \n    if(t) c.push_back(t);\n    return c;\n}\n\nbool cmp(vector<int> a){\n    if(a.size()>1) return true;\n    else return a[0];\n}\n\nvector<int> dec_to_bin(vector<int> &a){\n    vector<int> b;\n    while(cmp(a)){\n        int r;\n        a = div_2(a,r);\n        b.push_back(r);\n    }\n    return b;\n}\n\nvector<int> bin_to_dec(vector<int> &b){  //二进制转十进制的算法很香。 秦九韶算法\n    vector<int> d;\n    d.push_back(0);\n    for(int i = 0;i<b.size();++i){\n        d = add(add(d,d),{b[i]});\n    }\n    return d;\n}\n\n\n\nint main(){\n    string a_s;\n    vector<int> a,b,d;\n    cin>>a_s;\n    \n    for(int i = a_s.length()-1;i>-1;--i) a.push_back(a_s[i]-'0');\n    b = dec_to_bin(a);\n\n    d = bin_to_dec(b);\n\n    for(int i = d.size() - 1; i >= 0; i --) cout << d[i];\n\n    cout << endl;\n    \n    \n    return 0;\n}\n```\n\n详解一下如何计算大数二进制转大数十进制：\n$$\n假设 当前二进制的数组为: \\ \\  b_i, b_{i-1},\\cdots,b_{1},b_{0};   \\ \\ (ps : 从高位到低位。)\\\\\n正常的计算方法是: \\ \\ \\  res = \\sum_{k=0}^{i}{2^{k}b_{k}} \\\\\n对于这个算法显然不适合大数计算，因为计算2^k 是一个乘法运算，在这个算法里面，乘法和加法的混合运算显然会使得算法的时间复杂度上升\\\\\n因此 我们可以使用秦九韶算法来简化步骤将所有的乘法运算都化简为加法运算\\\\\n由res = \\sum_{k=0}^{i}{2^{k}b_{k}},我们不妨拿出前四项: res_{前四项} = b_{3}2^3+ b_{2}2^2+ b_{1}2^1+ b_{0}2^0 = \n\\{[b_{3}2+b_{2}]2+b_1\\}2+b_0; \\\\\n故可以使用秦九韶算法化简步骤\n$$\n\n```C++\nvector<int> bin_to_dec(vector<int> &b){  //二进制转十进制的算法很香。 秦九韶算法\n    vector<int> d;\n    d.push_back(0);\n    for(int i = 0;i<b.size();++i){\n        d = add(add(d,d),{b[i]});\n    }\n    return d;\n}\n```\n\n\n\n","slug":"acwing算法每日一题记录","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwm10003bsuoecng2fjl","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-09</p>\n</div></div><div class=\"timeline-item-content\"><p>根据先序序列输出中序序列。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-10</p>\n</div></div><div class=\"timeline-item-content\"><p>冶炼金属，一道数学题。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-14</p>\n</div></div><div class=\"timeline-item-content\"><p>最长上升子序列的变形。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-15</p>\n</div></div><div class=\"timeline-item-content\"><p>子矩阵、接龙数列、skew数</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-18</p>\n</div></div><div class=\"timeline-item-content\"><p>整数奇偶排序</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-19</p>\n</div></div><div class=\"timeline-item-content\"><p>最长公共子串。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-20</p>\n</div></div><div class=\"timeline-item-content\"><p>很简单的一道题目，三重循环</p>\n<ul>\n<li><p>三元组。</p>\n</li>\n<li><p>分组统计</p>\n</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-22</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>高精度进制转换</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"每日一题\"><a href=\"#每日一题\" class=\"headerlink\" title=\"每日一题\"></a>每日一题</h1><h2 id=\"3384-二叉树遍历\"><a href=\"#3384-二叉树遍历\" class=\"headerlink\" title=\"3384 二叉树遍历\"></a>3384 二叉树遍历</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">char</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>,&amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;=<span class=\"string\">'a'</span> &amp;&amp; x&lt;=<span class=\"string\">'z'</span>){</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c \"</span>,x);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"4956冶炼金属\"><a href=\"#4956冶炼金属\" class=\"headerlink\" title=\"4956冶炼金属\"></a>4956冶炼金属</h2><div class=\"tabs\" id=\"题解\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#题解-1\">最简单的答案--数学推导</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#题解-2\">我自己想的，二分查找，只能过前八个样例</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"题解-1\"><script type=\"math/tex; mode=display\">\n(暴力枚举) O\\left(n^2\\right)\n设答案为 x, 则有 b \\leqslant \\frac{a}{x}<b+1\n即 \\frac{a}{b+1}<x \\leqslant \\frac{a}{b}\n最小值 \\frac{a}{b+1}+1, 最大值 \\frac{a}{b}\n多组数据取一个交集</script><p>最后答案也很好看</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> res_max,res_min;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    res_min = <span class=\"number\">0</span>;</span><br><span class=\"line\">    res_max = <span class=\"number\">1e9</span>+<span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">        res_max = <span class=\"built_in\">min</span>(a/b,res_max);</span><br><span class=\"line\">        res_min = <span class=\"built_in\">max</span>(a/(b+<span class=\"number\">1</span>)+<span class=\"number\">1</span>,res_min);</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,res_min,res_max);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"题解-2\"><p>基本思路是，给定的两个数能找到其范围内的最大值和最小值。不详细说明了，反正是一个很傻瓜的算法，后面不知道什么原因过不了最后两个样例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">judge_ceil</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b&gt;(<span class=\"type\">double</span>)a/c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">judge_floor</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b&gt;=(<span class=\"type\">double</span>)a/c<span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_range</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> &amp;mn,<span class=\"type\">int</span> &amp;mx)</span></span>{</span><br><span class=\"line\">    mn = mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>,r = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">judge_floor</span>(a,b,mid)) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">judge_floor</span>(a,b,l)) mn = l;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> mn = l+<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    l = <span class=\"number\">0</span>,r = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">judge_ceil</span>(a,b,mid)) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">judge_ceil</span>(a,b,l)) mx = l<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> mx = l;</span><br><span class=\"line\">    <span class=\"comment\">// mx = l;</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> res_max,res_min;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    res_min = <span class=\"number\">0</span>;</span><br><span class=\"line\">    res_max = <span class=\"number\">1e9</span>+<span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b,tmp_max,tmp_min;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">get_range</span>(a,b,tmp_min,tmp_max);</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;\"tmp_max&amp;min: \"&lt;&lt;tmp_max&lt;&lt;\" \"&lt;&lt;tmp_min&lt;&lt;endl;</span></span><br><span class=\"line\">        res_max = <span class=\"built_in\">min</span>(tmp_max,res_max);</span><br><span class=\"line\">        res_min = <span class=\"built_in\">max</span>(tmp_min,res_min);</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;res_min&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;res_max&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"4958-接龙数列\"><a href=\"#4958-接龙数列\" class=\"headerlink\" title=\"4958 接龙数列\"></a>4958 接龙数列</h2><p>先复习一下模板（我又忘得差不多了）</p>\n<div class=\"tabs\" id=\"最长上升子序列问题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#最长上升子序列问题-1\">acwing-895.最长上升子序列</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#最长上升子序列问题-2\">第一次尝试：递推</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#最长上升子序列问题-3\">第二次尝试：最长上升子序列的变体（时间复杂度太高）</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#最长上升子序列问题-4\">第三次尝试（Y总的思路）：</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"最长上升子序列问题-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1010</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> f[N];  <span class=\"comment\">// fi 表示以i结尾的 上升子序列的集合  属性 子序列的长度最大值  </span></span><br><span class=\"line\">            <span class=\"comment\">// 状态计算：fi = sigma（fk+1）</span></span><br><span class=\"line\"><span class=\"type\">int</span> g[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i)cin&gt;&gt;g[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        f[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>;j&lt;=i<span class=\"number\">-1</span>;++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(g[i]&gt;f[j]) f[i] = <span class=\"built_in\">max</span>(f[i],f[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        mx = <span class=\"built_in\">max</span>(mx,f[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;mx&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>关键在于理解这一部分</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\"> \tf[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"> \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>;j&lt;=i<span class=\"number\">-1</span>;++j)</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(g[i]&gt;g[j]) f[i] = <span class=\"built_in\">max</span>(f[i],f[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\"> \tmx = <span class=\"built_in\">max</span>(mx,f[i]);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 这里内层循环的顺序对这道题的结果无影响</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">    f[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i<span class=\"number\">-1</span>;j&gt;<span class=\"number\">0</span>;--j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(g[i]&gt;g[j]) f[i] = <span class=\"built_in\">max</span>(f[i],f[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">    mx = <span class=\"built_in\">max</span>(mx,f[i]);</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;\"f_\"&lt;&lt;i&lt;&lt;\": \"&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>按从1—n的次序更新f（n）的值 <script type=\"math/tex\">f(n): 以第n个数为结尾的最长上升子序列的长度</script> </p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"最长上升子序列问题-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态规划</span></span><br><span class=\"line\"><span class=\"comment\">// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 运算 f [n] f[n-1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> d[N];</span><br><span class=\"line\"><span class=\"type\">int</span> f[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> num[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> tail = a%<span class=\"number\">10</span>;  <span class=\"comment\">// a的最后一个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b){</span><br><span class=\"line\">        head = b%<span class=\"number\">10</span>;</span><br><span class=\"line\">        b/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tail==head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i)<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num[i]);</span><br><span class=\"line\">    <span class=\"type\">int</span> last = num[<span class=\"number\">1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(last,num[i])){<span class=\"comment\">//最长接龙尾部的数和当前数满足接龙条件 则f(i+1) = f(i)+1) 还要更新当前最长接龙尾部的值  否则 f(i+1) = f(i)</span></span><br><span class=\"line\">            last = num[i];</span><br><span class=\"line\">            f[i] = f[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">        }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">            f[i] = f[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;n-f[n]&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>具体思路：</p>\n<p>由第一个往后推，如果后一个是当前最长接龙的下一个位置，则更新当前最长接龙尾部的数为当前数并且将fi = length++ 否则 fi = length。</p>\n<p>问题：贪心思想没法找到全局最优解。当前这个可以是最长接龙的尾巴但是不是最好的。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"最长上升子序列问题-3\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态规划</span></span><br><span class=\"line\"><span class=\"comment\">// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 运算 f [n] f[n-1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> d[N];</span><br><span class=\"line\"><span class=\"type\">int</span> f[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> num[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> tail = a%<span class=\"number\">10</span>;  <span class=\"comment\">// a的最后一个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b){</span><br><span class=\"line\">        head = b%<span class=\"number\">10</span>;</span><br><span class=\"line\">        b/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tail==head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i)<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num[i]);</span><br><span class=\"line\">    f[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        f[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i<span class=\"number\">-1</span>;j&gt;<span class=\"number\">0</span>;--j){</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(num[j],num[i])) f[i] = <span class=\"built_in\">max</span>(f[i],f[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        mx = <span class=\"built_in\">max</span>(f[i],mx);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;n-mx&lt;&lt;endl</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>TLE 时间复杂度为<script type=\"math/tex\">O(n^2)</script> 超时了。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"最长上升子序列问题-4\"><p>对于前面的最长上升子序列的优化，主要优化部分是两重循环。</p>\n<p>分析：第二层循环是在前i-1个数据中找到以第i个数头结尾的最长的子序列长度，所以只要记录这个值就ok，因为：==以i个数头结尾的最长的子序列长度是可以穷举，有限的（只有十个）==，而最长子序列无法使用这种方法是因为他需要遍历前面所有的数据找到最值，而这个最值是无法有限次记录的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">// 动态规划</span></span><br><span class=\"line\"><span class=\"comment\">// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 运算 f [n] f[n-1]</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> h[N],l[N],G[<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> f[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        <span class=\"type\">char</span> s[<span class=\"number\">11</span>];</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s);</span><br><span class=\"line\">        h[i] = s[<span class=\"number\">0</span>]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        l[i] = s[<span class=\"built_in\">strlen</span>(s)<span class=\"number\">-1</span>]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        f[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        f[i] = <span class=\"built_in\">max</span>(f[i],G[h[i]]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        G[l[i]] = <span class=\"built_in\">max</span>(f[i],G[l[i]]);</span><br><span class=\"line\">        mx = <span class=\"built_in\">max</span>(f[i],mx);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;n-mx&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"4964-子矩阵\"><a href=\"#4964-子矩阵\" class=\"headerlink\" title=\"4964 子矩阵\"></a>4964 子矩阵</h2><p>数位DP、单调队列。</p>\n<div class=\"tabs\" id=\"子矩阵\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#子矩阵-1\">暴力方法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#子矩阵-2\">暴力解法的优化</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#子矩阵-3\">子矩阵 3</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"子矩阵-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1010</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mod = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> INF = <span class=\"number\">1e9</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> g[N][N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m,n,a,b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">// 暴力</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>,&amp;n,&amp;m,&amp;a,&amp;b);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;++j)<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;g[i][j]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n-a+<span class=\"number\">1</span>;++i){</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m-b+<span class=\"number\">1</span>;++j){</span><br><span class=\"line\">            <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> mi = INF;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> q = i;q&lt;i+a;++q){</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = j;p&lt;j+b;p++){</span><br><span class=\"line\">                    mx = <span class=\"built_in\">max</span>(mx,g[q][p]);</span><br><span class=\"line\">                    mi = <span class=\"built_in\">min</span>(mi,g[q][p]);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">            sum=(sum+(mx*mi))%mod;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,sum);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>时间复杂度可能要到<script type=\"math/tex\">500^4 = 62,500,000,000 \\approx 10^8</script> </p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"子矩阵-2\"><p><strong>This is Tab 2.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"子矩阵-3\"><p><strong>This is Tab 3.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"3431-skew数\"><a href=\"#3431-skew数\" class=\"headerlink\" title=\"3431 skew数\"></a>3431 skew数</h2><p>很简单的一道字符串模拟题目</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(cin,str)){</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = str.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>,k = <span class=\"number\">2</span>;i&gt;=<span class=\"number\">0</span>;--i,k&lt;&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">            res += (str[i]-<span class=\"string\">'0'</span>)*(k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"3446-整数奇偶排序\"><a href=\"#3446-整数奇偶排序\" class=\"headerlink\" title=\"3446 整数奇偶排序\"></a>3446 整数奇偶排序</h2><p>一道很简单的排序题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; odd,even;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a,<span class=\"type\">int</span> &amp;b)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a&gt;b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;t){</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;t&lt;&lt;\" \";</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t%<span class=\"number\">2</span>) odd.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> even.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(odd.<span class=\"built_in\">begin</span>(),odd.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(even.<span class=\"built_in\">begin</span>(),even.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x:odd){</span><br><span class=\"line\">        cout&lt;&lt;x&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x:even){</span><br><span class=\"line\">        cout&lt;&lt;x&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"3508-最长公共子串\"><a href=\"#3508-最长公共子串\" class=\"headerlink\" title=\"3508 最长公共子串\"></a>3508 最长公共子串</h2><p>:exclamation: 求的是公共子串！！！</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/8.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> f[N]; <span class=\"comment\">// 定义 fij a的以第i个char结尾的 和 b的以第j个char结尾的 构成的公共子串  数值：长度的最大值</span></span><br><span class=\"line\"><span class=\"type\">char</span> a[N],b[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s\"</span>,a+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> a_length = <span class=\"built_in\">strlen</span>(a+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> b_length = <span class=\"built_in\">strlen</span>(b+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=a_length;++i){</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = b_length;j&gt;=<span class=\"number\">1</span>;--j){</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i]==b[j] &amp;&amp; a[i]&gt;=<span class=\"string\">'a'</span>) f[j] = f[j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> f[j] = <span class=\"number\">0</span>;  <span class=\"comment\">// 这里不太理解</span></span><br><span class=\"line\">            mx = <span class=\"built_in\">max</span>(mx,f[j]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;mx&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"3543-三元组\"><a href=\"#3543-三元组\" class=\"headerlink\" title=\"3543 三元组\"></a>3543 三元组</h2><p>时间复杂度分析：找一个长度为m中的满足条件的三元组。时间复杂度为<script type=\"math/tex\">O(m^3)</script> m最大为50，n最大为10；所以<script type=\"math/tex\">T(n) = 50^3 10= 1.25 \\times10^6</script> 暴力做法完全可行啊！ 可以做的优化就是将第三重循环做一个二分。这样就可以少一层，但是要先排序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 三重循环遍历</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">51</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> num[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--){</span><br><span class=\"line\">        <span class=\"type\">int</span> m;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        cin&gt;&gt;m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;m;++i){</span><br><span class=\"line\">            cin&gt;&gt;num[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;m;++i){</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>;j&lt;m;++j){</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">0</span>;k&lt;m;++k){</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(num[i]+num[j] == num[k]) cnt++;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"3576-分组统计\"><a href=\"#3576-分组统计\" class=\"headerlink\" title=\"3576 分组统计\"></a>3576 分组统计</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">// 小组数连续且不为空  需要保存一个数值的集合</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">110</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vector&lt;int&gt; set[N];</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> t,n;</span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--){</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; set[N];</span><br><span class=\"line\">        <span class=\"type\">int</span> number[N];</span><br><span class=\"line\">        <span class=\"type\">int</span> gs[N];</span><br><span class=\"line\">        cin&gt;&gt;n;</span><br><span class=\"line\">        <span class=\"type\">int</span> mx_group = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)cin&gt;&gt;number[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i) cin&gt;&gt;gs[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">            set[gs[i]][number[i]]++;</span><br><span class=\"line\">            mx_group = <span class=\"built_in\">max</span>(mx_group,gs[i]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(number,number+n);</span><br><span class=\"line\">        <span class=\"type\">int</span> k = <span class=\"built_in\">unique</span>(number,number+n)-number;</span><br><span class=\"line\">        <span class=\"comment\">// 输出</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> g = <span class=\"number\">1</span>;g&lt;=mx_group;++g){</span><br><span class=\"line\">            cout&lt;&lt;g&lt;&lt;<span class=\"string\">\"={\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;k;++i){</span><br><span class=\"line\">                cout&lt;&lt;number[i]&lt;&lt;<span class=\"string\">\"=\"</span>&lt;&lt;set[g][number[i]];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i+<span class=\"number\">1</span>&lt;k)cout&lt;&lt;<span class=\"string\">\",\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">\"}\\n\"</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>简单模拟。</p>\n<h2 id=\"3395-10进制-VS-2进制\"><a href=\"#3395-10进制-VS-2进制\" class=\"headerlink\" title=\"3395 10进制 VS 2进制\"></a>3395 10进制 VS 2进制</h2><p>这是一道典型的高精度运算的题目</p>\n<div class=\"tabs\" id=\"高精度相关的板子\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#高精度相关的板子-1\">高精度加法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#高精度相关的板子-2\">高精度减法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#高精度相关的板子-3\">高精度乘法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#高精度相关的板子-4\">高精度除法</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"高精度相关的板子-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">add</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;A,vector&lt;<span class=\"type\">int</span>&gt; &amp;B)</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A.<span class=\"built_in\">size</span>()&lt;B.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"built_in\">add</span>(B,A);</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; C;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;A.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        </span><br><span class=\"line\">        t+=A[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;B.<span class=\"built_in\">size</span>()) t+=B[i];</span><br><span class=\"line\">        C.<span class=\"built_in\">push_back</span>(t%<span class=\"number\">10</span>);</span><br><span class=\"line\">        t/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t) C.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> C;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string a,b;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; A,B,C;</span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) A.<span class=\"built_in\">push_back</span>(a[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = b.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) B.<span class=\"built_in\">push_back</span>(b[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    C = <span class=\"built_in\">add</span>(A,B);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = C.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i)cout&lt;&lt;C[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>没啥好说的，注意输入和输出的数组顺序。add函数在处理加法的时候是从低位处理到高位，所以在输入的时候需要将低位放在前面，这和我们日常的书写顺序是相反的。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"高精度相关的板子-2\"><p>和加法差不多（差得不太多）</p>\n<ul>\n<li>判断两个数的大小，用大的减去小的。</li>\n<li>由于减法并不像加法有交换律所以定义减法的函数中减数和被减数的位置是固定的。</li>\n<li>对于前导0 的处理。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a,vector&lt;<span class=\"type\">int</span>&gt; &amp;b)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.<span class=\"built_in\">size</span>()!=b.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> a.<span class=\"built_in\">size</span>()&gt;b.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]!=b[i]) <span class=\"keyword\">return</span> a[i]&gt;b[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 比较两个数的大小，返回a&gt;=b；</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sub</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a,vector&lt;<span class=\"type\">int</span>&gt; &amp;b)</span></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; c;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;a.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        t = a[i]-t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;b.<span class=\"built_in\">size</span>()) t-=b[i];</span><br><span class=\"line\">        c.<span class=\"built_in\">push_back</span>((t+<span class=\"number\">10</span>)%<span class=\"number\">10</span>);  <span class=\"comment\">// 因为t可能是个负数，所以取其10 的mod 是借位后的数位。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t&lt;<span class=\"number\">0</span>) t = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span> &amp;&amp; c.<span class=\"built_in\">back</span>()==<span class=\"number\">0</span>) c.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string a_s,b_s;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; a,b,c;</span><br><span class=\"line\">    cin&gt;&gt;a_s&gt;&gt;b_s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a_s.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) a.<span class=\"built_in\">push_back</span>(a_s[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = b_s.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) b.<span class=\"built_in\">push_back</span>(b_s[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">cmp</span>(a,b)){</span><br><span class=\"line\">        c = <span class=\"built_in\">sub</span>(a,b);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        c = <span class=\"built_in\">sub</span>(b,a);</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">\"-\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = c.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) cout&lt;&lt;c[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"高精度相关的板子-3\"><p>需要注意的是：</p>\n<ul>\n<li>对于结果的前导0的处理</li>\n<li>结果一定会大于原式，如何处理多出原本被乘数size的数位。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">multi</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a,<span class=\"type\">int</span> b)</span></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; c;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;a.<span class=\"built_in\">size</span>()||t&gt;<span class=\"number\">0</span>;++i){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;a.<span class=\"built_in\">size</span>()) t += b*a[i];</span><br><span class=\"line\">        c.<span class=\"built_in\">push_back</span>(t%<span class=\"number\">10</span>);</span><br><span class=\"line\">        t/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span> &amp;&amp; c.<span class=\"built_in\">back</span>()==<span class=\"number\">0</span>) c.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    <span class=\"type\">int</span> b;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; A;</span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b==<span class=\"number\">0</span>){</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;--i){</span><br><span class=\"line\">        A.<span class=\"built_in\">push_back</span>(a[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; C = <span class=\"built_in\">multi</span>(A,b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = C.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;--i)cout&lt;&lt;C[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"高精度相关的板子-4\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">div</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;A, <span class=\"type\">int</span> b, <span class=\"type\">int</span> &amp;r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; C;</span><br><span class=\"line\">    r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = A.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i -- )</span><br><span class=\"line\">    {</span><br><span class=\"line\">        r = r * <span class=\"number\">10</span> + A[i];</span><br><span class=\"line\">        C.<span class=\"built_in\">push_back</span>(r / b);</span><br><span class=\"line\">        r %= b;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(C.<span class=\"built_in\">begin</span>(), C.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (C.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">1</span> &amp;&amp; C.<span class=\"built_in\">back</span>() == <span class=\"number\">0</span>) C.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> C;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; A;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> B;</span><br><span class=\"line\">    cin &gt;&gt; a &gt;&gt; B;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = a.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i -- ) A.<span class=\"built_in\">push_back</span>(a[i] - <span class=\"string\">'0'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> C = <span class=\"built_in\">div</span>(A, B, r);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = C.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<blockquote>\n<p>题目描述：</p>\n<p>对于一个十进制数 A，将 A转换为二进制数，然后按位逆序排列，再转换为十进制数 B，我们称 B为 A 的二进制逆序数。</p>\n<p>例如对于十进制数 173173，它的二进制形式为 1010110110101101，逆序排列得到 1011010110110101，其十进制数为 181181，181181 即为 173173 的二进制逆序数。</p>\n</blockquote>\n<p>注意：二进制转十进制的加法表示！！！秦九韶算法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">div_2</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a,<span class=\"type\">int</span> &amp;r)</span></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; c;</span><br><span class=\"line\">    r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;--i){</span><br><span class=\"line\">        r = r*<span class=\"number\">10</span>+a[i];</span><br><span class=\"line\">        c.<span class=\"built_in\">push_back</span>(r&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">        r%=<span class=\"number\">2</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(c.<span class=\"built_in\">begin</span>(),c.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span> &amp;&amp; c.<span class=\"built_in\">back</span>()==<span class=\"number\">0</span>) c.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">add</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; a,vector&lt;<span class=\"type\">int</span>&gt; b)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.<span class=\"built_in\">size</span>()&lt;b.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"built_in\">add</span>(b,a);</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; c;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;a.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        t += a[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;b.<span class=\"built_in\">size</span>()) t+=b[i];</span><br><span class=\"line\">        c.<span class=\"built_in\">push_back</span>(t%<span class=\"number\">10</span>);</span><br><span class=\"line\">        t/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t) c.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; a)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dec_to_bin</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a)</span></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cmp</span>(a)){</span><br><span class=\"line\">        <span class=\"type\">int</span> r;</span><br><span class=\"line\">        a = <span class=\"built_in\">div_2</span>(a,r);</span><br><span class=\"line\">        b.<span class=\"built_in\">push_back</span>(r);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">bin_to_dec</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;b)</span></span>{  <span class=\"comment\">//二进制转十进制的算法很香。 秦九韶算法</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; d;</span><br><span class=\"line\">    d.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;b.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        d = <span class=\"built_in\">add</span>(<span class=\"built_in\">add</span>(d,d),{b[i]});</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string a_s;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; a,b,d;</span><br><span class=\"line\">    cin&gt;&gt;a_s;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a_s.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;--i) a.<span class=\"built_in\">push_back</span>(a_s[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    b = <span class=\"built_in\">dec_to_bin</span>(a);</span><br><span class=\"line\"></span><br><span class=\"line\">    d = <span class=\"built_in\">bin_to_dec</span>(b);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = d.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i --) cout &lt;&lt; d[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>详解一下如何计算大数二进制转大数十进制：</p>\n<script type=\"math/tex; mode=display\">\n假设 当前二进制的数组为: \\ \\  b_i, b_{i-1},\\cdots,b_{1},b_{0};   \\ \\ (ps : 从高位到低位。)\\\\\n正常的计算方法是: \\ \\ \\  res = \\sum_{k=0}^{i}{2^{k}b_{k}} \\\\\n对于这个算法显然不适合大数计算，因为计算2^k 是一个乘法运算，在这个算法里面，乘法和加法的混合运算显然会使得算法的时间复杂度上升\\\\\n因此 我们可以使用秦九韶算法来简化步骤将所有的乘法运算都化简为加法运算\\\\\n由res = \\sum_{k=0}^{i}{2^{k}b_{k}},我们不妨拿出前四项: res_{前四项} = b_{3}2^3+ b_{2}2^2+ b_{1}2^1+ b_{0}2^0 = \n\\{[b_{3}2+b_{2}]2+b_1\\}2+b_0; \\\\\n故可以使用秦九韶算法化简步骤</script><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">bin_to_dec</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;b)</span></span>{  <span class=\"comment\">//二进制转十进制的算法很香。 秦九韶算法</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; d;</span><br><span class=\"line\">    d.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;b.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        d = <span class=\"built_in\">add</span>(<span class=\"built_in\">add</span>(d,d),{b[i]});</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-09</p>\n</div></div><div class=\"timeline-item-content\"><p>根据先序序列输出中序序列。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-10</p>\n</div></div><div class=\"timeline-item-content\"><p>冶炼金属，一道数学题。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-14</p>\n</div></div><div class=\"timeline-item-content\"><p>最长上升子序列的变形。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-15</p>\n</div></div><div class=\"timeline-item-content\"><p>子矩阵、接龙数列、skew数</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-18</p>\n</div></div><div class=\"timeline-item-content\"><p>整数奇偶排序</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-19</p>\n</div></div><div class=\"timeline-item-content\"><p>最长公共子串。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-20</p>\n</div></div><div class=\"timeline-item-content\"><p>很简单的一道题目，三重循环</p>\n<ul>\n<li><p>三元组。</p>\n</li>\n<li><p>分组统计</p>\n</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-22</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>高精度进制转换</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"每日一题\"><a href=\"#每日一题\" class=\"headerlink\" title=\"每日一题\"></a>每日一题</h1><h2 id=\"3384-二叉树遍历\"><a href=\"#3384-二叉树遍历\" class=\"headerlink\" title=\"3384 二叉树遍历\"></a>3384 二叉树遍历</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">char</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>,&amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;=<span class=\"string\">'a'</span> &amp;&amp; x&lt;=<span class=\"string\">'z'</span>){</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c \"</span>,x);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"4956冶炼金属\"><a href=\"#4956冶炼金属\" class=\"headerlink\" title=\"4956冶炼金属\"></a>4956冶炼金属</h2><div class=\"tabs\" id=\"题解\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#题解-1\">最简单的答案--数学推导</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#题解-2\">我自己想的，二分查找，只能过前八个样例</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"题解-1\"><script type=\"math/tex; mode=display\">\n(暴力枚举) O\\left(n^2\\right)\n设答案为 x, 则有 b \\leqslant \\frac{a}{x}<b+1\n即 \\frac{a}{b+1}<x \\leqslant \\frac{a}{b}\n最小值 \\frac{a}{b+1}+1, 最大值 \\frac{a}{b}\n多组数据取一个交集</script><p>最后答案也很好看</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> res_max,res_min;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    res_min = <span class=\"number\">0</span>;</span><br><span class=\"line\">    res_max = <span class=\"number\">1e9</span>+<span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">        res_max = <span class=\"built_in\">min</span>(a/b,res_max);</span><br><span class=\"line\">        res_min = <span class=\"built_in\">max</span>(a/(b+<span class=\"number\">1</span>)+<span class=\"number\">1</span>,res_min);</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,res_min,res_max);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"题解-2\"><p>基本思路是，给定的两个数能找到其范围内的最大值和最小值。不详细说明了，反正是一个很傻瓜的算法，后面不知道什么原因过不了最后两个样例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">judge_ceil</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b&gt;(<span class=\"type\">double</span>)a/c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">judge_floor</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b&gt;=(<span class=\"type\">double</span>)a/c<span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_range</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> &amp;mn,<span class=\"type\">int</span> &amp;mx)</span></span>{</span><br><span class=\"line\">    mn = mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>,r = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">judge_floor</span>(a,b,mid)) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">judge_floor</span>(a,b,l)) mn = l;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> mn = l+<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    l = <span class=\"number\">0</span>,r = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">judge_ceil</span>(a,b,mid)) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">judge_ceil</span>(a,b,l)) mx = l<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> mx = l;</span><br><span class=\"line\">    <span class=\"comment\">// mx = l;</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> res_max,res_min;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    res_min = <span class=\"number\">0</span>;</span><br><span class=\"line\">    res_max = <span class=\"number\">1e9</span>+<span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b,tmp_max,tmp_min;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">get_range</span>(a,b,tmp_min,tmp_max);</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;\"tmp_max&amp;min: \"&lt;&lt;tmp_max&lt;&lt;\" \"&lt;&lt;tmp_min&lt;&lt;endl;</span></span><br><span class=\"line\">        res_max = <span class=\"built_in\">min</span>(tmp_max,res_max);</span><br><span class=\"line\">        res_min = <span class=\"built_in\">max</span>(tmp_min,res_min);</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;res_min&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;res_max&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"4958-接龙数列\"><a href=\"#4958-接龙数列\" class=\"headerlink\" title=\"4958 接龙数列\"></a>4958 接龙数列</h2><p>先复习一下模板（我又忘得差不多了）</p>\n<div class=\"tabs\" id=\"最长上升子序列问题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#最长上升子序列问题-1\">acwing-895.最长上升子序列</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#最长上升子序列问题-2\">第一次尝试：递推</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#最长上升子序列问题-3\">第二次尝试：最长上升子序列的变体（时间复杂度太高）</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#最长上升子序列问题-4\">第三次尝试（Y总的思路）：</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"最长上升子序列问题-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1010</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> f[N];  <span class=\"comment\">// fi 表示以i结尾的 上升子序列的集合  属性 子序列的长度最大值  </span></span><br><span class=\"line\">            <span class=\"comment\">// 状态计算：fi = sigma（fk+1）</span></span><br><span class=\"line\"><span class=\"type\">int</span> g[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i)cin&gt;&gt;g[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        f[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>;j&lt;=i<span class=\"number\">-1</span>;++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(g[i]&gt;f[j]) f[i] = <span class=\"built_in\">max</span>(f[i],f[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        mx = <span class=\"built_in\">max</span>(mx,f[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;mx&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>关键在于理解这一部分</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\"> \tf[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"> \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>;j&lt;=i<span class=\"number\">-1</span>;++j)</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(g[i]&gt;g[j]) f[i] = <span class=\"built_in\">max</span>(f[i],f[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\"> \tmx = <span class=\"built_in\">max</span>(mx,f[i]);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 这里内层循环的顺序对这道题的结果无影响</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">    f[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i<span class=\"number\">-1</span>;j&gt;<span class=\"number\">0</span>;--j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(g[i]&gt;g[j]) f[i] = <span class=\"built_in\">max</span>(f[i],f[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">    mx = <span class=\"built_in\">max</span>(mx,f[i]);</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;\"f_\"&lt;&lt;i&lt;&lt;\": \"&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>按从1—n的次序更新f（n）的值 <script type=\"math/tex\">f(n): 以第n个数为结尾的最长上升子序列的长度</script> </p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"最长上升子序列问题-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态规划</span></span><br><span class=\"line\"><span class=\"comment\">// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 运算 f [n] f[n-1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> d[N];</span><br><span class=\"line\"><span class=\"type\">int</span> f[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> num[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> tail = a%<span class=\"number\">10</span>;  <span class=\"comment\">// a的最后一个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b){</span><br><span class=\"line\">        head = b%<span class=\"number\">10</span>;</span><br><span class=\"line\">        b/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tail==head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i)<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num[i]);</span><br><span class=\"line\">    <span class=\"type\">int</span> last = num[<span class=\"number\">1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(last,num[i])){<span class=\"comment\">//最长接龙尾部的数和当前数满足接龙条件 则f(i+1) = f(i)+1) 还要更新当前最长接龙尾部的值  否则 f(i+1) = f(i)</span></span><br><span class=\"line\">            last = num[i];</span><br><span class=\"line\">            f[i] = f[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">        }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">            f[i] = f[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;n-f[n]&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>具体思路：</p>\n<p>由第一个往后推，如果后一个是当前最长接龙的下一个位置，则更新当前最长接龙尾部的数为当前数并且将fi = length++ 否则 fi = length。</p>\n<p>问题：贪心思想没法找到全局最优解。当前这个可以是最长接龙的尾巴但是不是最好的。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"最长上升子序列问题-3\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态规划</span></span><br><span class=\"line\"><span class=\"comment\">// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 运算 f [n] f[n-1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> d[N];</span><br><span class=\"line\"><span class=\"type\">int</span> f[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> num[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> tail = a%<span class=\"number\">10</span>;  <span class=\"comment\">// a的最后一个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b){</span><br><span class=\"line\">        head = b%<span class=\"number\">10</span>;</span><br><span class=\"line\">        b/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tail==head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i)<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num[i]);</span><br><span class=\"line\">    f[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        f[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i<span class=\"number\">-1</span>;j&gt;<span class=\"number\">0</span>;--j){</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(num[j],num[i])) f[i] = <span class=\"built_in\">max</span>(f[i],f[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        mx = <span class=\"built_in\">max</span>(f[i],mx);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;n-mx&lt;&lt;endl</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>TLE 时间复杂度为<script type=\"math/tex\">O(n^2)</script> 超时了。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"最长上升子序列问题-4\"><p>对于前面的最长上升子序列的优化，主要优化部分是两重循环。</p>\n<p>分析：第二层循环是在前i-1个数据中找到以第i个数头结尾的最长的子序列长度，所以只要记录这个值就ok，因为：==以i个数头结尾的最长的子序列长度是可以穷举，有限的（只有十个）==，而最长子序列无法使用这种方法是因为他需要遍历前面所有的数据找到最值，而这个最值是无法有限次记录的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">// 动态规划</span></span><br><span class=\"line\"><span class=\"comment\">// d(j) 前j个数组中组成 合法串的集合  值：最长  最长上升子序列！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 运算 f [n] f[n-1]</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> h[N],l[N],G[<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> f[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        <span class=\"type\">char</span> s[<span class=\"number\">11</span>];</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s);</span><br><span class=\"line\">        h[i] = s[<span class=\"number\">0</span>]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        l[i] = s[<span class=\"built_in\">strlen</span>(s)<span class=\"number\">-1</span>]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        f[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        f[i] = <span class=\"built_in\">max</span>(f[i],G[h[i]]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        G[l[i]] = <span class=\"built_in\">max</span>(f[i],G[l[i]]);</span><br><span class=\"line\">        mx = <span class=\"built_in\">max</span>(f[i],mx);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;n-mx&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"4964-子矩阵\"><a href=\"#4964-子矩阵\" class=\"headerlink\" title=\"4964 子矩阵\"></a>4964 子矩阵</h2><p>数位DP、单调队列。</p>\n<div class=\"tabs\" id=\"子矩阵\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#子矩阵-1\">暴力方法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#子矩阵-2\">暴力解法的优化</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#子矩阵-3\">子矩阵 3</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"子矩阵-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1010</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mod = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> INF = <span class=\"number\">1e9</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> g[N][N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m,n,a,b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">// 暴力</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>,&amp;n,&amp;m,&amp;a,&amp;b);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;++j)<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;g[i][j]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n-a+<span class=\"number\">1</span>;++i){</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m-b+<span class=\"number\">1</span>;++j){</span><br><span class=\"line\">            <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> mi = INF;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> q = i;q&lt;i+a;++q){</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = j;p&lt;j+b;p++){</span><br><span class=\"line\">                    mx = <span class=\"built_in\">max</span>(mx,g[q][p]);</span><br><span class=\"line\">                    mi = <span class=\"built_in\">min</span>(mi,g[q][p]);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">            sum=(sum+(mx*mi))%mod;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,sum);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>时间复杂度可能要到<script type=\"math/tex\">500^4 = 62,500,000,000 \\approx 10^8</script> </p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"子矩阵-2\"><p><strong>This is Tab 2.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"子矩阵-3\"><p><strong>This is Tab 3.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"3431-skew数\"><a href=\"#3431-skew数\" class=\"headerlink\" title=\"3431 skew数\"></a>3431 skew数</h2><p>很简单的一道字符串模拟题目</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(cin,str)){</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = str.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>,k = <span class=\"number\">2</span>;i&gt;=<span class=\"number\">0</span>;--i,k&lt;&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">            res += (str[i]-<span class=\"string\">'0'</span>)*(k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"3446-整数奇偶排序\"><a href=\"#3446-整数奇偶排序\" class=\"headerlink\" title=\"3446 整数奇偶排序\"></a>3446 整数奇偶排序</h2><p>一道很简单的排序题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; odd,even;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a,<span class=\"type\">int</span> &amp;b)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a&gt;b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;t){</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;t&lt;&lt;\" \";</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t%<span class=\"number\">2</span>) odd.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> even.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(odd.<span class=\"built_in\">begin</span>(),odd.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(even.<span class=\"built_in\">begin</span>(),even.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x:odd){</span><br><span class=\"line\">        cout&lt;&lt;x&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x:even){</span><br><span class=\"line\">        cout&lt;&lt;x&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"3508-最长公共子串\"><a href=\"#3508-最长公共子串\" class=\"headerlink\" title=\"3508 最长公共子串\"></a>3508 最长公共子串</h2><p>:exclamation: 求的是公共子串！！！</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/8.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> f[N]; <span class=\"comment\">// 定义 fij a的以第i个char结尾的 和 b的以第j个char结尾的 构成的公共子串  数值：长度的最大值</span></span><br><span class=\"line\"><span class=\"type\">char</span> a[N],b[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s\"</span>,a+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> a_length = <span class=\"built_in\">strlen</span>(a+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> b_length = <span class=\"built_in\">strlen</span>(b+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=a_length;++i){</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = b_length;j&gt;=<span class=\"number\">1</span>;--j){</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i]==b[j] &amp;&amp; a[i]&gt;=<span class=\"string\">'a'</span>) f[j] = f[j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> f[j] = <span class=\"number\">0</span>;  <span class=\"comment\">// 这里不太理解</span></span><br><span class=\"line\">            mx = <span class=\"built_in\">max</span>(mx,f[j]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;mx&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"3543-三元组\"><a href=\"#3543-三元组\" class=\"headerlink\" title=\"3543 三元组\"></a>3543 三元组</h2><p>时间复杂度分析：找一个长度为m中的满足条件的三元组。时间复杂度为<script type=\"math/tex\">O(m^3)</script> m最大为50，n最大为10；所以<script type=\"math/tex\">T(n) = 50^3 10= 1.25 \\times10^6</script> 暴力做法完全可行啊！ 可以做的优化就是将第三重循环做一个二分。这样就可以少一层，但是要先排序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 三重循环遍历</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">51</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> num[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--){</span><br><span class=\"line\">        <span class=\"type\">int</span> m;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        cin&gt;&gt;m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;m;++i){</span><br><span class=\"line\">            cin&gt;&gt;num[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;m;++i){</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>;j&lt;m;++j){</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">0</span>;k&lt;m;++k){</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(num[i]+num[j] == num[k]) cnt++;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"3576-分组统计\"><a href=\"#3576-分组统计\" class=\"headerlink\" title=\"3576 分组统计\"></a>3576 分组统计</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">// 小组数连续且不为空  需要保存一个数值的集合</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">110</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vector&lt;int&gt; set[N];</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> t,n;</span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--){</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; set[N];</span><br><span class=\"line\">        <span class=\"type\">int</span> number[N];</span><br><span class=\"line\">        <span class=\"type\">int</span> gs[N];</span><br><span class=\"line\">        cin&gt;&gt;n;</span><br><span class=\"line\">        <span class=\"type\">int</span> mx_group = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)cin&gt;&gt;number[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i) cin&gt;&gt;gs[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">            set[gs[i]][number[i]]++;</span><br><span class=\"line\">            mx_group = <span class=\"built_in\">max</span>(mx_group,gs[i]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(number,number+n);</span><br><span class=\"line\">        <span class=\"type\">int</span> k = <span class=\"built_in\">unique</span>(number,number+n)-number;</span><br><span class=\"line\">        <span class=\"comment\">// 输出</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> g = <span class=\"number\">1</span>;g&lt;=mx_group;++g){</span><br><span class=\"line\">            cout&lt;&lt;g&lt;&lt;<span class=\"string\">\"={\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;k;++i){</span><br><span class=\"line\">                cout&lt;&lt;number[i]&lt;&lt;<span class=\"string\">\"=\"</span>&lt;&lt;set[g][number[i]];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i+<span class=\"number\">1</span>&lt;k)cout&lt;&lt;<span class=\"string\">\",\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">\"}\\n\"</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>简单模拟。</p>\n<h2 id=\"3395-10进制-VS-2进制\"><a href=\"#3395-10进制-VS-2进制\" class=\"headerlink\" title=\"3395 10进制 VS 2进制\"></a>3395 10进制 VS 2进制</h2><p>这是一道典型的高精度运算的题目</p>\n<div class=\"tabs\" id=\"高精度相关的板子\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#高精度相关的板子-1\">高精度加法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#高精度相关的板子-2\">高精度减法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#高精度相关的板子-3\">高精度乘法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#高精度相关的板子-4\">高精度除法</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"高精度相关的板子-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">add</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;A,vector&lt;<span class=\"type\">int</span>&gt; &amp;B)</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A.<span class=\"built_in\">size</span>()&lt;B.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"built_in\">add</span>(B,A);</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; C;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;A.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        </span><br><span class=\"line\">        t+=A[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;B.<span class=\"built_in\">size</span>()) t+=B[i];</span><br><span class=\"line\">        C.<span class=\"built_in\">push_back</span>(t%<span class=\"number\">10</span>);</span><br><span class=\"line\">        t/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t) C.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> C;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string a,b;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; A,B,C;</span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) A.<span class=\"built_in\">push_back</span>(a[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = b.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) B.<span class=\"built_in\">push_back</span>(b[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    C = <span class=\"built_in\">add</span>(A,B);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = C.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i)cout&lt;&lt;C[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>没啥好说的，注意输入和输出的数组顺序。add函数在处理加法的时候是从低位处理到高位，所以在输入的时候需要将低位放在前面，这和我们日常的书写顺序是相反的。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"高精度相关的板子-2\"><p>和加法差不多（差得不太多）</p>\n<ul>\n<li>判断两个数的大小，用大的减去小的。</li>\n<li>由于减法并不像加法有交换律所以定义减法的函数中减数和被减数的位置是固定的。</li>\n<li>对于前导0 的处理。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a,vector&lt;<span class=\"type\">int</span>&gt; &amp;b)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.<span class=\"built_in\">size</span>()!=b.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> a.<span class=\"built_in\">size</span>()&gt;b.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]!=b[i]) <span class=\"keyword\">return</span> a[i]&gt;b[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 比较两个数的大小，返回a&gt;=b；</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sub</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a,vector&lt;<span class=\"type\">int</span>&gt; &amp;b)</span></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; c;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;a.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        t = a[i]-t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;b.<span class=\"built_in\">size</span>()) t-=b[i];</span><br><span class=\"line\">        c.<span class=\"built_in\">push_back</span>((t+<span class=\"number\">10</span>)%<span class=\"number\">10</span>);  <span class=\"comment\">// 因为t可能是个负数，所以取其10 的mod 是借位后的数位。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t&lt;<span class=\"number\">0</span>) t = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span> &amp;&amp; c.<span class=\"built_in\">back</span>()==<span class=\"number\">0</span>) c.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string a_s,b_s;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; a,b,c;</span><br><span class=\"line\">    cin&gt;&gt;a_s&gt;&gt;b_s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a_s.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) a.<span class=\"built_in\">push_back</span>(a_s[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = b_s.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) b.<span class=\"built_in\">push_back</span>(b_s[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">cmp</span>(a,b)){</span><br><span class=\"line\">        c = <span class=\"built_in\">sub</span>(a,b);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        c = <span class=\"built_in\">sub</span>(b,a);</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">\"-\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = c.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i) cout&lt;&lt;c[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"高精度相关的板子-3\"><p>需要注意的是：</p>\n<ul>\n<li>对于结果的前导0的处理</li>\n<li>结果一定会大于原式，如何处理多出原本被乘数size的数位。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">multi</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a,<span class=\"type\">int</span> b)</span></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; c;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;a.<span class=\"built_in\">size</span>()||t&gt;<span class=\"number\">0</span>;++i){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;a.<span class=\"built_in\">size</span>()) t += b*a[i];</span><br><span class=\"line\">        c.<span class=\"built_in\">push_back</span>(t%<span class=\"number\">10</span>);</span><br><span class=\"line\">        t/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span> &amp;&amp; c.<span class=\"built_in\">back</span>()==<span class=\"number\">0</span>) c.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    <span class=\"type\">int</span> b;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; A;</span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b==<span class=\"number\">0</span>){</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;--i){</span><br><span class=\"line\">        A.<span class=\"built_in\">push_back</span>(a[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; C = <span class=\"built_in\">multi</span>(A,b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = C.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;--i)cout&lt;&lt;C[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"高精度相关的板子-4\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">div</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;A, <span class=\"type\">int</span> b, <span class=\"type\">int</span> &amp;r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; C;</span><br><span class=\"line\">    r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = A.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i -- )</span><br><span class=\"line\">    {</span><br><span class=\"line\">        r = r * <span class=\"number\">10</span> + A[i];</span><br><span class=\"line\">        C.<span class=\"built_in\">push_back</span>(r / b);</span><br><span class=\"line\">        r %= b;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(C.<span class=\"built_in\">begin</span>(), C.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (C.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">1</span> &amp;&amp; C.<span class=\"built_in\">back</span>() == <span class=\"number\">0</span>) C.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> C;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; A;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> B;</span><br><span class=\"line\">    cin &gt;&gt; a &gt;&gt; B;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = a.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i -- ) A.<span class=\"built_in\">push_back</span>(a[i] - <span class=\"string\">'0'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> C = <span class=\"built_in\">div</span>(A, B, r);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = C.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<blockquote>\n<p>题目描述：</p>\n<p>对于一个十进制数 A，将 A转换为二进制数，然后按位逆序排列，再转换为十进制数 B，我们称 B为 A 的二进制逆序数。</p>\n<p>例如对于十进制数 173173，它的二进制形式为 1010110110101101，逆序排列得到 1011010110110101，其十进制数为 181181，181181 即为 173173 的二进制逆序数。</p>\n</blockquote>\n<p>注意：二进制转十进制的加法表示！！！秦九韶算法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">div_2</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a,<span class=\"type\">int</span> &amp;r)</span></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; c;</span><br><span class=\"line\">    r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;--i){</span><br><span class=\"line\">        r = r*<span class=\"number\">10</span>+a[i];</span><br><span class=\"line\">        c.<span class=\"built_in\">push_back</span>(r&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">        r%=<span class=\"number\">2</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(c.<span class=\"built_in\">begin</span>(),c.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span> &amp;&amp; c.<span class=\"built_in\">back</span>()==<span class=\"number\">0</span>) c.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">add</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; a,vector&lt;<span class=\"type\">int</span>&gt; b)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.<span class=\"built_in\">size</span>()&lt;b.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"built_in\">add</span>(b,a);</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; c;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;a.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        t += a[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;b.<span class=\"built_in\">size</span>()) t+=b[i];</span><br><span class=\"line\">        c.<span class=\"built_in\">push_back</span>(t%<span class=\"number\">10</span>);</span><br><span class=\"line\">        t/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t) c.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; a)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dec_to_bin</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a)</span></span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cmp</span>(a)){</span><br><span class=\"line\">        <span class=\"type\">int</span> r;</span><br><span class=\"line\">        a = <span class=\"built_in\">div_2</span>(a,r);</span><br><span class=\"line\">        b.<span class=\"built_in\">push_back</span>(r);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">bin_to_dec</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;b)</span></span>{  <span class=\"comment\">//二进制转十进制的算法很香。 秦九韶算法</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; d;</span><br><span class=\"line\">    d.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;b.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        d = <span class=\"built_in\">add</span>(<span class=\"built_in\">add</span>(d,d),{b[i]});</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string a_s;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; a,b,d;</span><br><span class=\"line\">    cin&gt;&gt;a_s;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a_s.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;--i) a.<span class=\"built_in\">push_back</span>(a_s[i]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">    b = <span class=\"built_in\">dec_to_bin</span>(a);</span><br><span class=\"line\"></span><br><span class=\"line\">    d = <span class=\"built_in\">bin_to_dec</span>(b);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = d.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i --) cout &lt;&lt; d[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>详解一下如何计算大数二进制转大数十进制：</p>\n<script type=\"math/tex; mode=display\">\n假设 当前二进制的数组为: \\ \\  b_i, b_{i-1},\\cdots,b_{1},b_{0};   \\ \\ (ps : 从高位到低位。)\\\\\n正常的计算方法是: \\ \\ \\  res = \\sum_{k=0}^{i}{2^{k}b_{k}} \\\\\n对于这个算法显然不适合大数计算，因为计算2^k 是一个乘法运算，在这个算法里面，乘法和加法的混合运算显然会使得算法的时间复杂度上升\\\\\n因此 我们可以使用秦九韶算法来简化步骤将所有的乘法运算都化简为加法运算\\\\\n由res = \\sum_{k=0}^{i}{2^{k}b_{k}},我们不妨拿出前四项: res_{前四项} = b_{3}2^3+ b_{2}2^2+ b_{1}2^1+ b_{0}2^0 = \n\\{[b_{3}2+b_{2}]2+b_1\\}2+b_0; \\\\\n故可以使用秦九韶算法化简步骤</script><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">bin_to_dec</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;b)</span></span>{  <span class=\"comment\">//二进制转十进制的算法很香。 秦九韶算法</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; d;</span><br><span class=\"line\">    d.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;b.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        d = <span class=\"built_in\">add</span>(<span class=\"built_in\">add</span>(d,d),{b[i]});</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n"},{"title":"Hello World","date":"2023-03-22T16:00:00.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntag: start\ndate: 2023-3-23\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2023-04-11T12:01:02.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwm60007bsuoeudl7d9h","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"外挂标签速查","date":"2023-03-28T06:08:57.682Z","cover":"https://my-blog-pics-repo.oss-cn-shanghai.aliyuncs.com/Cover_img/105773900_p0.jpg","_content":"\n\n\nhttps://butterfly.js.org/posts/4aa8abbe/\n\n# hexo butterfly 主题的外挂标签 速查\n\n## Note 标签\n\n```markdown\n{% note [color] [icon] [style] %}\nAny content (support inline tags too.io).\n{% endnote %}\n```\n\n| 名称  | 用法                                                         |\n| ----- | ------------------------------------------------------------ |\n| color | 【可選】顔色(default / blue / pink / red / purple / orange / green) |\n| icon  | 【可選】可配置自定義 icon (只支持 fontawesome 圖標, 也可以配置 no-icon ) |\n| style | 【可選】可以覆蓋配置中的 style（simple/modern/flat/disabled） |\n\n## tag-hide标签\n\n```markdown\n{% hideToggle display,bg,color %}\ncontent\n{% endhideToggle %}\n```\n\n## Tabs 标签\n\n横向可选择的框栏\n\n```markdown\n{% tabs test1 %}\n<!-- tab -->\n**This is Tab 1.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 2.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n```\n\n```markdown\n{% tabs test4 %}\n<!-- tab 第一個Tab -->\n**tab名字為第一個Tab**\n<!-- endtab -->\n\n<!-- tab @fab fa-apple-pay -->\n**只有圖標 沒有Tab名字**\n<!-- endtab -->\n\n<!-- tab 炸彈@fas fa-bomb -->\n**名字+icon**\n<!-- endtab -->\n{% endtabs %}\n\n```\n\n## label标签\n\n高亮文字\n\n```\n{% label text color %}\n```\n\n| 参数  | 解释                                                         |\n| ----- | ------------------------------------------------------------ |\n| text  | 待高亮的文字                                                 |\n| color | 【可選】背景顏色，默認為 default  default/blue/pink/red/purple/orange/green |\n\n\n\n## timeline标签\n\n```\n{% timeline 2022,blue %}\n<!-- timeline 01-02 -->\n這是測試頁面\n<!-- endtimeline -->\n{% endtimeline %}\n```\n\n## Mermaid标签\n\n```\n{% mermaid %}\n內容\n{% endmermaid %}\n```\n\n## 记录算法题解和思路的tabs 标签\n\n```\n{% tabs 思路&&题解 %}\n<!-- tab 思路-->\n**This is Tab 1.**\n<!-- endtab -->\n\n<!-- tab 题解-->\n**This is Tab 2.**\n<!-- endtab -->\n{% endtabs %}\n\n\n```\n\n","source":"_posts/hexo-外挂标签模板-速查.md","raw":"---\ntitle: 外挂标签速查\ntag: \n- 主题美化\n- 标签速查\ncategories:\n- 学习笔记\ndate: {{date}}\ncover: https://my-blog-pics-repo.oss-cn-shanghai.aliyuncs.com/Cover_img/105773900_p0.jpg\n---\n\n\n\nhttps://butterfly.js.org/posts/4aa8abbe/\n\n# hexo butterfly 主题的外挂标签 速查\n\n## Note 标签\n\n```markdown\n{% note [color] [icon] [style] %}\nAny content (support inline tags too.io).\n{% endnote %}\n```\n\n| 名称  | 用法                                                         |\n| ----- | ------------------------------------------------------------ |\n| color | 【可選】顔色(default / blue / pink / red / purple / orange / green) |\n| icon  | 【可選】可配置自定義 icon (只支持 fontawesome 圖標, 也可以配置 no-icon ) |\n| style | 【可選】可以覆蓋配置中的 style（simple/modern/flat/disabled） |\n\n## tag-hide标签\n\n```markdown\n{% hideToggle display,bg,color %}\ncontent\n{% endhideToggle %}\n```\n\n## Tabs 标签\n\n横向可选择的框栏\n\n```markdown\n{% tabs test1 %}\n<!-- tab -->\n**This is Tab 1.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 2.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n```\n\n```markdown\n{% tabs test4 %}\n<!-- tab 第一個Tab -->\n**tab名字為第一個Tab**\n<!-- endtab -->\n\n<!-- tab @fab fa-apple-pay -->\n**只有圖標 沒有Tab名字**\n<!-- endtab -->\n\n<!-- tab 炸彈@fas fa-bomb -->\n**名字+icon**\n<!-- endtab -->\n{% endtabs %}\n\n```\n\n## label标签\n\n高亮文字\n\n```\n{% label text color %}\n```\n\n| 参数  | 解释                                                         |\n| ----- | ------------------------------------------------------------ |\n| text  | 待高亮的文字                                                 |\n| color | 【可選】背景顏色，默認為 default  default/blue/pink/red/purple/orange/green |\n\n\n\n## timeline标签\n\n```\n{% timeline 2022,blue %}\n<!-- timeline 01-02 -->\n這是測試頁面\n<!-- endtimeline -->\n{% endtimeline %}\n```\n\n## Mermaid标签\n\n```\n{% mermaid %}\n內容\n{% endmermaid %}\n```\n\n## 记录算法题解和思路的tabs 标签\n\n```\n{% tabs 思路&&题解 %}\n<!-- tab 思路-->\n**This is Tab 1.**\n<!-- endtab -->\n\n<!-- tab 题解-->\n**This is Tab 2.**\n<!-- endtab -->\n{% endtabs %}\n\n\n```\n\n","slug":"hexo-外挂标签模板-速查","published":1,"updated":"2023-04-23T03:01:27.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwm70009bsuob1tw64g7","content":"<p><a href=\"https://butterfly.js.org/posts/4aa8abbe/\">https://butterfly.js.org/posts/4aa8abbe/</a></p>\n<h1 id=\"hexo-butterfly-主题的外挂标签-速查\"><a href=\"#hexo-butterfly-主题的外挂标签-速查\" class=\"headerlink\" title=\"hexo butterfly 主题的外挂标签 速查\"></a>hexo butterfly 主题的外挂标签 速查</h1><h2 id=\"Note-标签\"><a href=\"#Note-标签\" class=\"headerlink\" title=\"Note 标签\"></a>Note 标签</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% note [color] [icon] [style] %&#125;</span><br><span class=\"line\">Any content (support inline tags too.io).</span><br><span class=\"line\">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>color</td>\n<td>【可選】顔色(default / blue / pink / red / purple / orange / green)</td>\n</tr>\n<tr>\n<td>icon</td>\n<td>【可選】可配置自定義 icon (只支持 fontawesome 圖標, 也可以配置 no-icon )</td>\n</tr>\n<tr>\n<td>style</td>\n<td>【可選】可以覆蓋配置中的 style（simple/modern/flat/disabled）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"tag-hide标签\"><a href=\"#tag-hide标签\" class=\"headerlink\" title=\"tag-hide标签\"></a>tag-hide标签</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% hideToggle display,bg,color %&#125;</span><br><span class=\"line\">content</span><br><span class=\"line\">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tabs-标签\"><a href=\"#Tabs-标签\" class=\"headerlink\" title=\"Tabs 标签\"></a>Tabs 标签</h2><p>横向可选择的框栏</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% tabs test1 %&#125;</span><br><span class=\"line\">&lt;!-- tab --&gt;</span><br><span class=\"line\"><span class=\"strong\">**This is Tab 1.**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab --&gt;</span><br><span class=\"line\"><span class=\"strong\">**This is Tab 2.**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab --&gt;</span><br><span class=\"line\"><span class=\"strong\">**This is Tab 3.**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% tabs test4 %&#125;</span><br><span class=\"line\">&lt;!-- tab 第一個Tab --&gt;</span><br><span class=\"line\"><span class=\"strong\">**tab名字為第一個Tab**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class=\"line\"><span class=\"strong\">**只有圖標 沒有Tab名字**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab 炸彈@fas fa-bomb --&gt;</span><br><span class=\"line\"><span class=\"strong\">**名字+icon**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\">&#123;% endtabs %&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"label标签\"><a href=\"#label标签\" class=\"headerlink\" title=\"label标签\"></a>label标签</h2><p>高亮文字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text</td>\n<td>待高亮的文字</td>\n</tr>\n<tr>\n<td>color</td>\n<td>【可選】背景顏色，默認為 default  default/blue/pink/red/purple/orange/green</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"timeline标签\"><a href=\"#timeline标签\" class=\"headerlink\" title=\"timeline标签\"></a>timeline标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% timeline 2022,blue %&#125;</span><br><span class=\"line\">&lt;!-- timeline 01-02 --&gt;</span><br><span class=\"line\">這是測試頁面</span><br><span class=\"line\">&lt;!-- endtimeline --&gt;</span><br><span class=\"line\">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Mermaid标签\"><a href=\"#Mermaid标签\" class=\"headerlink\" title=\"Mermaid标签\"></a>Mermaid标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% mermaid %&#125;</span><br><span class=\"line\">內容</span><br><span class=\"line\">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"记录算法题解和思路的tabs-标签\"><a href=\"#记录算法题解和思路的tabs-标签\" class=\"headerlink\" title=\"记录算法题解和思路的tabs 标签\"></a>记录算法题解和思路的tabs 标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% tabs 思路&amp;&amp;题解 %&#125;</span><br><span class=\"line\">&lt;!-- tab 思路--&gt;</span><br><span class=\"line\">**This is Tab 1.**</span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab 题解--&gt;</span><br><span class=\"line\">**This is Tab 2.**</span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\">&#123;% endtabs %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<p><a href=\"https://butterfly.js.org/posts/4aa8abbe/\">https://butterfly.js.org/posts/4aa8abbe/</a></p>\n<h1 id=\"hexo-butterfly-主题的外挂标签-速查\"><a href=\"#hexo-butterfly-主题的外挂标签-速查\" class=\"headerlink\" title=\"hexo butterfly 主题的外挂标签 速查\"></a>hexo butterfly 主题的外挂标签 速查</h1><h2 id=\"Note-标签\"><a href=\"#Note-标签\" class=\"headerlink\" title=\"Note 标签\"></a>Note 标签</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% note [color] [icon] [style] %&#125;</span><br><span class=\"line\">Any content (support inline tags too.io).</span><br><span class=\"line\">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>color</td>\n<td>【可選】顔色(default / blue / pink / red / purple / orange / green)</td>\n</tr>\n<tr>\n<td>icon</td>\n<td>【可選】可配置自定義 icon (只支持 fontawesome 圖標, 也可以配置 no-icon )</td>\n</tr>\n<tr>\n<td>style</td>\n<td>【可選】可以覆蓋配置中的 style（simple/modern/flat/disabled）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"tag-hide标签\"><a href=\"#tag-hide标签\" class=\"headerlink\" title=\"tag-hide标签\"></a>tag-hide标签</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% hideToggle display,bg,color %&#125;</span><br><span class=\"line\">content</span><br><span class=\"line\">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tabs-标签\"><a href=\"#Tabs-标签\" class=\"headerlink\" title=\"Tabs 标签\"></a>Tabs 标签</h2><p>横向可选择的框栏</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% tabs test1 %&#125;</span><br><span class=\"line\">&lt;!-- tab --&gt;</span><br><span class=\"line\"><span class=\"strong\">**This is Tab 1.**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab --&gt;</span><br><span class=\"line\"><span class=\"strong\">**This is Tab 2.**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab --&gt;</span><br><span class=\"line\"><span class=\"strong\">**This is Tab 3.**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% tabs test4 %&#125;</span><br><span class=\"line\">&lt;!-- tab 第一個Tab --&gt;</span><br><span class=\"line\"><span class=\"strong\">**tab名字為第一個Tab**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class=\"line\"><span class=\"strong\">**只有圖標 沒有Tab名字**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab 炸彈@fas fa-bomb --&gt;</span><br><span class=\"line\"><span class=\"strong\">**名字+icon**</span></span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\">&#123;% endtabs %&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"label标签\"><a href=\"#label标签\" class=\"headerlink\" title=\"label标签\"></a>label标签</h2><p>高亮文字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text</td>\n<td>待高亮的文字</td>\n</tr>\n<tr>\n<td>color</td>\n<td>【可選】背景顏色，默認為 default  default/blue/pink/red/purple/orange/green</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"timeline标签\"><a href=\"#timeline标签\" class=\"headerlink\" title=\"timeline标签\"></a>timeline标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% timeline 2022,blue %&#125;</span><br><span class=\"line\">&lt;!-- timeline 01-02 --&gt;</span><br><span class=\"line\">這是測試頁面</span><br><span class=\"line\">&lt;!-- endtimeline --&gt;</span><br><span class=\"line\">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Mermaid标签\"><a href=\"#Mermaid标签\" class=\"headerlink\" title=\"Mermaid标签\"></a>Mermaid标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% mermaid %&#125;</span><br><span class=\"line\">內容</span><br><span class=\"line\">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"记录算法题解和思路的tabs-标签\"><a href=\"#记录算法题解和思路的tabs-标签\" class=\"headerlink\" title=\"记录算法题解和思路的tabs 标签\"></a>记录算法题解和思路的tabs 标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% tabs 思路&amp;&amp;题解 %&#125;</span><br><span class=\"line\">&lt;!-- tab 思路--&gt;</span><br><span class=\"line\">**This is Tab 1.**</span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- tab 题解--&gt;</span><br><span class=\"line\">**This is Tab 2.**</span><br><span class=\"line\">&lt;!-- endtab --&gt;</span><br><span class=\"line\">&#123;% endtabs %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"totitle":"PAT甲级学习记录","copyright_author":"NinoNeumann","date":"2023-03-24T08:26:08.000Z","updated":"2023-03-24T08:26:08.000Z","mathjax":true,"keywords":"算法","description":"to record my learning on algorithm","cover":"https://my-blog-pics-repo.oss-cn-shanghai.aliyuncs.com/Cover_img/100412772_p0.png","_content":"\n\n\n{% timeline 2023,blue %}\n<!-- timeline 03-29 -->\nPAT甲级 进位制\n<!-- endtimeline -->\n\n<!-- timeline 03-30 -->\nPAT甲级 排序\n<!-- endtimeline -->\n\n<!-- timeline 03-31 -->\nPAT甲级 排序\n\n- stringstream 类的一些操作\n- 如何自定义stl在sort中的排序规则\n\n<!-- endtimeline -->\n\n<!-- timeline 04-01 -->\nPAT甲级 排序\n\nPAT甲级 的一些模拟题目\n\n- long long 数据类型的大小判断。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-01 -->\nPAT甲级 DFS\n\nacwing上的一些冠以dfs的题解。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-05 -->\nPAT甲级 最短路算法复习\n\n- 单源最短路\n  - 存在负权边\n    - spfa\n    - bellman-ford算法\n  - 不存在负权边\n    - dijkstra\n    - 堆优化版本的dijkstra\n- 多源最短路\n  - floyd算法\n\n<!-- endtimeline -->\n\n<!-- timeline 04-05 -->\n\n- 二分查找找左右边界问题。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-18 -->\n\n- [x] 1497. 树的遍历\n\n<!-- endtimeline -->\n\n<!-- timeline 04-18 -->\n\n- [x] 1498. 最深的根\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n[toc]\n\n# PAT-recording\n\n\n\n- [x] 进位制\n- [ ] 排序\n\n\n\n## 进位制\n\n### 1482 进制\n\n分析：\n\n两个数，其中的一个进制是给定的,并且这个数的进制不超过36。\n\n但是另外一个数的进制就不好说了，可能是一个很大的数字。（重点）枚举的区间就是1~target  ：target=给定的数最大能表示的范围也就是$$36^{10}-1$$ 。\n\n显然，不能通过枚举的方法找，使用二分是一个不错的选择。\n\n{% tabs test4 %}\n<!-- tab 第一种方法（繁琐） -->\n\n枚举另一个数 将其转化为枚举的进制数字 或者都转化为10进制数字。\n\n需要一个 \n\n```c++\nstring fuc(string a, int in,int out);\n```\n\n 这样的函数将a转化为out 进制数\n\n这个方法实在是太繁琐了，（这个函数我不会写）\n\n<!-- endtab -->\n\n<!-- tab 第二种方法 -->\n\n计算一下两个数如果转化为十进制数 int 或者long long 能否能存下\n\nN是不超过十位的数字 最大就是 十个z  =  $$36^{10}-1$$  可以使用 计算机自带的计算器计算这个数看看是否溢出。（不溢出）\n\n那么就可以找这样的函数\n\n```c++\nlong long fuc(string a,int out);\n```\n\n主要思路就是：二分。\n\n```c++\n// 二分模板\nint main(){\n    int l = floor,r = ceil;\n    while(l<r){\n        int mid = (l+r)>>1;\n        if(check()) r = mid;\n        else l = mid+1;\n    }\n    // 第二个模板   注意左右边界的跳转的条件\n    while(l<r){\n        int mid = (l+r+1)>>1;\n        if(check()) l = mid;  \n        else r = mid-1;\n    }\n    \n}\n```\n\n\n\n```c++\n//\n// Created by Nino Neumann on 2023/3/29.\n//\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 1e16;\n\nint get(char c){\n    if(c<='9') return c-'0';\n    else return c-'a'+10;\n}\n\n\nLL convert(string a,LL radix){\n    LL res = 0;\n    LL c = 1;\n    for(int i = a.length()-1;i>=0;--i){\n        // if((double)res + (get(a[i])*c) > 1e16) return 1e18;\n        // cout<<(double)res + (get(a[i])*c)<<\"  \";\n        res += (get(a[i])*c);\n        c *= radix;\n        // cout<<\"  \"<<res<<endl;\n        if(res>1e16) return 1e16;\n        if(res<0)return 1e16;\n        \n    }\n    // cout<<res<<endl;\n    return res;\n}\n\nint main(){\n    string a,b;\n    int tag,radix;\n    cin>>a>>b>>tag>>radix;\n    if(tag==2) swap(a,b);\n    LL a_n = convert(a,radix);\n    // cout<<\"a_: \"<<a_n<<endl;\n    \n    // 二分的模板\n    LL l = 1,r = a_n+1;\n    \n    for (auto c : b) l = max(l, (LL)get(c) + 1);\n    while(l<r){\n        LL mid = (l+r)>>1;\n        if(convert(b,mid)>=a_n) r = mid;\n        else l = mid+1;\n    }\n    if(convert(b,r)==a_n) cout<<r<<endl;\n    else cout<<\"Impossible\\n\";\n    // cout<<convert(b,r)<<endl;\n    return 0;\n}\n```\n\n\n\n- 上下界的选择：\n\n上下界必须要根据当前这个数来确定进制上下界搜索的范围。\n\n- 做进制转换的时候数据可能会溢出，所以要加以判断，由于确定数最大就是$$36^{10}-1$$ 所以如果当前这一步计算的结果大于这个数就可以直接return一个很大的但是不溢出的数字。\n- 由于进制计算的步骤问题，有可能当前判断的时候溢出已经发生所以判断当前计算结果是否小于0 如果是则返回一个很大的数。\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n### 1492 可逆质数\n\n简单题，用到的模板就是质数判断\n\n### 1504 火星颜色\n\n简单题 不记录了\n\n值得记录的知识点：stringstream类的一些操作\n\n#### StringStream\n\n包含的头文件： sstream.h\n\n- 可以做普通的字符串输入输出的中转站\n\n```c++\n// 初始化一个sstream对象\nstringstream ssin;\nstring a;\nstring b;\nssin<<a; // 将a放入b中\ncout<<ssin.str()<<endl;// 输出存放在ssin中的所有字符串\nssin>>b; // 将刚才的放入的a放到b中\n```\n\n- 实现类型的转换\n\n```c++\nint d;\nstring ds;\nstringstream ssin;\nssin<<d;  // 将int输入ssin\nssin>>ds; // 将输入的int输出到ds中这中间会调用数据类型转换。\n\n```\n\n- 实现对于string字符串的空格切割\n\n```c++\nstring str;\ngetline(cin,str);\nstringstream ssin(str);\nstring word;\nwhile(ssin>>word){\n   operation)();\n}\n```\n\n\n\n### 1590 火星数字\n\nstringstream ssin（）\n\n输入输出\n\n## 排序\n\n### 1484 最佳排名\n\n数据结构：\n\n一个结构体、重载<运算符。规则 有四列成绩，每个学生只有其最好的排名。\n\n数据范围：\n\n学生和查询次数在2000以内 每科成绩100以内的正数\n\n思路：\n\n每次查询的时候对每个学生排序 输出所有排序中成绩最好的。时间复杂度不超。\n\n不清楚的点：\n\n排名怎么算？如果有同分数的人怎么算排名？按照分数排名还是按照别的规则。同分数名次一致。\n\n如何解决：\n\n将所有分数排序，然后按照每个同学的分数 直接去查这个排名表，查到的最考前的数的下标就是其排名。\n\n\n\n### 1499 数字图书馆\n\n要求：\n\n五个关键字段：书名、作者（唯一）、出版商、关键词（不超过五个空格分开。）、日期.\n\nid是可能有前导0的。\n\n思路：\n\n五个map<string,vector<string\\> >分别存放书名、出版商、关键词、日期 、作者与相关id的对应查询字典。最后输出查询的时候只要更具hash表找到对应的vector然后对其排名就可以了\n\n### 1502 PAT 排名\n\n思路：\n\n对每个地区的学生信息输入完成后生成一个地区排名表，将输入完成的学生的地区排名信息输入。\n\n所有的地区的学生信息输入完成后生成一个。\n\n```C++\n//\n// Created by Nino Neumann on 2023/3/31.\n//\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nstruct info{\n    string id;\n    int grade;\n    int final_rank,location_number,local_rank;\n    bool operator<(const info &a) const{\n        if(final_rank==a.final_rank) return id<a.id;\n        return final_rank<a.final_rank;\n    }\n};\n\n\nvector<int> total_grade_list;\nvector<info> total_students_list;\n\n\nint get_rank(int grade,vector<int> gl){\n    int l = 0,r = gl.size()-1;\n    while(l<r){\n        int mid = (l+r+1)>>1;\n        if(gl[mid]<=grade) l = mid;\n        else r = mid-1;\n    }\n    return gl.size()-l;\n}\n\nbool cmp(int &a,int &b){\n    return a>b;\n}\nint main(){\n    int n;\n    cin>>n;\n    for(int i = 1;i<=n;++i){\n        int k;\n        cin>>k;\n        vector<pair<string,int>> local_info;\n        vector<int> local_grade_list;\n        while(k--){\n            string id;\n            int grade;\n            cin>>id>>grade;\n            local_grade_list.push_back(grade);\n            local_info.push_back({id,grade});\n            total_grade_list.push_back(grade);\n        }\n\n        sort(local_grade_list.begin(),local_grade_list.end(),cmp);\n        // cout<<i<<\" \"<<\"local_grade_list 0 \"<<local_grade_list[0];\n\n        for(auto p:local_info){\n            string id = p.first;\n            int g = p.second;\n            int rank = get_rank(g,local_grade_list);\n            total_students_list.push_back({id,g,-1,i,rank});\n        }\n    }\n\n    sort(total_grade_list.begin(),total_grade_list.end(),cmp);\n    \n    for(int i = 0;i<total_students_list.size();++i){\n        info *p = &total_students_list[i];\n        int g = p->grade;\n        p->final_rank = get_rank(g,total_grade_list);\n    }\n    sort(total_students_list.begin(),total_students_list.end());\n    // cout<<total_students_list[0].grade<<endl;\n    cout<<total_students_list.size()<<endl;\n    for(auto stu:total_students_list){\n        cout<<stu.id<<\" \"<<stu.final_rank+1<<\" \"<<stu.location_number<<\" \"<<stu.local_rank+1<<endl;\n    }\n    return 0;\n}\n```\n\n毫不意外的超时了捏。\n\n应该是get_rank导致三重循环所以超时了吧。\n\n\n\n### 1505列表排序\n\n很简单的一道排序题，但是很容易超时，就想着这样。\n\n```C++\n//\n// Created by Nino Neumann on 2023/3/31.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct student{\n    string id,name;\n    int score;\n};\n\nbool cmp1(student &a,student &b) {\n    return a.id<b.id;\n}\nbool cmp2(student &a,student &b) {\n    return a.name==b.name ? a.id<b.id : a.name>=b.name;\n}\nbool cmp3(student &a,student &b) {\n    return a.score==b.score ? a.id<b.id : a.score>=b.score;\n}\n\nvector<student> students;\n\nint main(){\n    int n,c;\n    cin>>n>>c;\n    while(n--){\n        string id,name;\n        int grade;\n        cin>>id>>name>>grade;\n        students.push_back({id,name,grade});\n    }\n\n    if(c==1){\n        sort(students.begin(),students.end(),cmp1);\n    }else if (c==2){\n        sort(students.begin(),students.end(),cmp2);\n    }else{\n        sort(students.begin(),students.end(), cmp3);\n    }\n    for(auto s:students){\n        cout<<s.id<<\" \"<<s.name<<\" \"<<s.score<<endl;\n    }\n\n\n\n    return 0;\n}\n```\n\n试着用堆排序实现\n\n```C++\n//\n// Created by Nino Neumann on 2023/3/31.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nstruct student{\n    string id,name;\n    int score;\n};\n\nint c;\n\nbool operator>(const student a,const student b) {\n    if(c==1)\n        return a.id>b.id;\n    else if(c==2)\n        return a.name==b.name ? a.id>b.id : a.name>=b.name;\n    else\n        return a.score==b.score ? a.id>b.id : a.score>=b.score;\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d%d\",&n,&c);\n    priority_queue<student , vector<student> , greater<student> > heap;\n    while(n--){\n        string id,name;\n        id.resize(6);\n        name.resize(8);\n        \n        int grade;\n        scanf(\"%s%s%d\",&id[0],&name[0],&grade);\n        // scanf(\"%s\",&name[0]);\n        // scanf(\"%d\",&grade);\n        // cout<<id<<endl;\n        // students.push_back({id,name,grade});\n        heap.push({id,name,grade});\n    }\n\n    while(!heap.empty()){\n        auto s = heap.top();\n        heap.pop();\n        // cout<<s.id<<\" \"<<s.name<<\" \"<<s.score<<endl;\n        printf(\"%s %s %d\\n\",s.id.c_str(),s.name.c_str(),s.score);\n    }\n\n\n\n    return 0;\n}\n```\n\n依旧超时，因为在一个n循环中使用了堆排序所以时间复杂度是$$n^2log{n}$$ 所以会超时。\n\n这里应该着重优化输入输出。\n\n```C++\n//\n// Created by Nino Neumann on 2023/3/31.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\nconst int N = 1e5+1;\nstruct student{\n    string id,name;\n    int score;\n};\nstudent students[N];\n\nbool cmp1(student &a,student &b) {\n    return a.id<b.id;\n}\nbool cmp2(student &a,student &b) {\n    return a.name==b.name ? a.id<b.id : a.name<=b.name;\n}\nbool cmp3(student &a,student &b) {\n    return a.score==b.score ? a.id<b.id : a.score<=b.score;\n}\n\n// vector<student> students;\n\nint main(){\n    int n,c;\n    scanf(\"%d%d\",&n,&c);\n    // while(n--){\n    //     string id,name,line;\n    //     int grade;\n    //     cin>>id>>name>>grade;\n    //     students.push_back({id,name,grade});\n    // }\n    for(int i = 0;i<n;++i){\n        string name,id;\n        int grade;\n        name.resize(8);\n        id.resize(6);\n        scanf(\"%s%s%d\",&id[0],&name[0],&grade);\n        students[i].id = id;\n        students[i].name = name;\n        students[i].score = grade;\n    }\n        \n    \n\n    if(c==1){\n        sort(students,students+n,cmp1);\n    }else if (c==2){\n        sort(students,students+n,cmp2);\n    }else{\n        sort(students,students+n, cmp3);\n    }\n    for(int i = 0;i<n;++i){\n        auto s = students[i];\n        printf(\"%s %s %d\\n\",s.id.c_str(),s.name.c_str(),s.score);\n    }\n\n\n    return 0;\n}\n```\n\n\n\n### 1523 学生课程列表\n\n思路：\n\n使用哈希表 map查询 将每个学生的name为索引 跟上其选课的列表 vector<int> \n\n时间复杂度分析：\n\nhash表的插入查询：都是$$O(1)$$ 的时间复杂度\n\n输入时间复杂度：最多输入2500（课程最大数量）multi 200 （单个课程最多容纳人数）== 450000  输入\n\n查询操作时间复杂度：查询400000个人 最多不会超过450000（假设存在学生选了所有的课，但是这样的学僧最多不超过200个人，如果这个情况成立，那么也就是450000次）\n\n```c++\n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nmap<string,vector<int>> students;\n\n\nint n,k;\n\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    while(k--){\n        int c_id,member_num;\n        scanf(\"%d%d\",&c_id,&member_num);\n        while(member_num--){\n            string s;\n            s.resize(4);\n            scanf(\"%s\",&s[0]);\n            students[s].push_back(c_id);\n        }\n    }\n    //query\n    while(n--){\n        string s;\n        s.resize(4);\n        scanf(\"%s\",&s[0]);\n        printf(\"%s \",s.c_str());\n        if(students.find(s)!=students.end()){\n            sort(students[s].begin(),students[s].end());\n            printf(\"%d \",students[s].size());\n            \n            for(auto c:students[s])\n                printf(\"%d \",c);\n        }else{\n            printf(\"0\");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n应为在最后的查询里面会有一部排序的操作，所以挺怕他超时的，但是最后也没超时。\n\n### 1538 链表排序\n\n思路：\n\n创建一个map 将所有的元素输入进去，按照链表遍历将在链表中的元素加入vector里面 然后排序，最后输出。\n\n{% tabs 链表排序 %}\n<!-- tab TLE 使用了map-->\n\n\n\n ```C++\n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#define _CRT_SECURE_NO_WARNINGS \n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\n\nstruct node {\n    string addr;\n    int key;\n    string addr_next;\n    bool operator<(const node& a) const {\n        return key < a.key;\n    }\n};\n\nmap<string, node> hash_table;\nvector<node> nodes;\n\n// 输入 删除 排序 输出\n\nint main() {\n    string ad;\n    int n;\n    cin >> n >> ad;\n    while (n--) {\n        string s;\n        string o;\n        int key;\n        cin >> s >> key >> o;\n        hash_table[s] = { s,key,o };\n    }\n\n    while (ad != \"-1\") {\n        auto top_node = hash_table[ad];\n        nodes.push_back(top_node);\n        ad = top_node.addr_next;\n    }\n    sort(nodes.begin(),nodes.end());\n    \n    cout<<nodes.size()<<\" \";\n    if(nodes.size())\n        cout<<nodes[0].addr<<endl;\n    else{\n        cout<<\"-1\\n\";\n        return 0;\n    }\n    for (int i = 0;i<nodes.size();++i) {\n        auto n = nodes[i];\n        \n        if(i!=nodes.size()-1){\n            auto next = nodes[i+1];\n            printf(\"%s %d %s\\n\", n.addr.c_str(), n.key, next.addr.c_str());\n        }\n        else{\n            printf(\"%s %d -1\\n\", n.addr.c_str(), n.key);\n        }\n    }\n            \n\n\n\n    return 0;\n}\n ```\n\nTLE了。感觉又是cin的事情。\n\n<!-- endtab -->\n\n<!-- tab 使用unordered_map不超时 -->\n\n```C++\n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#define _CRT_SECURE_NO_WARNINGS \n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<unordered_map>\nusing namespace std;\n\nstruct node {\n    string addr;\n    int key;\n    string addr_next;\n    bool operator<(const node& a) const {\n        return key < a.key;\n    }\n};\n\nunordered_map<string, node> hash_table;\nvector<node> nodes;\n\n// 输入 删除 排序 输出\n\nint main() {\n    char c1[10];\n    char c2[10];\n    char c3[10];\n    \n    int n,key;\n    scanf(\"%d%s\",&n,c1);\n    string ad(c1);\n    while (n--) {\n        scanf(\"%s%d%s\",c2,&key,c3);\n        string s(c2),o(c3);\n        // cin >> s >> key >> o;\n        hash_table[s] = { s,key,o };\n    }\n\n    // while (ad != \"-1\") {\n    //     auto top_node = hash_table[ad];\n    //     nodes.push_back(top_node);\n    //     ad = top_node.addr_next;\n    // }\n    for(string head = ad;head!=\"-1\";head = hash_table[head].addr_next){\n        nodes.push_back(hash_table[head]);\n    }\n    sort(nodes.begin(),nodes.end());\n\n    printf(\"%d \",nodes.size());\n    if(nodes.size())\n        printf(\"%s\\n\",nodes[0].addr.c_str());\n    else{\n        printf(\"-1\\n\");\n        return 0;\n    }\n    for (int i = 0;i<nodes.size();++i) {\n        auto n = nodes[i];\n        \n        if(i!=nodes.size()-1){\n            auto next = nodes[i+1];\n            printf(\"%s %d %s\\n\", n.addr.c_str(), n.key, next.addr.c_str());\n        }\n        else{\n            printf(\"%s %d -1\\n\", n.addr.c_str(), n.key);\n        }\n    }\n            \n\n\n\n    return 0;\n}\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n能用scanf就用scanf，能用unordered_map就不用map。\n\n### 1561 PAT 评测\n\n思路：\n\n## 树\n\n### 树的遍历（重点最好记一下）\n\n- 给出的所有的点最多能到1百万个\n- 复杂度为$$O(n)$$\n- 给定的所有点的权值都是唯一的，如果不唯一那么树的形状可能不唯一。\n\n给定后序和中序遍历 输出层序遍历\n\n1、需要熟悉手动的中序+后续 构建树的过程、以及中序+前序构建树的过程。（在此基础上需要要知道如何快速找到中序遍历中的root下标）\n\n2、要知道本题中树是如何存储的。二叉树的存储可以简化到使用两个unordered_map 存储\n\n````C++\n#include<iostream>\n#include<queue>\n#include<unordered_map>\nusing namespace std;\n\nconst int N = 40;\n\nint postordered[N],inordered[N];\n\nunordered_map<int, int> l,r,ipost;\n\nint n;\n\nint build(int pl,int pr,int il,int ir){\n    int root  = postordered[pr];\n    int k = ipost[root];\n    if(il<k){\n        l[root] = build(pl,pl+k-1-il,il,k-1);\n    }\n    if(ir>k){\n        r[root] = build(pl+k-1-il+1,pr-1,k+1,ir);\n    }\n    return root;\n}\n\nvoid bfs(int root){\n    queue<int> q;\n    q.push(root);\n    while(!q.empty()){\n        auto t = q.front();\n        q.pop();\n        cout<<t<<\" \";\n        if(l.count(t)) q.push(l[t]);\n        if(r.count(t)) q.push(r[t]);\n    }\n}\n\nint main(){\n    cin>>n;\n    for(int i = 0;i<n;i++){\n        cin>>postordered[i];\n    }\n    \n    for(int i = 0;i<n;i++){\n        cin>>inordered[i];\n        ipost[inordered[i]] = i;\n    }\n    \n    int root = build(0,n-1,0,n-1);\n    bfs(root);\n    \n    \n    \n    return 0;\n}\n````\n\n\n\n### 1498 最深的根\n\n思路：使用并查集求解给定的树是否符合要求，以及不符合要求的话有多少个连通块。（这一步主要是对merge的过程进行修改。）\n\n```C++\n//\n// Created by Nino Neumann on 2023/4/19.\n//\n// 判断给出的树是不是一个连通的，如果不是求出连通分量-- 并查集\n// 求最深的根：对每个点进行遍历 dfs  存储图用的邻接表需要使用简易的邻接表否则会超时。\n#include \"iostream\"\n#include \"vector\"\n#include<cstring>\nusing namespace std;\n\nconst int N=1e4+10,M=N*2;  //\nint h[N],e[M],ne[M],idx; //邻接表存稀疏树图\n\nint n,k; // 一共有多少个节点\n\n// 定义并查集以及相关操作\nint p[N];\n\nint find(int a){\n    if(p[a]!=a) p[a] = find(p[a]);\n    return p[a];\n}\n\nvoid add(int a,int b)\n{\n    e[idx]=b;\n    ne[idx]=h[a];\n    h[a]=idx++;\n}\n\nvoid merge(int a,int b){\n    int fa = find(a),fb = find(b);\n    p[fa] = fb;\n}\n// 定义存储树的结构\n\n// struct head{\n//     vector<int> e;\n// };\n// head heads[N];\n\n// dfs\nint dfs(int u,int father){\n    // 计算当前根的最大深度\n    int depth = 0;\n    // if(heads[root].e.empty()){   // 搜索到叶子节点了；\n    //     return depth;\n    // }\n    for(int i=h[u];~i;i=ne[i])\n    {\n        int j=e[i];\n        if(j==father) continue; //重复搜了\n        depth=max(depth,dfs(j,u)+1);\n    }\n\n    // for(auto x:heads[root].e){\n    //     if(x==father)continue;\n    //     depth = max(depth,dfs(x,root)+1);\n    // }\n    return depth;\n}\n\n\n\n\nint main(){\n\n    scanf(\"%d\",&n);\n    k=n;\n    for(int i = 0;i<=n;++i) p[i] = i;\n    memset(h,-1,sizeof h); //初始化邻接表\n    for(int i = 0;i<n-1;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        int fx = find(x),fy = find(y);\n        if(fx!=fy){\n            p[fx] = fy;\n            k--;\n        }\n        add(x,y);add(y,x); //无向边加两次\n        // heads[x].e.push_back(y);\n        // heads[y].e.push_back(x);\n    }\n    if(k>1) printf(\"Error: %d components\\n\",k);\n    else\n    {\n        vector<int>nodes;\n        int max_depth=-1; //设置相反界外量\n        for(int i=1;i<=n;i++)\n        {\n            int depth=dfs(i,-1);  //这个节点无来源点 得到这个点的深度\n            if(depth>max_depth)\n            {\n                max_depth=depth; //更新\n                nodes.clear(); //清空\n                nodes.push_back(i);\n            }\n            else if(depth==max_depth) nodes.push_back(i);\n        }\n        for(auto v:nodes) cout<<v<<endl;\n\n    }\n\n\n    return 0;\n}\n```\n\n\n\n### 判断二叉搜索树\n\n问题一：如何根据二叉搜索树的先序遍历恢复树结构？\n\n二叉搜索树的中序遍历其实是已知的。这个问题其实就是根据二叉搜索树的中序和前序遍历得到二叉树。\n\n问题二：将问题转换为 上述的树的遍历后，中序遍历中节点值不唯一如何解决？\n\n由于中序遍历是一个有序数列，所以可以使用二分的方法去查找到当前前序遍历中的根节点在中序遍历中的位置\n\n问题三：如何判断不合法的情况？\n\n如果当前在中序区间中找根节点的过程中没有找到那么就返回false；\n\n```c++\n//\n// Created by Nino Neumann on 2023/4/19.\n//\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n\n\nconst int N = 1e3+10;\nint preorder[N],postorder[N],inorder[N];\nint cnt;\nint n;\n\n\nbool build(int il,int ir,int pl,int pr,int type){\n    bool res = true;\n    int root = preorder[pl];\n    int k = -1;\n    if(il>ir) return res; //  正常结束了\n    if(type==0){\n        // 二分查找左边界 升序数组中\n        // for (k = il; k <= ir; k ++ )\n        //     if (inorder[k] == root)\n        //         break;\n        // if (k > ir) return false;\n        int l = il,r = ir;\n        while(l<r){\n            int mid = (r+l)>>1;\n            if(inorder[mid]>=root)r = mid;\n            else l = mid+1;\n        }\n        if(inorder[l]==root) k = l;\n        else return false;\n    }else{\n        // 二分查找右边界 降序数组中\n        // for (k = ir; k >= il; k -- )\n        //     if (inorder[k] == root)\n        //         break;\n        // if (k < il) return false;\n        int l = il,r = ir;\n        while(l<r){\n            int mid = (r+l+1)>>1;\n            if(inorder[mid]>=root) l = mid;\n            else r = mid-1;\n        }\n        if(inorder[l]==root) k = l;\n        else return false;\n    }\n\n    if(!build(il,k-1,pl+1,pl+1+(k-1-il),type)) res = false;\n    if(!build(k+1,ir,pl+1+(k-1-il)+1,pr,type)) res = false;\n    postorder[cnt++] = root;\n    return res;\n\n\n\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 0;i<n;++i){\n        scanf(\"%d\",&preorder[i]);\n        inorder[i] = preorder[i];\n    }\n    sort(inorder,inorder+n);\n    if(build(0,n-1,0,n-1,0)){\n        // 这个树不是镜像并且存在  输出YES 和postorder序列\n        printf(\"YES\\n%d\",postorder[0]);\n        for(int i = 1;i<n;++i) printf(\" %d\",postorder[i]);\n    } else{\n        reverse(inorder,inorder+n);\n        cnt = 0; // 一定要注意cnt的重置\n        if(build(0,n-1,0,n-1,1)){\n            printf(\"YES\\n%d\",postorder[0]);\n            for(int i = 1;i<n;++i) printf(\" %d\",postorder[i]);\n        }else{\n            printf(\"NO\\n\");\n        }\n    }\n\n\n    return 0;\n}\n\n```\n\n\n\n### 1550 完全二叉搜索树\n\n对于我来说的难点：\n\n给定了每个节点的权值如何取构建一个完全二叉搜索树；\n\n如何使用数组存储树结构。\n\n-  从下标为0开始存储：\n- 从下标为一开始存储。\n\n{% tabs 1550 完全二叉搜索树 %}\n<!-- tab 思路-->\n\n通过完全二叉树的性质，可以定义二叉树的dfs边界，通过中序遍历将二叉树构建出来，并存储到一个数组中，再通过层序遍历将其输出。\n\n- 首先将节点按照从小到大的顺序排序，\n- 通过中序遍历建树\n- 直接输出存储树的数组就是中序遍历。\n\n<!-- endtab -->\n\n<!-- tab -->\n\n```C++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int N = 1010;\n\nint w[N];\nint tree[N];\nint n,cnt;\n\nvoid pre_order(int u){\n    int r_tree = u<<1;\n    int l_tree = (u<<1)+1;\n    if(r_tree<=n)\n        pre_order(r_tree);\n    tree[u] = w[cnt++];\n    if(l_tree<=n)\n        pre_order(l_tree);\n}\n\n\nint main(){\n    \n    cin>>n;\n    for(int i = 0;i<n;++i)cin>>w[i];\n    sort(w,w+n);\n    pre_order(1);\n    cout<<tree[1];\n    for(int i = 2;i<=n;++i) cout<<\" \"<<tree[i];\n    \n    \n    return 0;\n}\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n### 1576 再次树遍历\n\n这一题和  [3384. 二叉树遍历 - AcWing题 ](https://www.acwing.com/problem/content/description/3387/) 很像\n\n{% tabs 思路&&题解 %}\n<!-- tab 思路-->\n给出的堆栈操作是二叉树的先序遍历，可以使用先序遍历的dfs方法建树。\n\n- 可能涉及到字符串的查找判断。（可以简化，也可以省略）\n\n思路：\n\n- 首先根据先序遍历遍历二叉树，如果遇到pop就是回溯，\n- 然后再先序遍历过程中（由于是一个递归过程所以其中所有的节点都是存储下来的）通过后序的顺序输出每个节点的内容。\n\n一个重要的解题方法就是可以边先序输入边后序输出。\n\n<!-- endtab -->\n\n<!-- tab 题解-->\n\n```C++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nconst int N = 40;\nint n;\n\nvoid preorder(int root){\n    int w;\n    string str;\n    cin>>str;\n    if(str[1]=='u'){\n        // push 操作\n        cin>>w;\n        preorder(root*2);\n        preorder(root*2+1);\n        cout<<w;\n        if(root!=1)cout<<\" \";  //结尾不能有多余的空格。\n    }\n}\n\n\nint main(){\n    cin>>n;\n    preorder(1);\n    return 0;\n}\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n### 1589 构建二叉搜索树\n\n{% tabs 思路&&题解 %}\n<!-- tab 思路-->\n\n搜索树天生就知道其中序遍历。那么这题就是给出了树的结构和中序遍历，输出层序遍历。\n\n接下来就是解决具体问题了：\n\n- 定义存储树的结构\n- 定义inorder遍历的dfs函数\n- 定义层序遍历的bfs函数。\n\n<!-- endtab -->\n\n<!-- tab 题解-->\n\n```C++\n#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 110;\n\nstruct node{\n    int w;\n    int l,r;\n};\nint n;\nnode tree[N];\nint v[N];\nint cnt;\n\nvoid inorder(int root){\n    if(root==-1)return;\n    int l = tree[root].l;\n    int r = tree[root].r;\n    inorder(l);\n    tree[root].w = v[cnt++];\n    inorder(r);\n}\n\nvoid bfs(int root){\n    queue<int> q;\n    q.push(root);\n    while(!q.empty()){\n        auto front = q.front();\n        int l_tree = tree[front].l, r_tree = tree[front].r;\n        q.pop();\n        cout<<tree[front].w<<\" \";\n        if(l_tree>=0) q.push(l_tree);\n        if(r_tree>=0) q.push(r_tree);\n    }\n}\n\n\nint main(){\n    \n    cin>>n;\n    for(int i = 0;i<n;++i)\n        cin>>tree[i].l>>tree[i].r;\n        \n    for(int i = 0;i<n;++i)cin>>v[i];\n    sort(v,v+n);\n    inorder(0);\n    bfs(0);\n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n\n\n\n\n# PAT甲级网站刷题记录\n\n## A1046 前缀和。\n\n## A1065 A+B and C (64bit)\n\n在使用longlong 类型的运算与另一个long long数据类型判断大小的时候（如下的情况）\n\n不能直接使用 (运算) 判断符号 LL这样的格式来判断\n\n{% tabs longlong数据类型判断大小 %}\n<!-- tab 错误做法 -->\n\n```c++\nLL a,b,c,res;\na+b>c;  //这样做是错误的。\n```\n\n<!-- endtab -->\n\n<!-- tab 正确做法 -->\n\n```c++\nLL a,b,c,res;\nres = a+b;\nres>c;  //这样做是对的。\n```\n\n因为不能确定两个longlong数据类型在做加法的时候是否发生了溢出，如果发生溢出机器会自动截断，因而加法运算会在不知道哪一步停止。\n\n<!-- endtab -->\n{% endtabs %}\n\n# DFS\n\ndfs的搜索顺序是一个树形的。\n\nDFS的经典运用：\n\n- 组合数问题\n\n## 输出组合数 acwing \n\n```C++\n#include<iostream>\nusing namespace std;\n\n\nconst int N = 10;\n\nint num[N];\nint res[N];\nbool is_select[N];\nint n;\n\nvoid print_result(){\n    for(int i = 1;i<=n;++i){\n        cout<<res[i]<<\" \";\n    }\n    cout<<endl;\n}\n\n\n\nvoid dfs(int step){\n    // step 表示当前到哪一个位置了。\n    if(step == n+1) {\n        //表示已经到达最后一步了 可以输出了\n        print_result();\n        return;\n    }\n    // 在所有没有被添加进去的数字中选择一个填入\n    for(int i = 1;i<=n;++i){\n        if(!is_select[i]){\n            is_select[i] = true;\n            res[step] = i;\n            dfs(step+1);\n            is_select[i] = false;\n        }\n    }\n}\n\n\nint main(){\n    cin>>n;\n    \n    dfs(1);\n    return 0;\n}\n```\n\n## PAT甲级中的DFS题目\n\n- A1004\n\n\n\n# 一些c++ 的性质的记录（我记不住所以记一下）\n\n## c++在函数声明后面有const\n\n```c++\nbool operator<(const T &a) const {...}\n```\n\n**已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理**\n\n该函数内部不能修改成员变量的值。\n\n## 遇到需要使用效率更高的输入scanf 输入\\printf 输出一行内含有string和in的混合类型。\n\n一种可行的方法是resize string的大小，这种方法使用的前提是你得知道这个待输入的string有多大。然后如下使用\n\n```c++\nint main(){\n\tstring a;\n\tstring b;\n\tint c;\n\ta.resize(10);\n\tb.resize(10);\n\tscanf(\"%s%s%d\",&a[0],&b[0],&c);\n\tprintf(\"a: %s b: %s c: %d\\n\",a.c_str(),b.c_str(),c);\n\n}\n```\n\n输出的时候要转换为c_str()。\n\n## 字符串的比较失效问题\n\n\n\n{% tabs 字符串比较失效 %}\n<!-- tab 最原始的场景-->\n\n```c++\n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#define _CRT_SECURE_NO_WARNINGS \n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\n\nstruct node {\n    string addr;\n    int key;\n    string addr_next;\n    bool operator<(const node& a) const {\n        return key < a.key;\n    }\n};\n\nmap<string, node> hash_table;\nvector<node> nodes;\n\n// 输入 删除 排序 输出\n\nint main() {\n    string ad;\n    ad.resize(7);\n    int n;\n    scanf(\"%d%s\", &n, &ad[0]);\n    // cout<<n<<endl;\n    while (n--) {\n        string s;\n        string o;\n        s.resize(7);\n        o.resize(7);\n        int key;\n        scanf(\"%s%d%s\", &s[0], &key, &o[0]);\n        hash_table[s] = { s,key,o };\n        //        nodes.push_back({s,key,o});\n                // if(o==\"-1\")cout<<\"yes\\n\"<<endl;\n        if (o == \"-1\")cout << \"yes\\n\";\n    }\n    //    if(nodes)\n    // string current_addr = ad;\n    // cout<<(hash_table[\"11111\"].addr_next==\"22222\")<<endl;\n    // 下面的while循环部分失效 导致死循环 string之间的比较失效。\n    while (ad != \"-1\") {\n        auto top_node = hash_table[ad];\n        nodes.push_back(top_node);\n        ad = top_node.addr_next;\n        // cout<<\"-1\"<<endl;\n    }\n    //     sort(nodes.begin(),nodes.end());\n    // //    cout<<nodes.size()<<endl;\n    //     printf(\"%d %s\",nodes.size(),nodes[0].addr.c_str());\n    for (auto n : nodes) {\n        printf(\"%s %d %s\", n.addr.c_str(), n.key, n.addr_next.c_str());\n    }\n\n\n\n    return 0;\n}\n```\n\n<!-- endtab -->\n\n<!-- tab 一开始我以为-->问题出现的场景\n\n最原始的场景：\n\n```c++\nstring ad;\nstring addr_next;\nad.resize(5);\naddr_next.resize(5);\nstring current_addr = ad;\n // 输入的所有字符串的大小都是5，并且里面的有效长度也都是5\nwhile(current_addr!=\"-1\"){\n    auto top_node = hash_table[current_addr];\n    nodes.push_back(top_node);\n    current_addr = top_node.addr_next;\n}\n// 出现死循环，current_addr 不能判断出是否等于“-1”\n```\n\n出现原因：string读入的字符串必须要以\\0结尾，所以在定义string的resize大小的时候一定至少要多定义出一个额外的空间存放'\\0'。\n\n==不是这个原因==。 \n\n<!-- endtab -->\n\n<!-- tab 其实是-->\nsanf 读入字符串的原因，导致比较失效了。不建议使用scanf读入string 类型的数据。\n<!-- endtab -->\n{% endtabs %}\n\n# 关于二分找边界：\n\n\n\n暂时没弄明白，先记着。\n\n{% tabs 二分找边界问题 %}\n\n<!-- tab 基本的二分模板 -->\n\n```c++\nint bs(int q[],int t){\n\tint l = 0,r = n-1;\n\twhile(l<r){\n\t\tint mid = (l+r)>>1;\n\t\tif(q[mid]<t) l = mid;\n\t\telse r = mid+1;\n\t}\n    if(q[l]!=t) return -1;\n\treturn q[l];\n}\n```\n\n<!-- endtab -->\n\n<!-- tab 找有序数组中的某一个数的左边界 -->\n\n```c++\nint bs_left(int nums[],int t){\n    int r = n-1,l = 0;\n    while(l<r){\n        int mid = (l+r)>>1;\n        if(nums[mid]>=t) r = mid;\n        else l = mid+1;\n    }\n    \n    // cout<<\"targ: \"<<t<<\" left:\"<<l<<\" \"<<r<<endl;\n    if(nums[l]==t) return l;\n    return -1;\n}\n```\n\n\n\n<!-- endtab -->\n\n<!-- tab 找有序数组中的某一个数的右边界-->\n\n```c++\nint bs_right(int nums[],int t){\n    int r = n-1,l = 0;\n    while(l<r){\n        int mid = (l+r+1)>>1;\n        if(nums[mid]<=t) l = mid;\n        else r = mid-1;\n    }\n    // cout<<\"targ: \"<<t<<\" right:\"<<l<<\" \"<<r<<endl;\n    if(nums[l]==t) return l;\n    return -1;\n}\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n","source":"_posts/my-pat-learning.md","raw":"---\ntotitle: PAT甲级学习记录\ncopyright_author: NinoNeumann\ndate: 2023-03-24 16:26:08\nupdated: 2023-03-24 16:26:08\nmathjax: true\ntags:\n- algorithm\n- PAT certificate\ncategories: \"Algorithm\"\nkeywords: \"算法\"\ndescription: to record my learning on algorithm\ncover: https://my-blog-pics-repo.oss-cn-shanghai.aliyuncs.com/Cover_img/100412772_p0.png\n---\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 03-29 -->\nPAT甲级 进位制\n<!-- endtimeline -->\n\n<!-- timeline 03-30 -->\nPAT甲级 排序\n<!-- endtimeline -->\n\n<!-- timeline 03-31 -->\nPAT甲级 排序\n\n- stringstream 类的一些操作\n- 如何自定义stl在sort中的排序规则\n\n<!-- endtimeline -->\n\n<!-- timeline 04-01 -->\nPAT甲级 排序\n\nPAT甲级 的一些模拟题目\n\n- long long 数据类型的大小判断。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-01 -->\nPAT甲级 DFS\n\nacwing上的一些冠以dfs的题解。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-05 -->\nPAT甲级 最短路算法复习\n\n- 单源最短路\n  - 存在负权边\n    - spfa\n    - bellman-ford算法\n  - 不存在负权边\n    - dijkstra\n    - 堆优化版本的dijkstra\n- 多源最短路\n  - floyd算法\n\n<!-- endtimeline -->\n\n<!-- timeline 04-05 -->\n\n- 二分查找找左右边界问题。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-18 -->\n\n- [x] 1497. 树的遍历\n\n<!-- endtimeline -->\n\n<!-- timeline 04-18 -->\n\n- [x] 1498. 最深的根\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n[toc]\n\n# PAT-recording\n\n\n\n- [x] 进位制\n- [ ] 排序\n\n\n\n## 进位制\n\n### 1482 进制\n\n分析：\n\n两个数，其中的一个进制是给定的,并且这个数的进制不超过36。\n\n但是另外一个数的进制就不好说了，可能是一个很大的数字。（重点）枚举的区间就是1~target  ：target=给定的数最大能表示的范围也就是$$36^{10}-1$$ 。\n\n显然，不能通过枚举的方法找，使用二分是一个不错的选择。\n\n{% tabs test4 %}\n<!-- tab 第一种方法（繁琐） -->\n\n枚举另一个数 将其转化为枚举的进制数字 或者都转化为10进制数字。\n\n需要一个 \n\n```c++\nstring fuc(string a, int in,int out);\n```\n\n 这样的函数将a转化为out 进制数\n\n这个方法实在是太繁琐了，（这个函数我不会写）\n\n<!-- endtab -->\n\n<!-- tab 第二种方法 -->\n\n计算一下两个数如果转化为十进制数 int 或者long long 能否能存下\n\nN是不超过十位的数字 最大就是 十个z  =  $$36^{10}-1$$  可以使用 计算机自带的计算器计算这个数看看是否溢出。（不溢出）\n\n那么就可以找这样的函数\n\n```c++\nlong long fuc(string a,int out);\n```\n\n主要思路就是：二分。\n\n```c++\n// 二分模板\nint main(){\n    int l = floor,r = ceil;\n    while(l<r){\n        int mid = (l+r)>>1;\n        if(check()) r = mid;\n        else l = mid+1;\n    }\n    // 第二个模板   注意左右边界的跳转的条件\n    while(l<r){\n        int mid = (l+r+1)>>1;\n        if(check()) l = mid;  \n        else r = mid-1;\n    }\n    \n}\n```\n\n\n\n```c++\n//\n// Created by Nino Neumann on 2023/3/29.\n//\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 1e16;\n\nint get(char c){\n    if(c<='9') return c-'0';\n    else return c-'a'+10;\n}\n\n\nLL convert(string a,LL radix){\n    LL res = 0;\n    LL c = 1;\n    for(int i = a.length()-1;i>=0;--i){\n        // if((double)res + (get(a[i])*c) > 1e16) return 1e18;\n        // cout<<(double)res + (get(a[i])*c)<<\"  \";\n        res += (get(a[i])*c);\n        c *= radix;\n        // cout<<\"  \"<<res<<endl;\n        if(res>1e16) return 1e16;\n        if(res<0)return 1e16;\n        \n    }\n    // cout<<res<<endl;\n    return res;\n}\n\nint main(){\n    string a,b;\n    int tag,radix;\n    cin>>a>>b>>tag>>radix;\n    if(tag==2) swap(a,b);\n    LL a_n = convert(a,radix);\n    // cout<<\"a_: \"<<a_n<<endl;\n    \n    // 二分的模板\n    LL l = 1,r = a_n+1;\n    \n    for (auto c : b) l = max(l, (LL)get(c) + 1);\n    while(l<r){\n        LL mid = (l+r)>>1;\n        if(convert(b,mid)>=a_n) r = mid;\n        else l = mid+1;\n    }\n    if(convert(b,r)==a_n) cout<<r<<endl;\n    else cout<<\"Impossible\\n\";\n    // cout<<convert(b,r)<<endl;\n    return 0;\n}\n```\n\n\n\n- 上下界的选择：\n\n上下界必须要根据当前这个数来确定进制上下界搜索的范围。\n\n- 做进制转换的时候数据可能会溢出，所以要加以判断，由于确定数最大就是$$36^{10}-1$$ 所以如果当前这一步计算的结果大于这个数就可以直接return一个很大的但是不溢出的数字。\n- 由于进制计算的步骤问题，有可能当前判断的时候溢出已经发生所以判断当前计算结果是否小于0 如果是则返回一个很大的数。\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n### 1492 可逆质数\n\n简单题，用到的模板就是质数判断\n\n### 1504 火星颜色\n\n简单题 不记录了\n\n值得记录的知识点：stringstream类的一些操作\n\n#### StringStream\n\n包含的头文件： sstream.h\n\n- 可以做普通的字符串输入输出的中转站\n\n```c++\n// 初始化一个sstream对象\nstringstream ssin;\nstring a;\nstring b;\nssin<<a; // 将a放入b中\ncout<<ssin.str()<<endl;// 输出存放在ssin中的所有字符串\nssin>>b; // 将刚才的放入的a放到b中\n```\n\n- 实现类型的转换\n\n```c++\nint d;\nstring ds;\nstringstream ssin;\nssin<<d;  // 将int输入ssin\nssin>>ds; // 将输入的int输出到ds中这中间会调用数据类型转换。\n\n```\n\n- 实现对于string字符串的空格切割\n\n```c++\nstring str;\ngetline(cin,str);\nstringstream ssin(str);\nstring word;\nwhile(ssin>>word){\n   operation)();\n}\n```\n\n\n\n### 1590 火星数字\n\nstringstream ssin（）\n\n输入输出\n\n## 排序\n\n### 1484 最佳排名\n\n数据结构：\n\n一个结构体、重载<运算符。规则 有四列成绩，每个学生只有其最好的排名。\n\n数据范围：\n\n学生和查询次数在2000以内 每科成绩100以内的正数\n\n思路：\n\n每次查询的时候对每个学生排序 输出所有排序中成绩最好的。时间复杂度不超。\n\n不清楚的点：\n\n排名怎么算？如果有同分数的人怎么算排名？按照分数排名还是按照别的规则。同分数名次一致。\n\n如何解决：\n\n将所有分数排序，然后按照每个同学的分数 直接去查这个排名表，查到的最考前的数的下标就是其排名。\n\n\n\n### 1499 数字图书馆\n\n要求：\n\n五个关键字段：书名、作者（唯一）、出版商、关键词（不超过五个空格分开。）、日期.\n\nid是可能有前导0的。\n\n思路：\n\n五个map<string,vector<string\\> >分别存放书名、出版商、关键词、日期 、作者与相关id的对应查询字典。最后输出查询的时候只要更具hash表找到对应的vector然后对其排名就可以了\n\n### 1502 PAT 排名\n\n思路：\n\n对每个地区的学生信息输入完成后生成一个地区排名表，将输入完成的学生的地区排名信息输入。\n\n所有的地区的学生信息输入完成后生成一个。\n\n```C++\n//\n// Created by Nino Neumann on 2023/3/31.\n//\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nstruct info{\n    string id;\n    int grade;\n    int final_rank,location_number,local_rank;\n    bool operator<(const info &a) const{\n        if(final_rank==a.final_rank) return id<a.id;\n        return final_rank<a.final_rank;\n    }\n};\n\n\nvector<int> total_grade_list;\nvector<info> total_students_list;\n\n\nint get_rank(int grade,vector<int> gl){\n    int l = 0,r = gl.size()-1;\n    while(l<r){\n        int mid = (l+r+1)>>1;\n        if(gl[mid]<=grade) l = mid;\n        else r = mid-1;\n    }\n    return gl.size()-l;\n}\n\nbool cmp(int &a,int &b){\n    return a>b;\n}\nint main(){\n    int n;\n    cin>>n;\n    for(int i = 1;i<=n;++i){\n        int k;\n        cin>>k;\n        vector<pair<string,int>> local_info;\n        vector<int> local_grade_list;\n        while(k--){\n            string id;\n            int grade;\n            cin>>id>>grade;\n            local_grade_list.push_back(grade);\n            local_info.push_back({id,grade});\n            total_grade_list.push_back(grade);\n        }\n\n        sort(local_grade_list.begin(),local_grade_list.end(),cmp);\n        // cout<<i<<\" \"<<\"local_grade_list 0 \"<<local_grade_list[0];\n\n        for(auto p:local_info){\n            string id = p.first;\n            int g = p.second;\n            int rank = get_rank(g,local_grade_list);\n            total_students_list.push_back({id,g,-1,i,rank});\n        }\n    }\n\n    sort(total_grade_list.begin(),total_grade_list.end(),cmp);\n    \n    for(int i = 0;i<total_students_list.size();++i){\n        info *p = &total_students_list[i];\n        int g = p->grade;\n        p->final_rank = get_rank(g,total_grade_list);\n    }\n    sort(total_students_list.begin(),total_students_list.end());\n    // cout<<total_students_list[0].grade<<endl;\n    cout<<total_students_list.size()<<endl;\n    for(auto stu:total_students_list){\n        cout<<stu.id<<\" \"<<stu.final_rank+1<<\" \"<<stu.location_number<<\" \"<<stu.local_rank+1<<endl;\n    }\n    return 0;\n}\n```\n\n毫不意外的超时了捏。\n\n应该是get_rank导致三重循环所以超时了吧。\n\n\n\n### 1505列表排序\n\n很简单的一道排序题，但是很容易超时，就想着这样。\n\n```C++\n//\n// Created by Nino Neumann on 2023/3/31.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct student{\n    string id,name;\n    int score;\n};\n\nbool cmp1(student &a,student &b) {\n    return a.id<b.id;\n}\nbool cmp2(student &a,student &b) {\n    return a.name==b.name ? a.id<b.id : a.name>=b.name;\n}\nbool cmp3(student &a,student &b) {\n    return a.score==b.score ? a.id<b.id : a.score>=b.score;\n}\n\nvector<student> students;\n\nint main(){\n    int n,c;\n    cin>>n>>c;\n    while(n--){\n        string id,name;\n        int grade;\n        cin>>id>>name>>grade;\n        students.push_back({id,name,grade});\n    }\n\n    if(c==1){\n        sort(students.begin(),students.end(),cmp1);\n    }else if (c==2){\n        sort(students.begin(),students.end(),cmp2);\n    }else{\n        sort(students.begin(),students.end(), cmp3);\n    }\n    for(auto s:students){\n        cout<<s.id<<\" \"<<s.name<<\" \"<<s.score<<endl;\n    }\n\n\n\n    return 0;\n}\n```\n\n试着用堆排序实现\n\n```C++\n//\n// Created by Nino Neumann on 2023/3/31.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nstruct student{\n    string id,name;\n    int score;\n};\n\nint c;\n\nbool operator>(const student a,const student b) {\n    if(c==1)\n        return a.id>b.id;\n    else if(c==2)\n        return a.name==b.name ? a.id>b.id : a.name>=b.name;\n    else\n        return a.score==b.score ? a.id>b.id : a.score>=b.score;\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d%d\",&n,&c);\n    priority_queue<student , vector<student> , greater<student> > heap;\n    while(n--){\n        string id,name;\n        id.resize(6);\n        name.resize(8);\n        \n        int grade;\n        scanf(\"%s%s%d\",&id[0],&name[0],&grade);\n        // scanf(\"%s\",&name[0]);\n        // scanf(\"%d\",&grade);\n        // cout<<id<<endl;\n        // students.push_back({id,name,grade});\n        heap.push({id,name,grade});\n    }\n\n    while(!heap.empty()){\n        auto s = heap.top();\n        heap.pop();\n        // cout<<s.id<<\" \"<<s.name<<\" \"<<s.score<<endl;\n        printf(\"%s %s %d\\n\",s.id.c_str(),s.name.c_str(),s.score);\n    }\n\n\n\n    return 0;\n}\n```\n\n依旧超时，因为在一个n循环中使用了堆排序所以时间复杂度是$$n^2log{n}$$ 所以会超时。\n\n这里应该着重优化输入输出。\n\n```C++\n//\n// Created by Nino Neumann on 2023/3/31.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\nconst int N = 1e5+1;\nstruct student{\n    string id,name;\n    int score;\n};\nstudent students[N];\n\nbool cmp1(student &a,student &b) {\n    return a.id<b.id;\n}\nbool cmp2(student &a,student &b) {\n    return a.name==b.name ? a.id<b.id : a.name<=b.name;\n}\nbool cmp3(student &a,student &b) {\n    return a.score==b.score ? a.id<b.id : a.score<=b.score;\n}\n\n// vector<student> students;\n\nint main(){\n    int n,c;\n    scanf(\"%d%d\",&n,&c);\n    // while(n--){\n    //     string id,name,line;\n    //     int grade;\n    //     cin>>id>>name>>grade;\n    //     students.push_back({id,name,grade});\n    // }\n    for(int i = 0;i<n;++i){\n        string name,id;\n        int grade;\n        name.resize(8);\n        id.resize(6);\n        scanf(\"%s%s%d\",&id[0],&name[0],&grade);\n        students[i].id = id;\n        students[i].name = name;\n        students[i].score = grade;\n    }\n        \n    \n\n    if(c==1){\n        sort(students,students+n,cmp1);\n    }else if (c==2){\n        sort(students,students+n,cmp2);\n    }else{\n        sort(students,students+n, cmp3);\n    }\n    for(int i = 0;i<n;++i){\n        auto s = students[i];\n        printf(\"%s %s %d\\n\",s.id.c_str(),s.name.c_str(),s.score);\n    }\n\n\n    return 0;\n}\n```\n\n\n\n### 1523 学生课程列表\n\n思路：\n\n使用哈希表 map查询 将每个学生的name为索引 跟上其选课的列表 vector<int> \n\n时间复杂度分析：\n\nhash表的插入查询：都是$$O(1)$$ 的时间复杂度\n\n输入时间复杂度：最多输入2500（课程最大数量）multi 200 （单个课程最多容纳人数）== 450000  输入\n\n查询操作时间复杂度：查询400000个人 最多不会超过450000（假设存在学生选了所有的课，但是这样的学僧最多不超过200个人，如果这个情况成立，那么也就是450000次）\n\n```c++\n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nmap<string,vector<int>> students;\n\n\nint n,k;\n\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    while(k--){\n        int c_id,member_num;\n        scanf(\"%d%d\",&c_id,&member_num);\n        while(member_num--){\n            string s;\n            s.resize(4);\n            scanf(\"%s\",&s[0]);\n            students[s].push_back(c_id);\n        }\n    }\n    //query\n    while(n--){\n        string s;\n        s.resize(4);\n        scanf(\"%s\",&s[0]);\n        printf(\"%s \",s.c_str());\n        if(students.find(s)!=students.end()){\n            sort(students[s].begin(),students[s].end());\n            printf(\"%d \",students[s].size());\n            \n            for(auto c:students[s])\n                printf(\"%d \",c);\n        }else{\n            printf(\"0\");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n应为在最后的查询里面会有一部排序的操作，所以挺怕他超时的，但是最后也没超时。\n\n### 1538 链表排序\n\n思路：\n\n创建一个map 将所有的元素输入进去，按照链表遍历将在链表中的元素加入vector里面 然后排序，最后输出。\n\n{% tabs 链表排序 %}\n<!-- tab TLE 使用了map-->\n\n\n\n ```C++\n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#define _CRT_SECURE_NO_WARNINGS \n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\n\nstruct node {\n    string addr;\n    int key;\n    string addr_next;\n    bool operator<(const node& a) const {\n        return key < a.key;\n    }\n};\n\nmap<string, node> hash_table;\nvector<node> nodes;\n\n// 输入 删除 排序 输出\n\nint main() {\n    string ad;\n    int n;\n    cin >> n >> ad;\n    while (n--) {\n        string s;\n        string o;\n        int key;\n        cin >> s >> key >> o;\n        hash_table[s] = { s,key,o };\n    }\n\n    while (ad != \"-1\") {\n        auto top_node = hash_table[ad];\n        nodes.push_back(top_node);\n        ad = top_node.addr_next;\n    }\n    sort(nodes.begin(),nodes.end());\n    \n    cout<<nodes.size()<<\" \";\n    if(nodes.size())\n        cout<<nodes[0].addr<<endl;\n    else{\n        cout<<\"-1\\n\";\n        return 0;\n    }\n    for (int i = 0;i<nodes.size();++i) {\n        auto n = nodes[i];\n        \n        if(i!=nodes.size()-1){\n            auto next = nodes[i+1];\n            printf(\"%s %d %s\\n\", n.addr.c_str(), n.key, next.addr.c_str());\n        }\n        else{\n            printf(\"%s %d -1\\n\", n.addr.c_str(), n.key);\n        }\n    }\n            \n\n\n\n    return 0;\n}\n ```\n\nTLE了。感觉又是cin的事情。\n\n<!-- endtab -->\n\n<!-- tab 使用unordered_map不超时 -->\n\n```C++\n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#define _CRT_SECURE_NO_WARNINGS \n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<unordered_map>\nusing namespace std;\n\nstruct node {\n    string addr;\n    int key;\n    string addr_next;\n    bool operator<(const node& a) const {\n        return key < a.key;\n    }\n};\n\nunordered_map<string, node> hash_table;\nvector<node> nodes;\n\n// 输入 删除 排序 输出\n\nint main() {\n    char c1[10];\n    char c2[10];\n    char c3[10];\n    \n    int n,key;\n    scanf(\"%d%s\",&n,c1);\n    string ad(c1);\n    while (n--) {\n        scanf(\"%s%d%s\",c2,&key,c3);\n        string s(c2),o(c3);\n        // cin >> s >> key >> o;\n        hash_table[s] = { s,key,o };\n    }\n\n    // while (ad != \"-1\") {\n    //     auto top_node = hash_table[ad];\n    //     nodes.push_back(top_node);\n    //     ad = top_node.addr_next;\n    // }\n    for(string head = ad;head!=\"-1\";head = hash_table[head].addr_next){\n        nodes.push_back(hash_table[head]);\n    }\n    sort(nodes.begin(),nodes.end());\n\n    printf(\"%d \",nodes.size());\n    if(nodes.size())\n        printf(\"%s\\n\",nodes[0].addr.c_str());\n    else{\n        printf(\"-1\\n\");\n        return 0;\n    }\n    for (int i = 0;i<nodes.size();++i) {\n        auto n = nodes[i];\n        \n        if(i!=nodes.size()-1){\n            auto next = nodes[i+1];\n            printf(\"%s %d %s\\n\", n.addr.c_str(), n.key, next.addr.c_str());\n        }\n        else{\n            printf(\"%s %d -1\\n\", n.addr.c_str(), n.key);\n        }\n    }\n            \n\n\n\n    return 0;\n}\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n能用scanf就用scanf，能用unordered_map就不用map。\n\n### 1561 PAT 评测\n\n思路：\n\n## 树\n\n### 树的遍历（重点最好记一下）\n\n- 给出的所有的点最多能到1百万个\n- 复杂度为$$O(n)$$\n- 给定的所有点的权值都是唯一的，如果不唯一那么树的形状可能不唯一。\n\n给定后序和中序遍历 输出层序遍历\n\n1、需要熟悉手动的中序+后续 构建树的过程、以及中序+前序构建树的过程。（在此基础上需要要知道如何快速找到中序遍历中的root下标）\n\n2、要知道本题中树是如何存储的。二叉树的存储可以简化到使用两个unordered_map 存储\n\n````C++\n#include<iostream>\n#include<queue>\n#include<unordered_map>\nusing namespace std;\n\nconst int N = 40;\n\nint postordered[N],inordered[N];\n\nunordered_map<int, int> l,r,ipost;\n\nint n;\n\nint build(int pl,int pr,int il,int ir){\n    int root  = postordered[pr];\n    int k = ipost[root];\n    if(il<k){\n        l[root] = build(pl,pl+k-1-il,il,k-1);\n    }\n    if(ir>k){\n        r[root] = build(pl+k-1-il+1,pr-1,k+1,ir);\n    }\n    return root;\n}\n\nvoid bfs(int root){\n    queue<int> q;\n    q.push(root);\n    while(!q.empty()){\n        auto t = q.front();\n        q.pop();\n        cout<<t<<\" \";\n        if(l.count(t)) q.push(l[t]);\n        if(r.count(t)) q.push(r[t]);\n    }\n}\n\nint main(){\n    cin>>n;\n    for(int i = 0;i<n;i++){\n        cin>>postordered[i];\n    }\n    \n    for(int i = 0;i<n;i++){\n        cin>>inordered[i];\n        ipost[inordered[i]] = i;\n    }\n    \n    int root = build(0,n-1,0,n-1);\n    bfs(root);\n    \n    \n    \n    return 0;\n}\n````\n\n\n\n### 1498 最深的根\n\n思路：使用并查集求解给定的树是否符合要求，以及不符合要求的话有多少个连通块。（这一步主要是对merge的过程进行修改。）\n\n```C++\n//\n// Created by Nino Neumann on 2023/4/19.\n//\n// 判断给出的树是不是一个连通的，如果不是求出连通分量-- 并查集\n// 求最深的根：对每个点进行遍历 dfs  存储图用的邻接表需要使用简易的邻接表否则会超时。\n#include \"iostream\"\n#include \"vector\"\n#include<cstring>\nusing namespace std;\n\nconst int N=1e4+10,M=N*2;  //\nint h[N],e[M],ne[M],idx; //邻接表存稀疏树图\n\nint n,k; // 一共有多少个节点\n\n// 定义并查集以及相关操作\nint p[N];\n\nint find(int a){\n    if(p[a]!=a) p[a] = find(p[a]);\n    return p[a];\n}\n\nvoid add(int a,int b)\n{\n    e[idx]=b;\n    ne[idx]=h[a];\n    h[a]=idx++;\n}\n\nvoid merge(int a,int b){\n    int fa = find(a),fb = find(b);\n    p[fa] = fb;\n}\n// 定义存储树的结构\n\n// struct head{\n//     vector<int> e;\n// };\n// head heads[N];\n\n// dfs\nint dfs(int u,int father){\n    // 计算当前根的最大深度\n    int depth = 0;\n    // if(heads[root].e.empty()){   // 搜索到叶子节点了；\n    //     return depth;\n    // }\n    for(int i=h[u];~i;i=ne[i])\n    {\n        int j=e[i];\n        if(j==father) continue; //重复搜了\n        depth=max(depth,dfs(j,u)+1);\n    }\n\n    // for(auto x:heads[root].e){\n    //     if(x==father)continue;\n    //     depth = max(depth,dfs(x,root)+1);\n    // }\n    return depth;\n}\n\n\n\n\nint main(){\n\n    scanf(\"%d\",&n);\n    k=n;\n    for(int i = 0;i<=n;++i) p[i] = i;\n    memset(h,-1,sizeof h); //初始化邻接表\n    for(int i = 0;i<n-1;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        int fx = find(x),fy = find(y);\n        if(fx!=fy){\n            p[fx] = fy;\n            k--;\n        }\n        add(x,y);add(y,x); //无向边加两次\n        // heads[x].e.push_back(y);\n        // heads[y].e.push_back(x);\n    }\n    if(k>1) printf(\"Error: %d components\\n\",k);\n    else\n    {\n        vector<int>nodes;\n        int max_depth=-1; //设置相反界外量\n        for(int i=1;i<=n;i++)\n        {\n            int depth=dfs(i,-1);  //这个节点无来源点 得到这个点的深度\n            if(depth>max_depth)\n            {\n                max_depth=depth; //更新\n                nodes.clear(); //清空\n                nodes.push_back(i);\n            }\n            else if(depth==max_depth) nodes.push_back(i);\n        }\n        for(auto v:nodes) cout<<v<<endl;\n\n    }\n\n\n    return 0;\n}\n```\n\n\n\n### 判断二叉搜索树\n\n问题一：如何根据二叉搜索树的先序遍历恢复树结构？\n\n二叉搜索树的中序遍历其实是已知的。这个问题其实就是根据二叉搜索树的中序和前序遍历得到二叉树。\n\n问题二：将问题转换为 上述的树的遍历后，中序遍历中节点值不唯一如何解决？\n\n由于中序遍历是一个有序数列，所以可以使用二分的方法去查找到当前前序遍历中的根节点在中序遍历中的位置\n\n问题三：如何判断不合法的情况？\n\n如果当前在中序区间中找根节点的过程中没有找到那么就返回false；\n\n```c++\n//\n// Created by Nino Neumann on 2023/4/19.\n//\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n\n\nconst int N = 1e3+10;\nint preorder[N],postorder[N],inorder[N];\nint cnt;\nint n;\n\n\nbool build(int il,int ir,int pl,int pr,int type){\n    bool res = true;\n    int root = preorder[pl];\n    int k = -1;\n    if(il>ir) return res; //  正常结束了\n    if(type==0){\n        // 二分查找左边界 升序数组中\n        // for (k = il; k <= ir; k ++ )\n        //     if (inorder[k] == root)\n        //         break;\n        // if (k > ir) return false;\n        int l = il,r = ir;\n        while(l<r){\n            int mid = (r+l)>>1;\n            if(inorder[mid]>=root)r = mid;\n            else l = mid+1;\n        }\n        if(inorder[l]==root) k = l;\n        else return false;\n    }else{\n        // 二分查找右边界 降序数组中\n        // for (k = ir; k >= il; k -- )\n        //     if (inorder[k] == root)\n        //         break;\n        // if (k < il) return false;\n        int l = il,r = ir;\n        while(l<r){\n            int mid = (r+l+1)>>1;\n            if(inorder[mid]>=root) l = mid;\n            else r = mid-1;\n        }\n        if(inorder[l]==root) k = l;\n        else return false;\n    }\n\n    if(!build(il,k-1,pl+1,pl+1+(k-1-il),type)) res = false;\n    if(!build(k+1,ir,pl+1+(k-1-il)+1,pr,type)) res = false;\n    postorder[cnt++] = root;\n    return res;\n\n\n\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 0;i<n;++i){\n        scanf(\"%d\",&preorder[i]);\n        inorder[i] = preorder[i];\n    }\n    sort(inorder,inorder+n);\n    if(build(0,n-1,0,n-1,0)){\n        // 这个树不是镜像并且存在  输出YES 和postorder序列\n        printf(\"YES\\n%d\",postorder[0]);\n        for(int i = 1;i<n;++i) printf(\" %d\",postorder[i]);\n    } else{\n        reverse(inorder,inorder+n);\n        cnt = 0; // 一定要注意cnt的重置\n        if(build(0,n-1,0,n-1,1)){\n            printf(\"YES\\n%d\",postorder[0]);\n            for(int i = 1;i<n;++i) printf(\" %d\",postorder[i]);\n        }else{\n            printf(\"NO\\n\");\n        }\n    }\n\n\n    return 0;\n}\n\n```\n\n\n\n### 1550 完全二叉搜索树\n\n对于我来说的难点：\n\n给定了每个节点的权值如何取构建一个完全二叉搜索树；\n\n如何使用数组存储树结构。\n\n-  从下标为0开始存储：\n- 从下标为一开始存储。\n\n{% tabs 1550 完全二叉搜索树 %}\n<!-- tab 思路-->\n\n通过完全二叉树的性质，可以定义二叉树的dfs边界，通过中序遍历将二叉树构建出来，并存储到一个数组中，再通过层序遍历将其输出。\n\n- 首先将节点按照从小到大的顺序排序，\n- 通过中序遍历建树\n- 直接输出存储树的数组就是中序遍历。\n\n<!-- endtab -->\n\n<!-- tab -->\n\n```C++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int N = 1010;\n\nint w[N];\nint tree[N];\nint n,cnt;\n\nvoid pre_order(int u){\n    int r_tree = u<<1;\n    int l_tree = (u<<1)+1;\n    if(r_tree<=n)\n        pre_order(r_tree);\n    tree[u] = w[cnt++];\n    if(l_tree<=n)\n        pre_order(l_tree);\n}\n\n\nint main(){\n    \n    cin>>n;\n    for(int i = 0;i<n;++i)cin>>w[i];\n    sort(w,w+n);\n    pre_order(1);\n    cout<<tree[1];\n    for(int i = 2;i<=n;++i) cout<<\" \"<<tree[i];\n    \n    \n    return 0;\n}\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n### 1576 再次树遍历\n\n这一题和  [3384. 二叉树遍历 - AcWing题 ](https://www.acwing.com/problem/content/description/3387/) 很像\n\n{% tabs 思路&&题解 %}\n<!-- tab 思路-->\n给出的堆栈操作是二叉树的先序遍历，可以使用先序遍历的dfs方法建树。\n\n- 可能涉及到字符串的查找判断。（可以简化，也可以省略）\n\n思路：\n\n- 首先根据先序遍历遍历二叉树，如果遇到pop就是回溯，\n- 然后再先序遍历过程中（由于是一个递归过程所以其中所有的节点都是存储下来的）通过后序的顺序输出每个节点的内容。\n\n一个重要的解题方法就是可以边先序输入边后序输出。\n\n<!-- endtab -->\n\n<!-- tab 题解-->\n\n```C++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nconst int N = 40;\nint n;\n\nvoid preorder(int root){\n    int w;\n    string str;\n    cin>>str;\n    if(str[1]=='u'){\n        // push 操作\n        cin>>w;\n        preorder(root*2);\n        preorder(root*2+1);\n        cout<<w;\n        if(root!=1)cout<<\" \";  //结尾不能有多余的空格。\n    }\n}\n\n\nint main(){\n    cin>>n;\n    preorder(1);\n    return 0;\n}\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n### 1589 构建二叉搜索树\n\n{% tabs 思路&&题解 %}\n<!-- tab 思路-->\n\n搜索树天生就知道其中序遍历。那么这题就是给出了树的结构和中序遍历，输出层序遍历。\n\n接下来就是解决具体问题了：\n\n- 定义存储树的结构\n- 定义inorder遍历的dfs函数\n- 定义层序遍历的bfs函数。\n\n<!-- endtab -->\n\n<!-- tab 题解-->\n\n```C++\n#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 110;\n\nstruct node{\n    int w;\n    int l,r;\n};\nint n;\nnode tree[N];\nint v[N];\nint cnt;\n\nvoid inorder(int root){\n    if(root==-1)return;\n    int l = tree[root].l;\n    int r = tree[root].r;\n    inorder(l);\n    tree[root].w = v[cnt++];\n    inorder(r);\n}\n\nvoid bfs(int root){\n    queue<int> q;\n    q.push(root);\n    while(!q.empty()){\n        auto front = q.front();\n        int l_tree = tree[front].l, r_tree = tree[front].r;\n        q.pop();\n        cout<<tree[front].w<<\" \";\n        if(l_tree>=0) q.push(l_tree);\n        if(r_tree>=0) q.push(r_tree);\n    }\n}\n\n\nint main(){\n    \n    cin>>n;\n    for(int i = 0;i<n;++i)\n        cin>>tree[i].l>>tree[i].r;\n        \n    for(int i = 0;i<n;++i)cin>>v[i];\n    sort(v,v+n);\n    inorder(0);\n    bfs(0);\n    \n    return 0;\n}\n```\n\n\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n\n\n\n\n# PAT甲级网站刷题记录\n\n## A1046 前缀和。\n\n## A1065 A+B and C (64bit)\n\n在使用longlong 类型的运算与另一个long long数据类型判断大小的时候（如下的情况）\n\n不能直接使用 (运算) 判断符号 LL这样的格式来判断\n\n{% tabs longlong数据类型判断大小 %}\n<!-- tab 错误做法 -->\n\n```c++\nLL a,b,c,res;\na+b>c;  //这样做是错误的。\n```\n\n<!-- endtab -->\n\n<!-- tab 正确做法 -->\n\n```c++\nLL a,b,c,res;\nres = a+b;\nres>c;  //这样做是对的。\n```\n\n因为不能确定两个longlong数据类型在做加法的时候是否发生了溢出，如果发生溢出机器会自动截断，因而加法运算会在不知道哪一步停止。\n\n<!-- endtab -->\n{% endtabs %}\n\n# DFS\n\ndfs的搜索顺序是一个树形的。\n\nDFS的经典运用：\n\n- 组合数问题\n\n## 输出组合数 acwing \n\n```C++\n#include<iostream>\nusing namespace std;\n\n\nconst int N = 10;\n\nint num[N];\nint res[N];\nbool is_select[N];\nint n;\n\nvoid print_result(){\n    for(int i = 1;i<=n;++i){\n        cout<<res[i]<<\" \";\n    }\n    cout<<endl;\n}\n\n\n\nvoid dfs(int step){\n    // step 表示当前到哪一个位置了。\n    if(step == n+1) {\n        //表示已经到达最后一步了 可以输出了\n        print_result();\n        return;\n    }\n    // 在所有没有被添加进去的数字中选择一个填入\n    for(int i = 1;i<=n;++i){\n        if(!is_select[i]){\n            is_select[i] = true;\n            res[step] = i;\n            dfs(step+1);\n            is_select[i] = false;\n        }\n    }\n}\n\n\nint main(){\n    cin>>n;\n    \n    dfs(1);\n    return 0;\n}\n```\n\n## PAT甲级中的DFS题目\n\n- A1004\n\n\n\n# 一些c++ 的性质的记录（我记不住所以记一下）\n\n## c++在函数声明后面有const\n\n```c++\nbool operator<(const T &a) const {...}\n```\n\n**已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理**\n\n该函数内部不能修改成员变量的值。\n\n## 遇到需要使用效率更高的输入scanf 输入\\printf 输出一行内含有string和in的混合类型。\n\n一种可行的方法是resize string的大小，这种方法使用的前提是你得知道这个待输入的string有多大。然后如下使用\n\n```c++\nint main(){\n\tstring a;\n\tstring b;\n\tint c;\n\ta.resize(10);\n\tb.resize(10);\n\tscanf(\"%s%s%d\",&a[0],&b[0],&c);\n\tprintf(\"a: %s b: %s c: %d\\n\",a.c_str(),b.c_str(),c);\n\n}\n```\n\n输出的时候要转换为c_str()。\n\n## 字符串的比较失效问题\n\n\n\n{% tabs 字符串比较失效 %}\n<!-- tab 最原始的场景-->\n\n```c++\n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#define _CRT_SECURE_NO_WARNINGS \n//\n// Created by Nino Neumann on 2023/4/1.\n//\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\n\nstruct node {\n    string addr;\n    int key;\n    string addr_next;\n    bool operator<(const node& a) const {\n        return key < a.key;\n    }\n};\n\nmap<string, node> hash_table;\nvector<node> nodes;\n\n// 输入 删除 排序 输出\n\nint main() {\n    string ad;\n    ad.resize(7);\n    int n;\n    scanf(\"%d%s\", &n, &ad[0]);\n    // cout<<n<<endl;\n    while (n--) {\n        string s;\n        string o;\n        s.resize(7);\n        o.resize(7);\n        int key;\n        scanf(\"%s%d%s\", &s[0], &key, &o[0]);\n        hash_table[s] = { s,key,o };\n        //        nodes.push_back({s,key,o});\n                // if(o==\"-1\")cout<<\"yes\\n\"<<endl;\n        if (o == \"-1\")cout << \"yes\\n\";\n    }\n    //    if(nodes)\n    // string current_addr = ad;\n    // cout<<(hash_table[\"11111\"].addr_next==\"22222\")<<endl;\n    // 下面的while循环部分失效 导致死循环 string之间的比较失效。\n    while (ad != \"-1\") {\n        auto top_node = hash_table[ad];\n        nodes.push_back(top_node);\n        ad = top_node.addr_next;\n        // cout<<\"-1\"<<endl;\n    }\n    //     sort(nodes.begin(),nodes.end());\n    // //    cout<<nodes.size()<<endl;\n    //     printf(\"%d %s\",nodes.size(),nodes[0].addr.c_str());\n    for (auto n : nodes) {\n        printf(\"%s %d %s\", n.addr.c_str(), n.key, n.addr_next.c_str());\n    }\n\n\n\n    return 0;\n}\n```\n\n<!-- endtab -->\n\n<!-- tab 一开始我以为-->问题出现的场景\n\n最原始的场景：\n\n```c++\nstring ad;\nstring addr_next;\nad.resize(5);\naddr_next.resize(5);\nstring current_addr = ad;\n // 输入的所有字符串的大小都是5，并且里面的有效长度也都是5\nwhile(current_addr!=\"-1\"){\n    auto top_node = hash_table[current_addr];\n    nodes.push_back(top_node);\n    current_addr = top_node.addr_next;\n}\n// 出现死循环，current_addr 不能判断出是否等于“-1”\n```\n\n出现原因：string读入的字符串必须要以\\0结尾，所以在定义string的resize大小的时候一定至少要多定义出一个额外的空间存放'\\0'。\n\n==不是这个原因==。 \n\n<!-- endtab -->\n\n<!-- tab 其实是-->\nsanf 读入字符串的原因，导致比较失效了。不建议使用scanf读入string 类型的数据。\n<!-- endtab -->\n{% endtabs %}\n\n# 关于二分找边界：\n\n\n\n暂时没弄明白，先记着。\n\n{% tabs 二分找边界问题 %}\n\n<!-- tab 基本的二分模板 -->\n\n```c++\nint bs(int q[],int t){\n\tint l = 0,r = n-1;\n\twhile(l<r){\n\t\tint mid = (l+r)>>1;\n\t\tif(q[mid]<t) l = mid;\n\t\telse r = mid+1;\n\t}\n    if(q[l]!=t) return -1;\n\treturn q[l];\n}\n```\n\n<!-- endtab -->\n\n<!-- tab 找有序数组中的某一个数的左边界 -->\n\n```c++\nint bs_left(int nums[],int t){\n    int r = n-1,l = 0;\n    while(l<r){\n        int mid = (l+r)>>1;\n        if(nums[mid]>=t) r = mid;\n        else l = mid+1;\n    }\n    \n    // cout<<\"targ: \"<<t<<\" left:\"<<l<<\" \"<<r<<endl;\n    if(nums[l]==t) return l;\n    return -1;\n}\n```\n\n\n\n<!-- endtab -->\n\n<!-- tab 找有序数组中的某一个数的右边界-->\n\n```c++\nint bs_right(int nums[],int t){\n    int r = n-1,l = 0;\n    while(l<r){\n        int mid = (l+r+1)>>1;\n        if(nums[mid]<=t) l = mid;\n        else r = mid-1;\n    }\n    // cout<<\"targ: \"<<t<<\" right:\"<<l<<\" \"<<r<<endl;\n    if(nums[l]==t) return l;\n    return -1;\n}\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n","slug":"my-pat-learning","published":1,"title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwm8000absuobps6ct03","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>03-29</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 进位制</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>03-30</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 排序</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>03-31</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 排序</p>\n<ul>\n<li>stringstream 类的一些操作</li>\n<li>如何自定义stl在sort中的排序规则</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-01</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 排序</p>\n<p>PAT甲级 的一些模拟题目</p>\n<ul>\n<li>long long 数据类型的大小判断。</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-01</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 DFS</p>\n<p>acwing上的一些冠以dfs的题解。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-05</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 最短路算法复习</p>\n<ul>\n<li>单源最短路<ul>\n<li>存在负权边<ul>\n<li>spfa</li>\n<li>bellman-ford算法</li>\n</ul>\n</li>\n<li>不存在负权边<ul>\n<li>dijkstra</li>\n<li>堆优化版本的dijkstra</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多源最短路<ul>\n<li>floyd算法</li>\n</ul>\n</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-05</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>二分查找找左右边界问题。</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-18</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>[x] 1497. 树的遍历</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-18</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>[x] 1498. 最深的根</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"PAT-recording\"><a href=\"#PAT-recording\" class=\"headerlink\" title=\"PAT-recording\"></a>PAT-recording</h1><ul>\n<li>[x] 进位制</li>\n<li>[ ] 排序</li>\n</ul>\n<h2 id=\"进位制\"><a href=\"#进位制\" class=\"headerlink\" title=\"进位制\"></a>进位制</h2><h3 id=\"1482-进制\"><a href=\"#1482-进制\" class=\"headerlink\" title=\"1482 进制\"></a>1482 进制</h3><p>分析：</p>\n<p>两个数，其中的一个进制是给定的,并且这个数的进制不超过36。</p>\n<p>但是另外一个数的进制就不好说了，可能是一个很大的数字。（重点）枚举的区间就是1~target  ：target=给定的数最大能表示的范围也就是<script type=\"math/tex\">36^{10}-1</script> 。</p>\n<p>显然，不能通过枚举的方法找，使用二分是一个不错的选择。</p>\n<div class=\"tabs\" id=\"test4\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#test4-1\">第一种方法（繁琐）</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#test4-2\">第二种方法</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"test4-1\"><p>枚举另一个数 将其转化为枚举的进制数字 或者都转化为10进制数字。</p>\n<p>需要一个 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">fuc</span><span class=\"params\">(string a, <span class=\"type\">int</span> in,<span class=\"type\">int</span> out)</span></span>;</span><br></pre></td></tr></table></figure>\n<p> 这样的函数将a转化为out 进制数</p>\n<p>这个方法实在是太繁琐了，（这个函数我不会写）</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"test4-2\"><p>计算一下两个数如果转化为十进制数 int 或者long long 能否能存下</p>\n<p>N是不超过十位的数字 最大就是 十个z  =  <script type=\"math/tex\">36^{10}-1</script>  可以使用 计算机自带的计算器计算这个数看看是否溢出。（不溢出）</p>\n<p>那么就可以找这样的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">fuc</span><span class=\"params\">(string a,<span class=\"type\">int</span> out)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>主要思路就是：二分。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二分模板</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> l = floor,r = ceil;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>()) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 第二个模板   注意左右边界的跳转的条件</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>()) l = mid;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/29.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> LL;</span><br><span class=\"line\"><span class=\"type\">const</span> LL N = <span class=\"number\">1e16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">char</span> c)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c&lt;=<span class=\"string\">'9'</span>) <span class=\"keyword\">return</span> c-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> c-<span class=\"string\">'a'</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LL <span class=\"title\">convert</span><span class=\"params\">(string a,LL radix)</span></span>{</span><br><span class=\"line\">    LL res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LL c = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i){</span><br><span class=\"line\">        <span class=\"comment\">// if((double)res + (get(a[i])*c) &gt; 1e16) return 1e18;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(double)res + (get(a[i])*c)&lt;&lt;\"  \";</span></span><br><span class=\"line\">        res += (<span class=\"built_in\">get</span>(a[i])*c);</span><br><span class=\"line\">        c *= radix;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;\"  \"&lt;&lt;res&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res&gt;<span class=\"number\">1e16</span>) <span class=\"keyword\">return</span> <span class=\"number\">1e16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res&lt;<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">1e16</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;res&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string a,b;</span><br><span class=\"line\">    <span class=\"type\">int</span> tag,radix;</span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;tag&gt;&gt;radix;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tag==<span class=\"number\">2</span>) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    LL a_n = <span class=\"built_in\">convert</span>(a,radix);</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;\"a_: \"&lt;&lt;a_n&lt;&lt;endl;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 二分的模板</span></span><br><span class=\"line\">    LL l = <span class=\"number\">1</span>,r = a_n+<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c : b) l = <span class=\"built_in\">max</span>(l, (LL)<span class=\"built_in\">get</span>(c) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        LL mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">convert</span>(b,mid)&gt;=a_n) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">convert</span>(b,r)==a_n) cout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">\"Impossible\\n\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;convert(b,r)&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上下界的选择：</li>\n</ul>\n<p>上下界必须要根据当前这个数来确定进制上下界搜索的范围。</p>\n<ul>\n<li>做进制转换的时候数据可能会溢出，所以要加以判断，由于确定数最大就是<script type=\"math/tex\">36^{10}-1</script> 所以如果当前这一步计算的结果大于这个数就可以直接return一个很大的但是不溢出的数字。</li>\n<li>由于进制计算的步骤问题，有可能当前判断的时候溢出已经发生所以判断当前计算结果是否小于0 如果是则返回一个很大的数。</li>\n</ul><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"1492-可逆质数\"><a href=\"#1492-可逆质数\" class=\"headerlink\" title=\"1492 可逆质数\"></a>1492 可逆质数</h3><p>简单题，用到的模板就是质数判断</p>\n<h3 id=\"1504-火星颜色\"><a href=\"#1504-火星颜色\" class=\"headerlink\" title=\"1504 火星颜色\"></a>1504 火星颜色</h3><p>简单题 不记录了</p>\n<p>值得记录的知识点：stringstream类的一些操作</p>\n<h4 id=\"StringStream\"><a href=\"#StringStream\" class=\"headerlink\" title=\"StringStream\"></a>StringStream</h4><p>包含的头文件： sstream.h</p>\n<ul>\n<li>可以做普通的字符串输入输出的中转站</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化一个sstream对象</span></span><br><span class=\"line\">stringstream ssin;</span><br><span class=\"line\">string a;</span><br><span class=\"line\">string b;</span><br><span class=\"line\">ssin&lt;&lt;a; <span class=\"comment\">// 将a放入b中</span></span><br><span class=\"line\">cout&lt;&lt;ssin.<span class=\"built_in\">str</span>()&lt;&lt;endl;<span class=\"comment\">// 输出存放在ssin中的所有字符串</span></span><br><span class=\"line\">ssin&gt;&gt;b; <span class=\"comment\">// 将刚才的放入的a放到b中</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现类型的转换</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> d;</span><br><span class=\"line\">string ds;</span><br><span class=\"line\">stringstream ssin;</span><br><span class=\"line\">ssin&lt;&lt;d;  <span class=\"comment\">// 将int输入ssin</span></span><br><span class=\"line\">ssin&gt;&gt;ds; <span class=\"comment\">// 将输入的int输出到ds中这中间会调用数据类型转换。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现对于string字符串的空格切割</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,str);</span><br><span class=\"line\"><span class=\"function\">stringstream <span class=\"title\">ssin</span><span class=\"params\">(str)</span></span>;</span><br><span class=\"line\">string word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(ssin&gt;&gt;word){</span><br><span class=\"line\">   operation)();</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h3 id=\"1590-火星数字\"><a href=\"#1590-火星数字\" class=\"headerlink\" title=\"1590 火星数字\"></a>1590 火星数字</h3><p>stringstream ssin（）</p>\n<p>输入输出</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"1484-最佳排名\"><a href=\"#1484-最佳排名\" class=\"headerlink\" title=\"1484 最佳排名\"></a>1484 最佳排名</h3><p>数据结构：</p>\n<p>一个结构体、重载&lt;运算符。规则 有四列成绩，每个学生只有其最好的排名。</p>\n<p>数据范围：</p>\n<p>学生和查询次数在2000以内 每科成绩100以内的正数</p>\n<p>思路：</p>\n<p>每次查询的时候对每个学生排序 输出所有排序中成绩最好的。时间复杂度不超。</p>\n<p>不清楚的点：</p>\n<p>排名怎么算？如果有同分数的人怎么算排名？按照分数排名还是按照别的规则。同分数名次一致。</p>\n<p>如何解决：</p>\n<p>将所有分数排序，然后按照每个同学的分数 直接去查这个排名表，查到的最考前的数的下标就是其排名。</p>\n<h3 id=\"1499-数字图书馆\"><a href=\"#1499-数字图书馆\" class=\"headerlink\" title=\"1499 数字图书馆\"></a>1499 数字图书馆</h3><p>要求：</p>\n<p>五个关键字段：书名、作者（唯一）、出版商、关键词（不超过五个空格分开。）、日期.</p>\n<p>id是可能有前导0的。</p>\n<p>思路：</p>\n<p>五个map<string,vector<string\\> &gt;分别存放书名、出版商、关键词、日期 、作者与相关id的对应查询字典。最后输出查询的时候只要更具hash表找到对应的vector然后对其排名就可以了</string,vector<string\\></p>\n<h3 id=\"1502-PAT-排名\"><a href=\"#1502-PAT-排名\" class=\"headerlink\" title=\"1502 PAT 排名\"></a>1502 PAT 排名</h3><p>思路：</p>\n<p>对每个地区的学生信息输入完成后生成一个地区排名表，将输入完成的学生的地区排名信息输入。</p>\n<p>所有的地区的学生信息输入完成后生成一个。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/31.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">info</span>{</span><br><span class=\"line\">    string id;</span><br><span class=\"line\">    <span class=\"type\">int</span> grade;</span><br><span class=\"line\">    <span class=\"type\">int</span> final_rank,location_number,local_rank;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> info &amp;a) <span class=\"type\">const</span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(final_rank==a.final_rank) <span class=\"keyword\">return</span> id&lt;a.id;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> final_rank&lt;a.final_rank;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; total_grade_list;</span><br><span class=\"line\">vector&lt;info&gt; total_students_list;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_rank</span><span class=\"params\">(<span class=\"type\">int</span> grade,vector&lt;<span class=\"type\">int</span>&gt; gl)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>,r = gl.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(gl[mid]&lt;=grade) l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gl.<span class=\"built_in\">size</span>()-l;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a,<span class=\"type\">int</span> &amp;b)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a&gt;b;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        <span class=\"type\">int</span> k;</span><br><span class=\"line\">        cin&gt;&gt;k;</span><br><span class=\"line\">        vector&lt;pair&lt;string,<span class=\"type\">int</span>&gt;&gt; local_info;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; local_grade_list;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k--){</span><br><span class=\"line\">            string id;</span><br><span class=\"line\">            <span class=\"type\">int</span> grade;</span><br><span class=\"line\">            cin&gt;&gt;id&gt;&gt;grade;</span><br><span class=\"line\">            local_grade_list.<span class=\"built_in\">push_back</span>(grade);</span><br><span class=\"line\">            local_info.<span class=\"built_in\">push_back</span>({id,grade});</span><br><span class=\"line\">            total_grade_list.<span class=\"built_in\">push_back</span>(grade);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(local_grade_list.<span class=\"built_in\">begin</span>(),local_grade_list.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;\"local_grade_list 0 \"&lt;&lt;local_grade_list[0];</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p:local_info){</span><br><span class=\"line\">            string id = p.first;</span><br><span class=\"line\">            <span class=\"type\">int</span> g = p.second;</span><br><span class=\"line\">            <span class=\"type\">int</span> rank = <span class=\"built_in\">get_rank</span>(g,local_grade_list);</span><br><span class=\"line\">            total_students_list.<span class=\"built_in\">push_back</span>({id,g,<span class=\"number\">-1</span>,i,rank});</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(total_grade_list.<span class=\"built_in\">begin</span>(),total_grade_list.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;total_students_list.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        info *p = &amp;total_students_list[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> g = p-&gt;grade;</span><br><span class=\"line\">        p-&gt;final_rank = <span class=\"built_in\">get_rank</span>(g,total_grade_list);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(total_students_list.<span class=\"built_in\">begin</span>(),total_students_list.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;total_students_list[0].grade&lt;&lt;endl;</span></span><br><span class=\"line\">    cout&lt;&lt;total_students_list.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> stu:total_students_list){</span><br><span class=\"line\">        cout&lt;&lt;stu.id&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu.final_rank+<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu.location_number&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu.local_rank+<span class=\"number\">1</span>&lt;&lt;endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>毫不意外的超时了捏。</p>\n<p>应该是get_rank导致三重循环所以超时了吧。</p>\n<h3 id=\"1505列表排序\"><a href=\"#1505列表排序\" class=\"headerlink\" title=\"1505列表排序\"></a>1505列表排序</h3><p>很简单的一道排序题，但是很容易超时，就想着这样。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/31.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span>{</span><br><span class=\"line\">    string id,name;</span><br><span class=\"line\">    <span class=\"type\">int</span> score;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.id&lt;b.id;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp2</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.name==b.name ? a.id&lt;b.id : a.name&gt;=b.name;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp3</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.score==b.score ? a.id&lt;b.id : a.score&gt;=b.score;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;student&gt; students;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n,c;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--){</span><br><span class=\"line\">        string id,name;</span><br><span class=\"line\">        <span class=\"type\">int</span> grade;</span><br><span class=\"line\">        cin&gt;&gt;id&gt;&gt;name&gt;&gt;grade;</span><br><span class=\"line\">        students.<span class=\"built_in\">push_back</span>({id,name,grade});</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c==<span class=\"number\">1</span>){</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students.<span class=\"built_in\">begin</span>(),students.<span class=\"built_in\">end</span>(),cmp1);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c==<span class=\"number\">2</span>){</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students.<span class=\"built_in\">begin</span>(),students.<span class=\"built_in\">end</span>(),cmp2);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students.<span class=\"built_in\">begin</span>(),students.<span class=\"built_in\">end</span>(), cmp3);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:students){</span><br><span class=\"line\">        cout&lt;&lt;s.id&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;s.name&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;s.score&lt;&lt;endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>试着用堆排序实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/31.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span>{</span><br><span class=\"line\">    string id,name;</span><br><span class=\"line\">    <span class=\"type\">int</span> score;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> student a,<span class=\"type\">const</span> student b) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c==<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.id&gt;b.id;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c==<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.name==b.name ? a.id&gt;b.id : a.name&gt;=b.name;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.score==b.score ? a.id&gt;b.id : a.score&gt;=b.score;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;c);</span><br><span class=\"line\">    priority_queue&lt;student , vector&lt;student&gt; , greater&lt;student&gt; &gt; heap;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--){</span><br><span class=\"line\">        string id,name;</span><br><span class=\"line\">        id.<span class=\"built_in\">resize</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">        name.<span class=\"built_in\">resize</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> grade;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,&amp;id[<span class=\"number\">0</span>],&amp;name[<span class=\"number\">0</span>],&amp;grade);</span><br><span class=\"line\">        <span class=\"comment\">// scanf(\"%s\",&amp;name[0]);</span></span><br><span class=\"line\">        <span class=\"comment\">// scanf(\"%d\",&amp;grade);</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;id&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// students.push_back({id,name,grade});</span></span><br><span class=\"line\">        heap.<span class=\"built_in\">push</span>({id,name,grade});</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!heap.<span class=\"built_in\">empty</span>()){</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> s = heap.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        heap.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s.id&lt;&lt;\" \"&lt;&lt;s.name&lt;&lt;\" \"&lt;&lt;s.score&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s %d\\n\"</span>,s.id.<span class=\"built_in\">c_str</span>(),s.name.<span class=\"built_in\">c_str</span>(),s.score);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>依旧超时，因为在一个n循环中使用了堆排序所以时间复杂度是<script type=\"math/tex\">n^2log{n}</script> 所以会超时。</p>\n<p>这里应该着重优化输入输出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/31.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span>{</span><br><span class=\"line\">    string id,name;</span><br><span class=\"line\">    <span class=\"type\">int</span> score;</span><br><span class=\"line\">};</span><br><span class=\"line\">student students[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.id&lt;b.id;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp2</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.name==b.name ? a.id&lt;b.id : a.name&lt;=b.name;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp3</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.score==b.score ? a.id&lt;b.id : a.score&lt;=b.score;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vector&lt;student&gt; students;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n,c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;c);</span><br><span class=\"line\">    <span class=\"comment\">// while(n--){</span></span><br><span class=\"line\">    <span class=\"comment\">//     string id,name,line;</span></span><br><span class=\"line\">    <span class=\"comment\">//     int grade;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cin&gt;&gt;id&gt;&gt;name&gt;&gt;grade;</span></span><br><span class=\"line\">    <span class=\"comment\">//     students.push_back({id,name,grade});</span></span><br><span class=\"line\">    <span class=\"comment\">// }</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        string name,id;</span><br><span class=\"line\">        <span class=\"type\">int</span> grade;</span><br><span class=\"line\">        name.<span class=\"built_in\">resize</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">        id.<span class=\"built_in\">resize</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,&amp;id[<span class=\"number\">0</span>],&amp;name[<span class=\"number\">0</span>],&amp;grade);</span><br><span class=\"line\">        students[i].id = id;</span><br><span class=\"line\">        students[i].name = name;</span><br><span class=\"line\">        students[i].score = grade;</span><br><span class=\"line\">    }</span><br><span class=\"line\">        </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c==<span class=\"number\">1</span>){</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students,students+n,cmp1);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c==<span class=\"number\">2</span>){</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students,students+n,cmp2);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students,students+n, cmp3);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> s = students[i];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s %d\\n\"</span>,s.id.<span class=\"built_in\">c_str</span>(),s.name.<span class=\"built_in\">c_str</span>(),s.score);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h3 id=\"1523-学生课程列表\"><a href=\"#1523-学生课程列表\" class=\"headerlink\" title=\"1523 学生课程列表\"></a>1523 学生课程列表</h3><p>思路：</p>\n<p>使用哈希表 map查询 将每个学生的name为索引 跟上其选课的列表 vector<int> </int></p>\n<p>时间复杂度分析：</p>\n<p>hash表的插入查询：都是<script type=\"math/tex\">O(1)</script> 的时间复杂度</p>\n<p>输入时间复杂度：最多输入2500（课程最大数量）multi 200 （单个课程最多容纳人数）== 450000  输入</p>\n<p>查询操作时间复杂度：查询400000个人 最多不会超过450000（假设存在学生选了所有的课，但是这样的学僧最多不超过200个人，如果这个情况成立，那么也就是450000次）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">map&lt;string,vector&lt;<span class=\"type\">int</span>&gt;&gt; students;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k--){</span><br><span class=\"line\">        <span class=\"type\">int</span> c_id,member_num;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;c_id,&amp;member_num);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(member_num--){</span><br><span class=\"line\">            string s;</span><br><span class=\"line\">            s.<span class=\"built_in\">resize</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,&amp;s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            students[s].<span class=\"built_in\">push_back</span>(c_id);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//query</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--){</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,&amp;s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s \"</span>,s.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(students.<span class=\"built_in\">find</span>(s)!=students.<span class=\"built_in\">end</span>()){</span><br><span class=\"line\">            <span class=\"built_in\">sort</span>(students[s].<span class=\"built_in\">begin</span>(),students[s].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,students[s].<span class=\"built_in\">size</span>());</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:students[s])</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,c);</span><br><span class=\"line\">        }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>应为在最后的查询里面会有一部排序的操作，所以挺怕他超时的，但是最后也没超时。</p>\n<h3 id=\"1538-链表排序\"><a href=\"#1538-链表排序\" class=\"headerlink\" title=\"1538 链表排序\"></a>1538 链表排序</h3><p>思路：</p>\n<p>创建一个map 将所有的元素输入进去，按照链表遍历将在链表中的元素加入vector里面 然后排序，最后输出。</p>\n<div class=\"tabs\" id=\"链表排序\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#链表排序-1\">TLE 使用了map</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#链表排序-2\">使用unordered_map不超时</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"链表排序-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> {</span><br><span class=\"line\">    string addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    string addr_next;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> node&amp; a) <span class=\"type\">const</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key &lt; a.key;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">map&lt;string, node&gt; hash_table;</span><br><span class=\"line\">vector&lt;node&gt; nodes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输入 删除 排序 输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    string ad;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; ad;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) {</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        string o;</span><br><span class=\"line\">        <span class=\"type\">int</span> key;</span><br><span class=\"line\">        cin &gt;&gt; s &gt;&gt; key &gt;&gt; o;</span><br><span class=\"line\">        hash_table[s] = { s,key,o };</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ad != <span class=\"string\">\"-1\"</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> top_node = hash_table[ad];</span><br><span class=\"line\">        nodes.<span class=\"built_in\">push_back</span>(top_node);</span><br><span class=\"line\">        ad = top_node.addr_next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(nodes.<span class=\"built_in\">begin</span>(),nodes.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;nodes.<span class=\"built_in\">size</span>()&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nodes.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        cout&lt;&lt;nodes[<span class=\"number\">0</span>].addr&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>{</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">\"-1\\n\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;nodes.<span class=\"built_in\">size</span>();++i) {</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> n = nodes[i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=nodes.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>){</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> next = nodes[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d %s\\n\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key, next.addr.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span>{</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d -1\\n\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>TLE了。感觉又是cin的事情。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"链表排序-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> {</span><br><span class=\"line\">    string addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    string addr_next;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> node&amp; a) <span class=\"type\">const</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key &lt; a.key;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">unordered_map&lt;string, node&gt; hash_table;</span><br><span class=\"line\">vector&lt;node&gt; nodes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输入 删除 排序 输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">char</span> c1[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">char</span> c2[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">char</span> c3[<span class=\"number\">10</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> n,key;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%s\"</span>,&amp;n,c1);</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">ad</span><span class=\"params\">(c1)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) {</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%d%s\"</span>,c2,&amp;key,c3);</span><br><span class=\"line\">        <span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(c2)</span>,<span class=\"title\">o</span><span class=\"params\">(c3)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// cin &gt;&gt; s &gt;&gt; key &gt;&gt; o;</span></span><br><span class=\"line\">        hash_table[s] = { s,key,o };</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// while (ad != \"-1\") {</span></span><br><span class=\"line\">    <span class=\"comment\">//     auto top_node = hash_table[ad];</span></span><br><span class=\"line\">    <span class=\"comment\">//     nodes.push_back(top_node);</span></span><br><span class=\"line\">    <span class=\"comment\">//     ad = top_node.addr_next;</span></span><br><span class=\"line\">    <span class=\"comment\">// }</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(string head = ad;head!=<span class=\"string\">\"-1\"</span>;head = hash_table[head].addr_next){</span><br><span class=\"line\">        nodes.<span class=\"built_in\">push_back</span>(hash_table[head]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(nodes.<span class=\"built_in\">begin</span>(),nodes.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,nodes.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nodes.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,nodes[<span class=\"number\">0</span>].addr.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    <span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;nodes.<span class=\"built_in\">size</span>();++i) {</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> n = nodes[i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=nodes.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>){</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> next = nodes[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d %s\\n\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key, next.addr.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span>{</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d -1\\n\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<p>能用scanf就用scanf，能用unordered_map就不用map。</p>\n<h3 id=\"1561-PAT-评测\"><a href=\"#1561-PAT-评测\" class=\"headerlink\" title=\"1561 PAT 评测\"></a>1561 PAT 评测</h3><p>思路：</p>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"树的遍历（重点最好记一下）\"><a href=\"#树的遍历（重点最好记一下）\" class=\"headerlink\" title=\"树的遍历（重点最好记一下）\"></a>树的遍历（重点最好记一下）</h3><ul>\n<li>给出的所有的点最多能到1百万个</li>\n<li>复杂度为<script type=\"math/tex\">O(n)</script></li>\n<li>给定的所有点的权值都是唯一的，如果不唯一那么树的形状可能不唯一。</li>\n</ul>\n<p>给定后序和中序遍历 输出层序遍历</p>\n<p>1、需要熟悉手动的中序+后续 构建树的过程、以及中序+前序构建树的过程。（在此基础上需要要知道如何快速找到中序遍历中的root下标）</p>\n<p>2、要知道本题中树是如何存储的。二叉树的存储可以简化到使用两个unordered_map 存储</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">40</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> postordered[N],inordered[N];</span><br><span class=\"line\"></span><br><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; l,r,ipost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> pl,<span class=\"type\">int</span> pr,<span class=\"type\">int</span> il,<span class=\"type\">int</span> ir)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> root  = postordered[pr];</span><br><span class=\"line\">    <span class=\"type\">int</span> k = ipost[root];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(il&lt;k){</span><br><span class=\"line\">        l[root] = <span class=\"built_in\">build</span>(pl,pl+k<span class=\"number\">-1</span>-il,il,k<span class=\"number\">-1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ir&gt;k){</span><br><span class=\"line\">        r[root] = <span class=\"built_in\">build</span>(pl+k<span class=\"number\">-1</span>-il+<span class=\"number\">1</span>,pr<span class=\"number\">-1</span>,k+<span class=\"number\">1</span>,ir);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> root)</span></span>{</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>()){</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout&lt;&lt;t&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l.<span class=\"built_in\">count</span>(t)) q.<span class=\"built_in\">push</span>(l[t]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r.<span class=\"built_in\">count</span>(t)) q.<span class=\"built_in\">push</span>(r[t]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++){</span><br><span class=\"line\">        cin&gt;&gt;postordered[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++){</span><br><span class=\"line\">        cin&gt;&gt;inordered[i];</span><br><span class=\"line\">        ipost[inordered[i]] = i;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> root = <span class=\"built_in\">build</span>(<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(root);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h3 id=\"1498-最深的根\"><a href=\"#1498-最深的根\" class=\"headerlink\" title=\"1498 最深的根\"></a>1498 最深的根</h3><p>思路：使用并查集求解给定的树是否符合要求，以及不符合要求的话有多少个连通块。（这一步主要是对merge的过程进行修改。）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/19.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 判断给出的树是不是一个连通的，如果不是求出连通分量-- 并查集</span></span><br><span class=\"line\"><span class=\"comment\">// 求最深的根：对每个点进行遍历 dfs  存储图用的邻接表需要使用简易的邻接表否则会超时。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"iostream\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"vector\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">1e4</span>+<span class=\"number\">10</span>,M=N*<span class=\"number\">2</span>;  <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"type\">int</span> h[N],e[M],ne[M],idx; <span class=\"comment\">//邻接表存稀疏树图</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,k; <span class=\"comment\">// 一共有多少个节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义并查集以及相关操作</span></span><br><span class=\"line\"><span class=\"type\">int</span> p[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> a)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p[a]!=a) p[a] = <span class=\"built_in\">find</span>(p[a]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p[a];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    e[idx]=b;</span><br><span class=\"line\">    ne[idx]=h[a];</span><br><span class=\"line\">    h[a]=idx++;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> fa = <span class=\"built_in\">find</span>(a),fb = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">    p[fa] = fb;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 定义存储树的结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// struct head{</span></span><br><span class=\"line\"><span class=\"comment\">//     vector&lt;int&gt; e;</span></span><br><span class=\"line\"><span class=\"comment\">// };</span></span><br><span class=\"line\"><span class=\"comment\">// head heads[N];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dfs</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> father)</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">// 计算当前根的最大深度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// if(heads[root].e.empty()){   // 搜索到叶子节点了；</span></span><br><span class=\"line\">    <span class=\"comment\">//     return depth;</span></span><br><span class=\"line\">    <span class=\"comment\">// }</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=h[u];~i;i=ne[i])</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"type\">int</span> j=e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j==father) <span class=\"keyword\">continue</span>; <span class=\"comment\">//重复搜了</span></span><br><span class=\"line\">        depth=<span class=\"built_in\">max</span>(depth,<span class=\"built_in\">dfs</span>(j,u)+<span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(auto x:heads[root].e){</span></span><br><span class=\"line\">    <span class=\"comment\">//     if(x==father)continue;</span></span><br><span class=\"line\">    <span class=\"comment\">//     depth = max(depth,dfs(x,root)+1);</span></span><br><span class=\"line\">    <span class=\"comment\">// }</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    k=n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;++i) p[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span> h); <span class=\"comment\">//初始化邻接表</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;++i){</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;x,&amp;y);</span><br><span class=\"line\">        <span class=\"type\">int</span> fx = <span class=\"built_in\">find</span>(x),fy = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fx!=fy){</span><br><span class=\"line\">            p[fx] = fy;</span><br><span class=\"line\">            k--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(x,y);<span class=\"built_in\">add</span>(y,x); <span class=\"comment\">//无向边加两次</span></span><br><span class=\"line\">        <span class=\"comment\">// heads[x].e.push_back(y);</span></span><br><span class=\"line\">        <span class=\"comment\">// heads[y].e.push_back(x);</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k&gt;<span class=\"number\">1</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"Error: %d components\\n\"</span>,k);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;nodes;</span><br><span class=\"line\">        <span class=\"type\">int</span> max_depth=<span class=\"number\">-1</span>; <span class=\"comment\">//设置相反界外量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"type\">int</span> depth=<span class=\"built_in\">dfs</span>(i,<span class=\"number\">-1</span>);  <span class=\"comment\">//这个节点无来源点 得到这个点的深度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(depth&gt;max_depth)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                max_depth=depth; <span class=\"comment\">//更新</span></span><br><span class=\"line\">                nodes.<span class=\"built_in\">clear</span>(); <span class=\"comment\">//清空</span></span><br><span class=\"line\">                nodes.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(depth==max_depth) nodes.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> v:nodes) cout&lt;&lt;v&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h3 id=\"判断二叉搜索树\"><a href=\"#判断二叉搜索树\" class=\"headerlink\" title=\"判断二叉搜索树\"></a>判断二叉搜索树</h3><p>问题一：如何根据二叉搜索树的先序遍历恢复树结构？</p>\n<p>二叉搜索树的中序遍历其实是已知的。这个问题其实就是根据二叉搜索树的中序和前序遍历得到二叉树。</p>\n<p>问题二：将问题转换为 上述的树的遍历后，中序遍历中节点值不唯一如何解决？</p>\n<p>由于中序遍历是一个有序数列，所以可以使用二分的方法去查找到当前前序遍历中的根节点在中序遍历中的位置</p>\n<p>问题三：如何判断不合法的情况？</p>\n<p>如果当前在中序区间中找根节点的过程中没有找到那么就返回false；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/19.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> preorder[N],postorder[N],inorder[N];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> il,<span class=\"type\">int</span> ir,<span class=\"type\">int</span> pl,<span class=\"type\">int</span> pr,<span class=\"type\">int</span> type)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">bool</span> res = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> root = preorder[pl];</span><br><span class=\"line\">    <span class=\"type\">int</span> k = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(il&gt;ir) <span class=\"keyword\">return</span> res; <span class=\"comment\">//  正常结束了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type==<span class=\"number\">0</span>){</span><br><span class=\"line\">        <span class=\"comment\">// 二分查找左边界 升序数组中</span></span><br><span class=\"line\">        <span class=\"comment\">// for (k = il; k &lt;= ir; k ++ )</span></span><br><span class=\"line\">        <span class=\"comment\">//     if (inorder[k] == root)</span></span><br><span class=\"line\">        <span class=\"comment\">//         break;</span></span><br><span class=\"line\">        <span class=\"comment\">// if (k &gt; ir) return false;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> l = il,r = ir;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (r+l)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(inorder[mid]&gt;=root)r = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inorder[l]==root) k = l;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"comment\">// 二分查找右边界 降序数组中</span></span><br><span class=\"line\">        <span class=\"comment\">// for (k = ir; k &gt;= il; k -- )</span></span><br><span class=\"line\">        <span class=\"comment\">//     if (inorder[k] == root)</span></span><br><span class=\"line\">        <span class=\"comment\">//         break;</span></span><br><span class=\"line\">        <span class=\"comment\">// if (k &lt; il) return false;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> l = il,r = ir;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (r+l+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(inorder[mid]&gt;=root) l = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inorder[l]==root) k = l;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">build</span>(il,k<span class=\"number\">-1</span>,pl+<span class=\"number\">1</span>,pl+<span class=\"number\">1</span>+(k<span class=\"number\">-1</span>-il),type)) res = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">build</span>(k+<span class=\"number\">1</span>,ir,pl+<span class=\"number\">1</span>+(k<span class=\"number\">-1</span>-il)+<span class=\"number\">1</span>,pr,type)) res = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    postorder[cnt++] = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;preorder[i]);</span><br><span class=\"line\">        inorder[i] = preorder[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(inorder,inorder+n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">build</span>(<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>)){</span><br><span class=\"line\">        <span class=\"comment\">// 这个树不是镜像并且存在  输出YES 和postorder序列</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n%d\"</span>,postorder[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;n;++i) <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,postorder[i]);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(inorder,inorder+n);</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>; <span class=\"comment\">// 一定要注意cnt的重置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">build</span>(<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">1</span>)){</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n%d\"</span>,postorder[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;n;++i) <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,postorder[i]);</span><br><span class=\"line\">        }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1550-完全二叉搜索树\"><a href=\"#1550-完全二叉搜索树\" class=\"headerlink\" title=\"1550 完全二叉搜索树\"></a>1550 完全二叉搜索树</h3><p>对于我来说的难点：</p>\n<p>给定了每个节点的权值如何取构建一个完全二叉搜索树；</p>\n<p>如何使用数组存储树结构。</p>\n<ul>\n<li>从下标为0开始存储：</li>\n<li>从下标为一开始存储。</li>\n</ul>\n<div class=\"tabs\" id=\"1550-完全二叉搜索树\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#1550-完全二叉搜索树-1\">思路</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#1550-完全二叉搜索树-2\">1550 完全二叉搜索树 2</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"1550-完全二叉搜索树-1\"><p>通过完全二叉树的性质，可以定义二叉树的dfs边界，通过中序遍历将二叉树构建出来，并存储到一个数组中，再通过层序遍历将其输出。</p>\n<ul>\n<li>首先将节点按照从小到大的顺序排序，</li>\n<li>通过中序遍历建树</li>\n<li>直接输出存储树的数组就是中序遍历。</li>\n</ul><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"1550-完全二叉搜索树-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> w[N];</span><br><span class=\"line\"><span class=\"type\">int</span> tree[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n,cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre_order</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> r_tree = u&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> l_tree = (u&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r_tree&lt;=n)</span><br><span class=\"line\">        <span class=\"built_in\">pre_order</span>(r_tree);</span><br><span class=\"line\">    tree[u] = w[cnt++];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l_tree&lt;=n)</span><br><span class=\"line\">        <span class=\"built_in\">pre_order</span>(l_tree);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)cin&gt;&gt;w[i];</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(w,w+n);</span><br><span class=\"line\">    <span class=\"built_in\">pre_order</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;tree[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i) cout&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;tree[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"1576-再次树遍历\"><a href=\"#1576-再次树遍历\" class=\"headerlink\" title=\"1576 再次树遍历\"></a>1576 再次树遍历</h3><p>这一题和  <a href=\"https://www.acwing.com/problem/content/description/3387/\">3384. 二叉树遍历 - AcWing题 </a> 很像</p>\n<div class=\"tabs\" id=\"思路&&题解\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#思路&&题解-1\">思路</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#思路&&题解-2\">题解</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"思路&&题解-1\"><p>给出的堆栈操作是二叉树的先序遍历，可以使用先序遍历的dfs方法建树。</p>\n<ul>\n<li>可能涉及到字符串的查找判断。（可以简化，也可以省略）</li>\n</ul>\n<p>思路：</p>\n<ul>\n<li>首先根据先序遍历遍历二叉树，如果遇到pop就是回溯，</li>\n<li>然后再先序遍历过程中（由于是一个递归过程所以其中所有的节点都是存储下来的）通过后序的顺序输出每个节点的内容。</li>\n</ul>\n<p>一个重要的解题方法就是可以边先序输入边后序输出。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"思路&&题解-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preorder</span><span class=\"params\">(<span class=\"type\">int</span> root)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> w;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    cin&gt;&gt;str;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str[<span class=\"number\">1</span>]==<span class=\"string\">'u'</span>){</span><br><span class=\"line\">        <span class=\"comment\">// push 操作</span></span><br><span class=\"line\">        cin&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">preorder</span>(root*<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"built_in\">preorder</span>(root*<span class=\"number\">2</span>+<span class=\"number\">1</span>);</span><br><span class=\"line\">        cout&lt;&lt;w;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root!=<span class=\"number\">1</span>)cout&lt;&lt;<span class=\"string\">\" \"</span>;  <span class=\"comment\">//结尾不能有多余的空格。</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">preorder</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"1589-构建二叉搜索树\"><a href=\"#1589-构建二叉搜索树\" class=\"headerlink\" title=\"1589 构建二叉搜索树\"></a>1589 构建二叉搜索树</h3><div class=\"tabs\" id=\"思路&&题解\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#思路&&题解-1\">思路</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#思路&&题解-2\">题解</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"思路&&题解-1\"><p>搜索树天生就知道其中序遍历。那么这题就是给出了树的结构和中序遍历，输出层序遍历。</p>\n<p>接下来就是解决具体问题了：</p>\n<ul>\n<li>定义存储树的结构</li>\n<li>定义inorder遍历的dfs函数</li>\n<li>定义层序遍历的bfs函数。</li>\n</ul><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"思路&&题解-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">110</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> w;</span><br><span class=\"line\">    <span class=\"type\">int</span> l,r;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">node tree[N];</span><br><span class=\"line\"><span class=\"type\">int</span> v[N];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(<span class=\"type\">int</span> root)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"number\">-1</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = tree[root].l;</span><br><span class=\"line\">    <span class=\"type\">int</span> r = tree[root].r;</span><br><span class=\"line\">    <span class=\"built_in\">inorder</span>(l);</span><br><span class=\"line\">    tree[root].w = v[cnt++];</span><br><span class=\"line\">    <span class=\"built_in\">inorder</span>(r);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> root)</span></span>{</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>()){</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> front = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> l_tree = tree[front].l, r_tree = tree[front].r;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout&lt;&lt;tree[front].w&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l_tree&gt;=<span class=\"number\">0</span>) q.<span class=\"built_in\">push</span>(l_tree);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r_tree&gt;=<span class=\"number\">0</span>) q.<span class=\"built_in\">push</span>(r_tree);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">        cin&gt;&gt;tree[i].l&gt;&gt;tree[i].r;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)cin&gt;&gt;v[i];</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(v,v+n);</span><br><span class=\"line\">    <span class=\"built_in\">inorder</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"PAT甲级网站刷题记录\"><a href=\"#PAT甲级网站刷题记录\" class=\"headerlink\" title=\"PAT甲级网站刷题记录\"></a>PAT甲级网站刷题记录</h1><h2 id=\"A1046-前缀和。\"><a href=\"#A1046-前缀和。\" class=\"headerlink\" title=\"A1046 前缀和。\"></a>A1046 前缀和。</h2><h2 id=\"A1065-A-B-and-C-64bit\"><a href=\"#A1065-A-B-and-C-64bit\" class=\"headerlink\" title=\"A1065 A+B and C (64bit)\"></a>A1065 A+B and C (64bit)</h2><p>在使用longlong 类型的运算与另一个long long数据类型判断大小的时候（如下的情况）</p>\n<p>不能直接使用 (运算) 判断符号 LL这样的格式来判断</p>\n<div class=\"tabs\" id=\"longlong数据类型判断大小\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#longlong数据类型判断大小-1\">错误做法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#longlong数据类型判断大小-2\">正确做法</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"longlong数据类型判断大小-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LL a,b,c,res;</span><br><span class=\"line\">a+b&gt;c;  <span class=\"comment\">//这样做是错误的。</span></span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"longlong数据类型判断大小-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LL a,b,c,res;</span><br><span class=\"line\">res = a+b;</span><br><span class=\"line\">res&gt;c;  <span class=\"comment\">//这样做是对的。</span></span><br></pre></td></tr></table></figure>\n<p>因为不能确定两个longlong数据类型在做加法的时候是否发生了溢出，如果发生溢出机器会自动截断，因而加法运算会在不知道哪一步停止。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h1><p>dfs的搜索顺序是一个树形的。</p>\n<p>DFS的经典运用：</p>\n<ul>\n<li>组合数问题</li>\n</ul>\n<h2 id=\"输出组合数-acwing\"><a href=\"#输出组合数-acwing\" class=\"headerlink\" title=\"输出组合数 acwing\"></a>输出组合数 acwing</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> num[N];</span><br><span class=\"line\"><span class=\"type\">int</span> res[N];</span><br><span class=\"line\"><span class=\"type\">bool</span> is_select[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print_result</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        cout&lt;&lt;res[i]&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> step)</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">// step 表示当前到哪一个位置了。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(step == n+<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"comment\">//表示已经到达最后一步了 可以输出了</span></span><br><span class=\"line\">        <span class=\"built_in\">print_result</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 在所有没有被添加进去的数字中选择一个填入</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!is_select[i]){</span><br><span class=\"line\">            is_select[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            res[step] = i;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(step+<span class=\"number\">1</span>);</span><br><span class=\"line\">            is_select[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"PAT甲级中的DFS题目\"><a href=\"#PAT甲级中的DFS题目\" class=\"headerlink\" title=\"PAT甲级中的DFS题目\"></a>PAT甲级中的DFS题目</h2><ul>\n<li>A1004</li>\n</ul>\n<h1 id=\"一些c-的性质的记录（我记不住所以记一下）\"><a href=\"#一些c-的性质的记录（我记不住所以记一下）\" class=\"headerlink\" title=\"一些c++ 的性质的记录（我记不住所以记一下）\"></a>一些c++ 的性质的记录（我记不住所以记一下）</h1><h2 id=\"c-在函数声明后面有const\"><a href=\"#c-在函数声明后面有const\" class=\"headerlink\" title=\"c++在函数声明后面有const\"></a>c++在函数声明后面有const</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> T &amp;a) <span class=\"type\">const</span> {...}</span><br></pre></td></tr></table></figure>\n<p><strong>已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理</strong></p>\n<p>该函数内部不能修改成员变量的值。</p>\n<h2 id=\"遇到需要使用效率更高的输入scanf-输入-printf-输出一行内含有string和in的混合类型。\"><a href=\"#遇到需要使用效率更高的输入scanf-输入-printf-输出一行内含有string和in的混合类型。\" class=\"headerlink\" title=\"遇到需要使用效率更高的输入scanf 输入\\printf 输出一行内含有string和in的混合类型。\"></a>遇到需要使用效率更高的输入scanf 输入\\printf 输出一行内含有string和in的混合类型。</h2><p>一种可行的方法是resize string的大小，这种方法使用的前提是你得知道这个待输入的string有多大。然后如下使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">\tstring a;</span><br><span class=\"line\">\tstring b;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">\ta.<span class=\"built_in\">resize</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\tb.<span class=\"built_in\">resize</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,&amp;a[<span class=\"number\">0</span>],&amp;b[<span class=\"number\">0</span>],&amp;c);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a: %s b: %s c: %d\\n\"</span>,a.<span class=\"built_in\">c_str</span>(),b.<span class=\"built_in\">c_str</span>(),c);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>输出的时候要转换为c_str()。</p>\n<h2 id=\"字符串的比较失效问题\"><a href=\"#字符串的比较失效问题\" class=\"headerlink\" title=\"字符串的比较失效问题\"></a>字符串的比较失效问题</h2><div class=\"tabs\" id=\"字符串比较失效\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#字符串比较失效-1\">最原始的场景</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#字符串比较失效-2\">其实是</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"字符串比较失效-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> {</span><br><span class=\"line\">    string addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    string addr_next;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> node&amp; a) <span class=\"type\">const</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key &lt; a.key;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">map&lt;string, node&gt; hash_table;</span><br><span class=\"line\">vector&lt;node&gt; nodes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输入 删除 排序 输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    string ad;</span><br><span class=\"line\">    ad.<span class=\"built_in\">resize</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%s\"</span>, &amp;n, &amp;ad[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) {</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        string o;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">        o.<span class=\"built_in\">resize</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> key;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%d%s\"</span>, &amp;s[<span class=\"number\">0</span>], &amp;key, &amp;o[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        hash_table[s] = { s,key,o };</span><br><span class=\"line\">        <span class=\"comment\">//        nodes.push_back({s,key,o});</span></span><br><span class=\"line\">                <span class=\"comment\">// if(o==\"-1\")cout&lt;&lt;\"yes\\n\"&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"string\">\"-1\"</span>)cout &lt;&lt; <span class=\"string\">\"yes\\n\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//    if(nodes)</span></span><br><span class=\"line\">    <span class=\"comment\">// string current_addr = ad;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;(hash_table[\"11111\"].addr_next==\"22222\")&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// 下面的while循环部分失效 导致死循环 string之间的比较失效。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ad != <span class=\"string\">\"-1\"</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> top_node = hash_table[ad];</span><br><span class=\"line\">        nodes.<span class=\"built_in\">push_back</span>(top_node);</span><br><span class=\"line\">        ad = top_node.addr_next;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;\"-1\"&lt;&lt;endl;</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//     sort(nodes.begin(),nodes.end());</span></span><br><span class=\"line\">    <span class=\"comment\">// //    cout&lt;&lt;nodes.size()&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">//     printf(\"%d %s\",nodes.size(),nodes[0].addr.c_str());</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> n : nodes) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d %s\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key, n.addr_next.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"字符串比较失效-2\"><p>sanf 读入字符串的原因，导致比较失效了。不建议使用scanf读入string 类型的数据。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"关于二分找边界：\"><a href=\"#关于二分找边界：\" class=\"headerlink\" title=\"关于二分找边界：\"></a>关于二分找边界：</h1><p>暂时没弄明白，先记着。</p>\n<div class=\"tabs\" id=\"二分找边界问题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#二分找边界问题-1\">基本的二分模板</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#二分找边界问题-2\">找有序数组中的某一个数的左边界</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#二分找边界问题-3\">找有序数组中的某一个数的右边界</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"二分找边界问题-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bs</span><span class=\"params\">(<span class=\"type\">int</span> q[],<span class=\"type\">int</span> t)</span></span>{</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">0</span>,r = n<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q[mid]&lt;t) l = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q[l]!=t) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> q[l];</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"二分找边界问题-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bs_left</span><span class=\"params\">(<span class=\"type\">int</span> nums[],<span class=\"type\">int</span> t)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> r = n<span class=\"number\">-1</span>,l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]&gt;=t) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;\"targ: \"&lt;&lt;t&lt;&lt;\" left:\"&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[l]==t) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"二分找边界问题-3\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bs_right</span><span class=\"params\">(<span class=\"type\">int</span> nums[],<span class=\"type\">int</span> t)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> r = n<span class=\"number\">-1</span>,l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]&lt;=t) l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;\"targ: \"&lt;&lt;t&lt;&lt;\" right:\"&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[l]==t) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>03-29</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 进位制</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>03-30</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 排序</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>03-31</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 排序</p>\n<ul>\n<li>stringstream 类的一些操作</li>\n<li>如何自定义stl在sort中的排序规则</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-01</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 排序</p>\n<p>PAT甲级 的一些模拟题目</p>\n<ul>\n<li>long long 数据类型的大小判断。</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-01</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 DFS</p>\n<p>acwing上的一些冠以dfs的题解。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-05</p>\n</div></div><div class=\"timeline-item-content\"><p>PAT甲级 最短路算法复习</p>\n<ul>\n<li>单源最短路<ul>\n<li>存在负权边<ul>\n<li>spfa</li>\n<li>bellman-ford算法</li>\n</ul>\n</li>\n<li>不存在负权边<ul>\n<li>dijkstra</li>\n<li>堆优化版本的dijkstra</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多源最短路<ul>\n<li>floyd算法</li>\n</ul>\n</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-05</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>二分查找找左右边界问题。</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-18</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>[x] 1497. 树的遍历</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-18</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>[x] 1498. 最深的根</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"PAT-recording\"><a href=\"#PAT-recording\" class=\"headerlink\" title=\"PAT-recording\"></a>PAT-recording</h1><ul>\n<li>[x] 进位制</li>\n<li>[ ] 排序</li>\n</ul>\n<h2 id=\"进位制\"><a href=\"#进位制\" class=\"headerlink\" title=\"进位制\"></a>进位制</h2><h3 id=\"1482-进制\"><a href=\"#1482-进制\" class=\"headerlink\" title=\"1482 进制\"></a>1482 进制</h3><p>分析：</p>\n<p>两个数，其中的一个进制是给定的,并且这个数的进制不超过36。</p>\n<p>但是另外一个数的进制就不好说了，可能是一个很大的数字。（重点）枚举的区间就是1~target  ：target=给定的数最大能表示的范围也就是<script type=\"math/tex\">36^{10}-1</script> 。</p>\n<p>显然，不能通过枚举的方法找，使用二分是一个不错的选择。</p>\n<div class=\"tabs\" id=\"test4\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#test4-1\">第一种方法（繁琐）</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#test4-2\">第二种方法</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"test4-1\"><p>枚举另一个数 将其转化为枚举的进制数字 或者都转化为10进制数字。</p>\n<p>需要一个 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">fuc</span><span class=\"params\">(string a, <span class=\"type\">int</span> in,<span class=\"type\">int</span> out)</span></span>;</span><br></pre></td></tr></table></figure>\n<p> 这样的函数将a转化为out 进制数</p>\n<p>这个方法实在是太繁琐了，（这个函数我不会写）</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"test4-2\"><p>计算一下两个数如果转化为十进制数 int 或者long long 能否能存下</p>\n<p>N是不超过十位的数字 最大就是 十个z  =  <script type=\"math/tex\">36^{10}-1</script>  可以使用 计算机自带的计算器计算这个数看看是否溢出。（不溢出）</p>\n<p>那么就可以找这样的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">fuc</span><span class=\"params\">(string a,<span class=\"type\">int</span> out)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>主要思路就是：二分。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二分模板</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> l = floor,r = ceil;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>()) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 第二个模板   注意左右边界的跳转的条件</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>()) l = mid;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/29.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> LL;</span><br><span class=\"line\"><span class=\"type\">const</span> LL N = <span class=\"number\">1e16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">char</span> c)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c&lt;=<span class=\"string\">'9'</span>) <span class=\"keyword\">return</span> c-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> c-<span class=\"string\">'a'</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LL <span class=\"title\">convert</span><span class=\"params\">(string a,LL radix)</span></span>{</span><br><span class=\"line\">    LL res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LL c = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = a.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i){</span><br><span class=\"line\">        <span class=\"comment\">// if((double)res + (get(a[i])*c) &gt; 1e16) return 1e18;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(double)res + (get(a[i])*c)&lt;&lt;\"  \";</span></span><br><span class=\"line\">        res += (<span class=\"built_in\">get</span>(a[i])*c);</span><br><span class=\"line\">        c *= radix;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;\"  \"&lt;&lt;res&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res&gt;<span class=\"number\">1e16</span>) <span class=\"keyword\">return</span> <span class=\"number\">1e16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res&lt;<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">1e16</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;res&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string a,b;</span><br><span class=\"line\">    <span class=\"type\">int</span> tag,radix;</span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;tag&gt;&gt;radix;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tag==<span class=\"number\">2</span>) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    LL a_n = <span class=\"built_in\">convert</span>(a,radix);</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;\"a_: \"&lt;&lt;a_n&lt;&lt;endl;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 二分的模板</span></span><br><span class=\"line\">    LL l = <span class=\"number\">1</span>,r = a_n+<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c : b) l = <span class=\"built_in\">max</span>(l, (LL)<span class=\"built_in\">get</span>(c) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        LL mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">convert</span>(b,mid)&gt;=a_n) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">convert</span>(b,r)==a_n) cout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">\"Impossible\\n\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;convert(b,r)&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上下界的选择：</li>\n</ul>\n<p>上下界必须要根据当前这个数来确定进制上下界搜索的范围。</p>\n<ul>\n<li>做进制转换的时候数据可能会溢出，所以要加以判断，由于确定数最大就是<script type=\"math/tex\">36^{10}-1</script> 所以如果当前这一步计算的结果大于这个数就可以直接return一个很大的但是不溢出的数字。</li>\n<li>由于进制计算的步骤问题，有可能当前判断的时候溢出已经发生所以判断当前计算结果是否小于0 如果是则返回一个很大的数。</li>\n</ul><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"1492-可逆质数\"><a href=\"#1492-可逆质数\" class=\"headerlink\" title=\"1492 可逆质数\"></a>1492 可逆质数</h3><p>简单题，用到的模板就是质数判断</p>\n<h3 id=\"1504-火星颜色\"><a href=\"#1504-火星颜色\" class=\"headerlink\" title=\"1504 火星颜色\"></a>1504 火星颜色</h3><p>简单题 不记录了</p>\n<p>值得记录的知识点：stringstream类的一些操作</p>\n<h4 id=\"StringStream\"><a href=\"#StringStream\" class=\"headerlink\" title=\"StringStream\"></a>StringStream</h4><p>包含的头文件： sstream.h</p>\n<ul>\n<li>可以做普通的字符串输入输出的中转站</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化一个sstream对象</span></span><br><span class=\"line\">stringstream ssin;</span><br><span class=\"line\">string a;</span><br><span class=\"line\">string b;</span><br><span class=\"line\">ssin&lt;&lt;a; <span class=\"comment\">// 将a放入b中</span></span><br><span class=\"line\">cout&lt;&lt;ssin.<span class=\"built_in\">str</span>()&lt;&lt;endl;<span class=\"comment\">// 输出存放在ssin中的所有字符串</span></span><br><span class=\"line\">ssin&gt;&gt;b; <span class=\"comment\">// 将刚才的放入的a放到b中</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现类型的转换</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> d;</span><br><span class=\"line\">string ds;</span><br><span class=\"line\">stringstream ssin;</span><br><span class=\"line\">ssin&lt;&lt;d;  <span class=\"comment\">// 将int输入ssin</span></span><br><span class=\"line\">ssin&gt;&gt;ds; <span class=\"comment\">// 将输入的int输出到ds中这中间会调用数据类型转换。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现对于string字符串的空格切割</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,str);</span><br><span class=\"line\"><span class=\"function\">stringstream <span class=\"title\">ssin</span><span class=\"params\">(str)</span></span>;</span><br><span class=\"line\">string word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(ssin&gt;&gt;word){</span><br><span class=\"line\">   operation)();</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h3 id=\"1590-火星数字\"><a href=\"#1590-火星数字\" class=\"headerlink\" title=\"1590 火星数字\"></a>1590 火星数字</h3><p>stringstream ssin（）</p>\n<p>输入输出</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"1484-最佳排名\"><a href=\"#1484-最佳排名\" class=\"headerlink\" title=\"1484 最佳排名\"></a>1484 最佳排名</h3><p>数据结构：</p>\n<p>一个结构体、重载&lt;运算符。规则 有四列成绩，每个学生只有其最好的排名。</p>\n<p>数据范围：</p>\n<p>学生和查询次数在2000以内 每科成绩100以内的正数</p>\n<p>思路：</p>\n<p>每次查询的时候对每个学生排序 输出所有排序中成绩最好的。时间复杂度不超。</p>\n<p>不清楚的点：</p>\n<p>排名怎么算？如果有同分数的人怎么算排名？按照分数排名还是按照别的规则。同分数名次一致。</p>\n<p>如何解决：</p>\n<p>将所有分数排序，然后按照每个同学的分数 直接去查这个排名表，查到的最考前的数的下标就是其排名。</p>\n<h3 id=\"1499-数字图书馆\"><a href=\"#1499-数字图书馆\" class=\"headerlink\" title=\"1499 数字图书馆\"></a>1499 数字图书馆</h3><p>要求：</p>\n<p>五个关键字段：书名、作者（唯一）、出版商、关键词（不超过五个空格分开。）、日期.</p>\n<p>id是可能有前导0的。</p>\n<p>思路：</p>\n<p>五个map<string,vector<string\\> &gt;分别存放书名、出版商、关键词、日期 、作者与相关id的对应查询字典。最后输出查询的时候只要更具hash表找到对应的vector然后对其排名就可以了</string,vector<string\\></p>\n<h3 id=\"1502-PAT-排名\"><a href=\"#1502-PAT-排名\" class=\"headerlink\" title=\"1502 PAT 排名\"></a>1502 PAT 排名</h3><p>思路：</p>\n<p>对每个地区的学生信息输入完成后生成一个地区排名表，将输入完成的学生的地区排名信息输入。</p>\n<p>所有的地区的学生信息输入完成后生成一个。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/31.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">info</span>{</span><br><span class=\"line\">    string id;</span><br><span class=\"line\">    <span class=\"type\">int</span> grade;</span><br><span class=\"line\">    <span class=\"type\">int</span> final_rank,location_number,local_rank;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> info &amp;a) <span class=\"type\">const</span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(final_rank==a.final_rank) <span class=\"keyword\">return</span> id&lt;a.id;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> final_rank&lt;a.final_rank;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; total_grade_list;</span><br><span class=\"line\">vector&lt;info&gt; total_students_list;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_rank</span><span class=\"params\">(<span class=\"type\">int</span> grade,vector&lt;<span class=\"type\">int</span>&gt; gl)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>,r = gl.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(gl[mid]&lt;=grade) l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gl.<span class=\"built_in\">size</span>()-l;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a,<span class=\"type\">int</span> &amp;b)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a&gt;b;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        <span class=\"type\">int</span> k;</span><br><span class=\"line\">        cin&gt;&gt;k;</span><br><span class=\"line\">        vector&lt;pair&lt;string,<span class=\"type\">int</span>&gt;&gt; local_info;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; local_grade_list;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k--){</span><br><span class=\"line\">            string id;</span><br><span class=\"line\">            <span class=\"type\">int</span> grade;</span><br><span class=\"line\">            cin&gt;&gt;id&gt;&gt;grade;</span><br><span class=\"line\">            local_grade_list.<span class=\"built_in\">push_back</span>(grade);</span><br><span class=\"line\">            local_info.<span class=\"built_in\">push_back</span>({id,grade});</span><br><span class=\"line\">            total_grade_list.<span class=\"built_in\">push_back</span>(grade);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(local_grade_list.<span class=\"built_in\">begin</span>(),local_grade_list.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;\"local_grade_list 0 \"&lt;&lt;local_grade_list[0];</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p:local_info){</span><br><span class=\"line\">            string id = p.first;</span><br><span class=\"line\">            <span class=\"type\">int</span> g = p.second;</span><br><span class=\"line\">            <span class=\"type\">int</span> rank = <span class=\"built_in\">get_rank</span>(g,local_grade_list);</span><br><span class=\"line\">            total_students_list.<span class=\"built_in\">push_back</span>({id,g,<span class=\"number\">-1</span>,i,rank});</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(total_grade_list.<span class=\"built_in\">begin</span>(),total_grade_list.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;total_students_list.<span class=\"built_in\">size</span>();++i){</span><br><span class=\"line\">        info *p = &amp;total_students_list[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> g = p-&gt;grade;</span><br><span class=\"line\">        p-&gt;final_rank = <span class=\"built_in\">get_rank</span>(g,total_grade_list);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(total_students_list.<span class=\"built_in\">begin</span>(),total_students_list.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;total_students_list[0].grade&lt;&lt;endl;</span></span><br><span class=\"line\">    cout&lt;&lt;total_students_list.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> stu:total_students_list){</span><br><span class=\"line\">        cout&lt;&lt;stu.id&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu.final_rank+<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu.location_number&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu.local_rank+<span class=\"number\">1</span>&lt;&lt;endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>毫不意外的超时了捏。</p>\n<p>应该是get_rank导致三重循环所以超时了吧。</p>\n<h3 id=\"1505列表排序\"><a href=\"#1505列表排序\" class=\"headerlink\" title=\"1505列表排序\"></a>1505列表排序</h3><p>很简单的一道排序题，但是很容易超时，就想着这样。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/31.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span>{</span><br><span class=\"line\">    string id,name;</span><br><span class=\"line\">    <span class=\"type\">int</span> score;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.id&lt;b.id;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp2</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.name==b.name ? a.id&lt;b.id : a.name&gt;=b.name;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp3</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.score==b.score ? a.id&lt;b.id : a.score&gt;=b.score;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;student&gt; students;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n,c;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--){</span><br><span class=\"line\">        string id,name;</span><br><span class=\"line\">        <span class=\"type\">int</span> grade;</span><br><span class=\"line\">        cin&gt;&gt;id&gt;&gt;name&gt;&gt;grade;</span><br><span class=\"line\">        students.<span class=\"built_in\">push_back</span>({id,name,grade});</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c==<span class=\"number\">1</span>){</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students.<span class=\"built_in\">begin</span>(),students.<span class=\"built_in\">end</span>(),cmp1);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c==<span class=\"number\">2</span>){</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students.<span class=\"built_in\">begin</span>(),students.<span class=\"built_in\">end</span>(),cmp2);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students.<span class=\"built_in\">begin</span>(),students.<span class=\"built_in\">end</span>(), cmp3);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:students){</span><br><span class=\"line\">        cout&lt;&lt;s.id&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;s.name&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;s.score&lt;&lt;endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>试着用堆排序实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/31.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span>{</span><br><span class=\"line\">    string id,name;</span><br><span class=\"line\">    <span class=\"type\">int</span> score;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> student a,<span class=\"type\">const</span> student b) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c==<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.id&gt;b.id;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c==<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.name==b.name ? a.id&gt;b.id : a.name&gt;=b.name;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.score==b.score ? a.id&gt;b.id : a.score&gt;=b.score;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;c);</span><br><span class=\"line\">    priority_queue&lt;student , vector&lt;student&gt; , greater&lt;student&gt; &gt; heap;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--){</span><br><span class=\"line\">        string id,name;</span><br><span class=\"line\">        id.<span class=\"built_in\">resize</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">        name.<span class=\"built_in\">resize</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> grade;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,&amp;id[<span class=\"number\">0</span>],&amp;name[<span class=\"number\">0</span>],&amp;grade);</span><br><span class=\"line\">        <span class=\"comment\">// scanf(\"%s\",&amp;name[0]);</span></span><br><span class=\"line\">        <span class=\"comment\">// scanf(\"%d\",&amp;grade);</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;id&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// students.push_back({id,name,grade});</span></span><br><span class=\"line\">        heap.<span class=\"built_in\">push</span>({id,name,grade});</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!heap.<span class=\"built_in\">empty</span>()){</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> s = heap.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        heap.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s.id&lt;&lt;\" \"&lt;&lt;s.name&lt;&lt;\" \"&lt;&lt;s.score&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s %d\\n\"</span>,s.id.<span class=\"built_in\">c_str</span>(),s.name.<span class=\"built_in\">c_str</span>(),s.score);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>依旧超时，因为在一个n循环中使用了堆排序所以时间复杂度是<script type=\"math/tex\">n^2log{n}</script> 所以会超时。</p>\n<p>这里应该着重优化输入输出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/3/31.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span>{</span><br><span class=\"line\">    string id,name;</span><br><span class=\"line\">    <span class=\"type\">int</span> score;</span><br><span class=\"line\">};</span><br><span class=\"line\">student students[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.id&lt;b.id;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp2</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.name==b.name ? a.id&lt;b.id : a.name&lt;=b.name;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp3</span><span class=\"params\">(student &amp;a,student &amp;b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.score==b.score ? a.id&lt;b.id : a.score&lt;=b.score;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vector&lt;student&gt; students;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> n,c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;c);</span><br><span class=\"line\">    <span class=\"comment\">// while(n--){</span></span><br><span class=\"line\">    <span class=\"comment\">//     string id,name,line;</span></span><br><span class=\"line\">    <span class=\"comment\">//     int grade;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cin&gt;&gt;id&gt;&gt;name&gt;&gt;grade;</span></span><br><span class=\"line\">    <span class=\"comment\">//     students.push_back({id,name,grade});</span></span><br><span class=\"line\">    <span class=\"comment\">// }</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        string name,id;</span><br><span class=\"line\">        <span class=\"type\">int</span> grade;</span><br><span class=\"line\">        name.<span class=\"built_in\">resize</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">        id.<span class=\"built_in\">resize</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,&amp;id[<span class=\"number\">0</span>],&amp;name[<span class=\"number\">0</span>],&amp;grade);</span><br><span class=\"line\">        students[i].id = id;</span><br><span class=\"line\">        students[i].name = name;</span><br><span class=\"line\">        students[i].score = grade;</span><br><span class=\"line\">    }</span><br><span class=\"line\">        </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c==<span class=\"number\">1</span>){</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students,students+n,cmp1);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c==<span class=\"number\">2</span>){</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students,students+n,cmp2);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(students,students+n, cmp3);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> s = students[i];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s %d\\n\"</span>,s.id.<span class=\"built_in\">c_str</span>(),s.name.<span class=\"built_in\">c_str</span>(),s.score);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h3 id=\"1523-学生课程列表\"><a href=\"#1523-学生课程列表\" class=\"headerlink\" title=\"1523 学生课程列表\"></a>1523 学生课程列表</h3><p>思路：</p>\n<p>使用哈希表 map查询 将每个学生的name为索引 跟上其选课的列表 vector<int> </int></p>\n<p>时间复杂度分析：</p>\n<p>hash表的插入查询：都是<script type=\"math/tex\">O(1)</script> 的时间复杂度</p>\n<p>输入时间复杂度：最多输入2500（课程最大数量）multi 200 （单个课程最多容纳人数）== 450000  输入</p>\n<p>查询操作时间复杂度：查询400000个人 最多不会超过450000（假设存在学生选了所有的课，但是这样的学僧最多不超过200个人，如果这个情况成立，那么也就是450000次）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">map&lt;string,vector&lt;<span class=\"type\">int</span>&gt;&gt; students;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k--){</span><br><span class=\"line\">        <span class=\"type\">int</span> c_id,member_num;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;c_id,&amp;member_num);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(member_num--){</span><br><span class=\"line\">            string s;</span><br><span class=\"line\">            s.<span class=\"built_in\">resize</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,&amp;s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            students[s].<span class=\"built_in\">push_back</span>(c_id);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//query</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--){</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,&amp;s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s \"</span>,s.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(students.<span class=\"built_in\">find</span>(s)!=students.<span class=\"built_in\">end</span>()){</span><br><span class=\"line\">            <span class=\"built_in\">sort</span>(students[s].<span class=\"built_in\">begin</span>(),students[s].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,students[s].<span class=\"built_in\">size</span>());</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:students[s])</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,c);</span><br><span class=\"line\">        }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>应为在最后的查询里面会有一部排序的操作，所以挺怕他超时的，但是最后也没超时。</p>\n<h3 id=\"1538-链表排序\"><a href=\"#1538-链表排序\" class=\"headerlink\" title=\"1538 链表排序\"></a>1538 链表排序</h3><p>思路：</p>\n<p>创建一个map 将所有的元素输入进去，按照链表遍历将在链表中的元素加入vector里面 然后排序，最后输出。</p>\n<div class=\"tabs\" id=\"链表排序\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#链表排序-1\">TLE 使用了map</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#链表排序-2\">使用unordered_map不超时</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"链表排序-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> {</span><br><span class=\"line\">    string addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    string addr_next;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> node&amp; a) <span class=\"type\">const</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key &lt; a.key;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">map&lt;string, node&gt; hash_table;</span><br><span class=\"line\">vector&lt;node&gt; nodes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输入 删除 排序 输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    string ad;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; ad;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) {</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        string o;</span><br><span class=\"line\">        <span class=\"type\">int</span> key;</span><br><span class=\"line\">        cin &gt;&gt; s &gt;&gt; key &gt;&gt; o;</span><br><span class=\"line\">        hash_table[s] = { s,key,o };</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ad != <span class=\"string\">\"-1\"</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> top_node = hash_table[ad];</span><br><span class=\"line\">        nodes.<span class=\"built_in\">push_back</span>(top_node);</span><br><span class=\"line\">        ad = top_node.addr_next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(nodes.<span class=\"built_in\">begin</span>(),nodes.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;nodes.<span class=\"built_in\">size</span>()&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nodes.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        cout&lt;&lt;nodes[<span class=\"number\">0</span>].addr&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>{</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">\"-1\\n\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;nodes.<span class=\"built_in\">size</span>();++i) {</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> n = nodes[i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=nodes.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>){</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> next = nodes[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d %s\\n\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key, next.addr.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span>{</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d -1\\n\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>TLE了。感觉又是cin的事情。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"链表排序-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> {</span><br><span class=\"line\">    string addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    string addr_next;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> node&amp; a) <span class=\"type\">const</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key &lt; a.key;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">unordered_map&lt;string, node&gt; hash_table;</span><br><span class=\"line\">vector&lt;node&gt; nodes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输入 删除 排序 输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">char</span> c1[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">char</span> c2[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">char</span> c3[<span class=\"number\">10</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> n,key;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%s\"</span>,&amp;n,c1);</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">ad</span><span class=\"params\">(c1)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) {</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%d%s\"</span>,c2,&amp;key,c3);</span><br><span class=\"line\">        <span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(c2)</span>,<span class=\"title\">o</span><span class=\"params\">(c3)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// cin &gt;&gt; s &gt;&gt; key &gt;&gt; o;</span></span><br><span class=\"line\">        hash_table[s] = { s,key,o };</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// while (ad != \"-1\") {</span></span><br><span class=\"line\">    <span class=\"comment\">//     auto top_node = hash_table[ad];</span></span><br><span class=\"line\">    <span class=\"comment\">//     nodes.push_back(top_node);</span></span><br><span class=\"line\">    <span class=\"comment\">//     ad = top_node.addr_next;</span></span><br><span class=\"line\">    <span class=\"comment\">// }</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(string head = ad;head!=<span class=\"string\">\"-1\"</span>;head = hash_table[head].addr_next){</span><br><span class=\"line\">        nodes.<span class=\"built_in\">push_back</span>(hash_table[head]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(nodes.<span class=\"built_in\">begin</span>(),nodes.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,nodes.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nodes.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,nodes[<span class=\"number\">0</span>].addr.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    <span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;nodes.<span class=\"built_in\">size</span>();++i) {</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> n = nodes[i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=nodes.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>){</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> next = nodes[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d %s\\n\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key, next.addr.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span>{</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d -1\\n\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<p>能用scanf就用scanf，能用unordered_map就不用map。</p>\n<h3 id=\"1561-PAT-评测\"><a href=\"#1561-PAT-评测\" class=\"headerlink\" title=\"1561 PAT 评测\"></a>1561 PAT 评测</h3><p>思路：</p>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"树的遍历（重点最好记一下）\"><a href=\"#树的遍历（重点最好记一下）\" class=\"headerlink\" title=\"树的遍历（重点最好记一下）\"></a>树的遍历（重点最好记一下）</h3><ul>\n<li>给出的所有的点最多能到1百万个</li>\n<li>复杂度为<script type=\"math/tex\">O(n)</script></li>\n<li>给定的所有点的权值都是唯一的，如果不唯一那么树的形状可能不唯一。</li>\n</ul>\n<p>给定后序和中序遍历 输出层序遍历</p>\n<p>1、需要熟悉手动的中序+后续 构建树的过程、以及中序+前序构建树的过程。（在此基础上需要要知道如何快速找到中序遍历中的root下标）</p>\n<p>2、要知道本题中树是如何存储的。二叉树的存储可以简化到使用两个unordered_map 存储</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">40</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> postordered[N],inordered[N];</span><br><span class=\"line\"></span><br><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; l,r,ipost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> pl,<span class=\"type\">int</span> pr,<span class=\"type\">int</span> il,<span class=\"type\">int</span> ir)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> root  = postordered[pr];</span><br><span class=\"line\">    <span class=\"type\">int</span> k = ipost[root];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(il&lt;k){</span><br><span class=\"line\">        l[root] = <span class=\"built_in\">build</span>(pl,pl+k<span class=\"number\">-1</span>-il,il,k<span class=\"number\">-1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ir&gt;k){</span><br><span class=\"line\">        r[root] = <span class=\"built_in\">build</span>(pl+k<span class=\"number\">-1</span>-il+<span class=\"number\">1</span>,pr<span class=\"number\">-1</span>,k+<span class=\"number\">1</span>,ir);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> root)</span></span>{</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>()){</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout&lt;&lt;t&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l.<span class=\"built_in\">count</span>(t)) q.<span class=\"built_in\">push</span>(l[t]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r.<span class=\"built_in\">count</span>(t)) q.<span class=\"built_in\">push</span>(r[t]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++){</span><br><span class=\"line\">        cin&gt;&gt;postordered[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++){</span><br><span class=\"line\">        cin&gt;&gt;inordered[i];</span><br><span class=\"line\">        ipost[inordered[i]] = i;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> root = <span class=\"built_in\">build</span>(<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(root);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h3 id=\"1498-最深的根\"><a href=\"#1498-最深的根\" class=\"headerlink\" title=\"1498 最深的根\"></a>1498 最深的根</h3><p>思路：使用并查集求解给定的树是否符合要求，以及不符合要求的话有多少个连通块。（这一步主要是对merge的过程进行修改。）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/19.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 判断给出的树是不是一个连通的，如果不是求出连通分量-- 并查集</span></span><br><span class=\"line\"><span class=\"comment\">// 求最深的根：对每个点进行遍历 dfs  存储图用的邻接表需要使用简易的邻接表否则会超时。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"iostream\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"vector\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">1e4</span>+<span class=\"number\">10</span>,M=N*<span class=\"number\">2</span>;  <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"type\">int</span> h[N],e[M],ne[M],idx; <span class=\"comment\">//邻接表存稀疏树图</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,k; <span class=\"comment\">// 一共有多少个节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义并查集以及相关操作</span></span><br><span class=\"line\"><span class=\"type\">int</span> p[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> a)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p[a]!=a) p[a] = <span class=\"built_in\">find</span>(p[a]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p[a];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    e[idx]=b;</span><br><span class=\"line\">    ne[idx]=h[a];</span><br><span class=\"line\">    h[a]=idx++;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> fa = <span class=\"built_in\">find</span>(a),fb = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">    p[fa] = fb;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 定义存储树的结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// struct head{</span></span><br><span class=\"line\"><span class=\"comment\">//     vector&lt;int&gt; e;</span></span><br><span class=\"line\"><span class=\"comment\">// };</span></span><br><span class=\"line\"><span class=\"comment\">// head heads[N];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dfs</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> father)</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">// 计算当前根的最大深度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// if(heads[root].e.empty()){   // 搜索到叶子节点了；</span></span><br><span class=\"line\">    <span class=\"comment\">//     return depth;</span></span><br><span class=\"line\">    <span class=\"comment\">// }</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=h[u];~i;i=ne[i])</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"type\">int</span> j=e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j==father) <span class=\"keyword\">continue</span>; <span class=\"comment\">//重复搜了</span></span><br><span class=\"line\">        depth=<span class=\"built_in\">max</span>(depth,<span class=\"built_in\">dfs</span>(j,u)+<span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(auto x:heads[root].e){</span></span><br><span class=\"line\">    <span class=\"comment\">//     if(x==father)continue;</span></span><br><span class=\"line\">    <span class=\"comment\">//     depth = max(depth,dfs(x,root)+1);</span></span><br><span class=\"line\">    <span class=\"comment\">// }</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    k=n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;++i) p[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span> h); <span class=\"comment\">//初始化邻接表</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;++i){</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;x,&amp;y);</span><br><span class=\"line\">        <span class=\"type\">int</span> fx = <span class=\"built_in\">find</span>(x),fy = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fx!=fy){</span><br><span class=\"line\">            p[fx] = fy;</span><br><span class=\"line\">            k--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(x,y);<span class=\"built_in\">add</span>(y,x); <span class=\"comment\">//无向边加两次</span></span><br><span class=\"line\">        <span class=\"comment\">// heads[x].e.push_back(y);</span></span><br><span class=\"line\">        <span class=\"comment\">// heads[y].e.push_back(x);</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k&gt;<span class=\"number\">1</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"Error: %d components\\n\"</span>,k);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;nodes;</span><br><span class=\"line\">        <span class=\"type\">int</span> max_depth=<span class=\"number\">-1</span>; <span class=\"comment\">//设置相反界外量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"type\">int</span> depth=<span class=\"built_in\">dfs</span>(i,<span class=\"number\">-1</span>);  <span class=\"comment\">//这个节点无来源点 得到这个点的深度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(depth&gt;max_depth)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                max_depth=depth; <span class=\"comment\">//更新</span></span><br><span class=\"line\">                nodes.<span class=\"built_in\">clear</span>(); <span class=\"comment\">//清空</span></span><br><span class=\"line\">                nodes.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(depth==max_depth) nodes.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> v:nodes) cout&lt;&lt;v&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h3 id=\"判断二叉搜索树\"><a href=\"#判断二叉搜索树\" class=\"headerlink\" title=\"判断二叉搜索树\"></a>判断二叉搜索树</h3><p>问题一：如何根据二叉搜索树的先序遍历恢复树结构？</p>\n<p>二叉搜索树的中序遍历其实是已知的。这个问题其实就是根据二叉搜索树的中序和前序遍历得到二叉树。</p>\n<p>问题二：将问题转换为 上述的树的遍历后，中序遍历中节点值不唯一如何解决？</p>\n<p>由于中序遍历是一个有序数列，所以可以使用二分的方法去查找到当前前序遍历中的根节点在中序遍历中的位置</p>\n<p>问题三：如何判断不合法的情况？</p>\n<p>如果当前在中序区间中找根节点的过程中没有找到那么就返回false；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/19.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> preorder[N],postorder[N],inorder[N];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> il,<span class=\"type\">int</span> ir,<span class=\"type\">int</span> pl,<span class=\"type\">int</span> pr,<span class=\"type\">int</span> type)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">bool</span> res = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> root = preorder[pl];</span><br><span class=\"line\">    <span class=\"type\">int</span> k = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(il&gt;ir) <span class=\"keyword\">return</span> res; <span class=\"comment\">//  正常结束了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type==<span class=\"number\">0</span>){</span><br><span class=\"line\">        <span class=\"comment\">// 二分查找左边界 升序数组中</span></span><br><span class=\"line\">        <span class=\"comment\">// for (k = il; k &lt;= ir; k ++ )</span></span><br><span class=\"line\">        <span class=\"comment\">//     if (inorder[k] == root)</span></span><br><span class=\"line\">        <span class=\"comment\">//         break;</span></span><br><span class=\"line\">        <span class=\"comment\">// if (k &gt; ir) return false;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> l = il,r = ir;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (r+l)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(inorder[mid]&gt;=root)r = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inorder[l]==root) k = l;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"comment\">// 二分查找右边界 降序数组中</span></span><br><span class=\"line\">        <span class=\"comment\">// for (k = ir; k &gt;= il; k -- )</span></span><br><span class=\"line\">        <span class=\"comment\">//     if (inorder[k] == root)</span></span><br><span class=\"line\">        <span class=\"comment\">//         break;</span></span><br><span class=\"line\">        <span class=\"comment\">// if (k &lt; il) return false;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> l = il,r = ir;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (r+l+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(inorder[mid]&gt;=root) l = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inorder[l]==root) k = l;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">build</span>(il,k<span class=\"number\">-1</span>,pl+<span class=\"number\">1</span>,pl+<span class=\"number\">1</span>+(k<span class=\"number\">-1</span>-il),type)) res = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">build</span>(k+<span class=\"number\">1</span>,ir,pl+<span class=\"number\">1</span>+(k<span class=\"number\">-1</span>-il)+<span class=\"number\">1</span>,pr,type)) res = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    postorder[cnt++] = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i){</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;preorder[i]);</span><br><span class=\"line\">        inorder[i] = preorder[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(inorder,inorder+n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">build</span>(<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>)){</span><br><span class=\"line\">        <span class=\"comment\">// 这个树不是镜像并且存在  输出YES 和postorder序列</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n%d\"</span>,postorder[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;n;++i) <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,postorder[i]);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span>{</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(inorder,inorder+n);</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>; <span class=\"comment\">// 一定要注意cnt的重置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">build</span>(<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">1</span>)){</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n%d\"</span>,postorder[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;n;++i) <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,postorder[i]);</span><br><span class=\"line\">        }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1550-完全二叉搜索树\"><a href=\"#1550-完全二叉搜索树\" class=\"headerlink\" title=\"1550 完全二叉搜索树\"></a>1550 完全二叉搜索树</h3><p>对于我来说的难点：</p>\n<p>给定了每个节点的权值如何取构建一个完全二叉搜索树；</p>\n<p>如何使用数组存储树结构。</p>\n<ul>\n<li>从下标为0开始存储：</li>\n<li>从下标为一开始存储。</li>\n</ul>\n<div class=\"tabs\" id=\"1550-完全二叉搜索树\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#1550-完全二叉搜索树-1\">思路</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#1550-完全二叉搜索树-2\">1550 完全二叉搜索树 2</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"1550-完全二叉搜索树-1\"><p>通过完全二叉树的性质，可以定义二叉树的dfs边界，通过中序遍历将二叉树构建出来，并存储到一个数组中，再通过层序遍历将其输出。</p>\n<ul>\n<li>首先将节点按照从小到大的顺序排序，</li>\n<li>通过中序遍历建树</li>\n<li>直接输出存储树的数组就是中序遍历。</li>\n</ul><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"1550-完全二叉搜索树-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> w[N];</span><br><span class=\"line\"><span class=\"type\">int</span> tree[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n,cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre_order</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> r_tree = u&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> l_tree = (u&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r_tree&lt;=n)</span><br><span class=\"line\">        <span class=\"built_in\">pre_order</span>(r_tree);</span><br><span class=\"line\">    tree[u] = w[cnt++];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l_tree&lt;=n)</span><br><span class=\"line\">        <span class=\"built_in\">pre_order</span>(l_tree);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)cin&gt;&gt;w[i];</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(w,w+n);</span><br><span class=\"line\">    <span class=\"built_in\">pre_order</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;tree[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i) cout&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;tree[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"1576-再次树遍历\"><a href=\"#1576-再次树遍历\" class=\"headerlink\" title=\"1576 再次树遍历\"></a>1576 再次树遍历</h3><p>这一题和  <a href=\"https://www.acwing.com/problem/content/description/3387/\">3384. 二叉树遍历 - AcWing题 </a> 很像</p>\n<div class=\"tabs\" id=\"思路&&题解\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#思路&&题解-1\">思路</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#思路&&题解-2\">题解</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"思路&&题解-1\"><p>给出的堆栈操作是二叉树的先序遍历，可以使用先序遍历的dfs方法建树。</p>\n<ul>\n<li>可能涉及到字符串的查找判断。（可以简化，也可以省略）</li>\n</ul>\n<p>思路：</p>\n<ul>\n<li>首先根据先序遍历遍历二叉树，如果遇到pop就是回溯，</li>\n<li>然后再先序遍历过程中（由于是一个递归过程所以其中所有的节点都是存储下来的）通过后序的顺序输出每个节点的内容。</li>\n</ul>\n<p>一个重要的解题方法就是可以边先序输入边后序输出。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"思路&&题解-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preorder</span><span class=\"params\">(<span class=\"type\">int</span> root)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> w;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    cin&gt;&gt;str;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str[<span class=\"number\">1</span>]==<span class=\"string\">'u'</span>){</span><br><span class=\"line\">        <span class=\"comment\">// push 操作</span></span><br><span class=\"line\">        cin&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">preorder</span>(root*<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"built_in\">preorder</span>(root*<span class=\"number\">2</span>+<span class=\"number\">1</span>);</span><br><span class=\"line\">        cout&lt;&lt;w;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root!=<span class=\"number\">1</span>)cout&lt;&lt;<span class=\"string\">\" \"</span>;  <span class=\"comment\">//结尾不能有多余的空格。</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">preorder</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"1589-构建二叉搜索树\"><a href=\"#1589-构建二叉搜索树\" class=\"headerlink\" title=\"1589 构建二叉搜索树\"></a>1589 构建二叉搜索树</h3><div class=\"tabs\" id=\"思路&&题解\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#思路&&题解-1\">思路</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#思路&&题解-2\">题解</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"思路&&题解-1\"><p>搜索树天生就知道其中序遍历。那么这题就是给出了树的结构和中序遍历，输出层序遍历。</p>\n<p>接下来就是解决具体问题了：</p>\n<ul>\n<li>定义存储树的结构</li>\n<li>定义inorder遍历的dfs函数</li>\n<li>定义层序遍历的bfs函数。</li>\n</ul><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"思路&&题解-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">110</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> w;</span><br><span class=\"line\">    <span class=\"type\">int</span> l,r;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">node tree[N];</span><br><span class=\"line\"><span class=\"type\">int</span> v[N];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(<span class=\"type\">int</span> root)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"number\">-1</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = tree[root].l;</span><br><span class=\"line\">    <span class=\"type\">int</span> r = tree[root].r;</span><br><span class=\"line\">    <span class=\"built_in\">inorder</span>(l);</span><br><span class=\"line\">    tree[root].w = v[cnt++];</span><br><span class=\"line\">    <span class=\"built_in\">inorder</span>(r);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> root)</span></span>{</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>()){</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> front = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> l_tree = tree[front].l, r_tree = tree[front].r;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout&lt;&lt;tree[front].w&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l_tree&gt;=<span class=\"number\">0</span>) q.<span class=\"built_in\">push</span>(l_tree);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r_tree&gt;=<span class=\"number\">0</span>) q.<span class=\"built_in\">push</span>(r_tree);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">        cin&gt;&gt;tree[i].l&gt;&gt;tree[i].r;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)cin&gt;&gt;v[i];</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(v,v+n);</span><br><span class=\"line\">    <span class=\"built_in\">inorder</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"PAT甲级网站刷题记录\"><a href=\"#PAT甲级网站刷题记录\" class=\"headerlink\" title=\"PAT甲级网站刷题记录\"></a>PAT甲级网站刷题记录</h1><h2 id=\"A1046-前缀和。\"><a href=\"#A1046-前缀和。\" class=\"headerlink\" title=\"A1046 前缀和。\"></a>A1046 前缀和。</h2><h2 id=\"A1065-A-B-and-C-64bit\"><a href=\"#A1065-A-B-and-C-64bit\" class=\"headerlink\" title=\"A1065 A+B and C (64bit)\"></a>A1065 A+B and C (64bit)</h2><p>在使用longlong 类型的运算与另一个long long数据类型判断大小的时候（如下的情况）</p>\n<p>不能直接使用 (运算) 判断符号 LL这样的格式来判断</p>\n<div class=\"tabs\" id=\"longlong数据类型判断大小\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#longlong数据类型判断大小-1\">错误做法</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#longlong数据类型判断大小-2\">正确做法</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"longlong数据类型判断大小-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LL a,b,c,res;</span><br><span class=\"line\">a+b&gt;c;  <span class=\"comment\">//这样做是错误的。</span></span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"longlong数据类型判断大小-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LL a,b,c,res;</span><br><span class=\"line\">res = a+b;</span><br><span class=\"line\">res&gt;c;  <span class=\"comment\">//这样做是对的。</span></span><br></pre></td></tr></table></figure>\n<p>因为不能确定两个longlong数据类型在做加法的时候是否发生了溢出，如果发生溢出机器会自动截断，因而加法运算会在不知道哪一步停止。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h1><p>dfs的搜索顺序是一个树形的。</p>\n<p>DFS的经典运用：</p>\n<ul>\n<li>组合数问题</li>\n</ul>\n<h2 id=\"输出组合数-acwing\"><a href=\"#输出组合数-acwing\" class=\"headerlink\" title=\"输出组合数 acwing\"></a>输出组合数 acwing</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> num[N];</span><br><span class=\"line\"><span class=\"type\">int</span> res[N];</span><br><span class=\"line\"><span class=\"type\">bool</span> is_select[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print_result</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        cout&lt;&lt;res[i]&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> step)</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">// step 表示当前到哪一个位置了。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(step == n+<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"comment\">//表示已经到达最后一步了 可以输出了</span></span><br><span class=\"line\">        <span class=\"built_in\">print_result</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 在所有没有被添加进去的数字中选择一个填入</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;++i){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!is_select[i]){</span><br><span class=\"line\">            is_select[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            res[step] = i;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(step+<span class=\"number\">1</span>);</span><br><span class=\"line\">            is_select[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"PAT甲级中的DFS题目\"><a href=\"#PAT甲级中的DFS题目\" class=\"headerlink\" title=\"PAT甲级中的DFS题目\"></a>PAT甲级中的DFS题目</h2><ul>\n<li>A1004</li>\n</ul>\n<h1 id=\"一些c-的性质的记录（我记不住所以记一下）\"><a href=\"#一些c-的性质的记录（我记不住所以记一下）\" class=\"headerlink\" title=\"一些c++ 的性质的记录（我记不住所以记一下）\"></a>一些c++ 的性质的记录（我记不住所以记一下）</h1><h2 id=\"c-在函数声明后面有const\"><a href=\"#c-在函数声明后面有const\" class=\"headerlink\" title=\"c++在函数声明后面有const\"></a>c++在函数声明后面有const</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> T &amp;a) <span class=\"type\">const</span> {...}</span><br></pre></td></tr></table></figure>\n<p><strong>已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理</strong></p>\n<p>该函数内部不能修改成员变量的值。</p>\n<h2 id=\"遇到需要使用效率更高的输入scanf-输入-printf-输出一行内含有string和in的混合类型。\"><a href=\"#遇到需要使用效率更高的输入scanf-输入-printf-输出一行内含有string和in的混合类型。\" class=\"headerlink\" title=\"遇到需要使用效率更高的输入scanf 输入\\printf 输出一行内含有string和in的混合类型。\"></a>遇到需要使用效率更高的输入scanf 输入\\printf 输出一行内含有string和in的混合类型。</h2><p>一种可行的方法是resize string的大小，这种方法使用的前提是你得知道这个待输入的string有多大。然后如下使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">\tstring a;</span><br><span class=\"line\">\tstring b;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">\ta.<span class=\"built_in\">resize</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\tb.<span class=\"built_in\">resize</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,&amp;a[<span class=\"number\">0</span>],&amp;b[<span class=\"number\">0</span>],&amp;c);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a: %s b: %s c: %d\\n\"</span>,a.<span class=\"built_in\">c_str</span>(),b.<span class=\"built_in\">c_str</span>(),c);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>输出的时候要转换为c_str()。</p>\n<h2 id=\"字符串的比较失效问题\"><a href=\"#字符串的比较失效问题\" class=\"headerlink\" title=\"字符串的比较失效问题\"></a>字符串的比较失效问题</h2><div class=\"tabs\" id=\"字符串比较失效\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#字符串比较失效-1\">最原始的场景</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#字符串比较失效-2\">其实是</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"字符串比较失效-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Nino Neumann on 2023/4/1.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> {</span><br><span class=\"line\">    string addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    string addr_next;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> node&amp; a) <span class=\"type\">const</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key &lt; a.key;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">map&lt;string, node&gt; hash_table;</span><br><span class=\"line\">vector&lt;node&gt; nodes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输入 删除 排序 输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    string ad;</span><br><span class=\"line\">    ad.<span class=\"built_in\">resize</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%s\"</span>, &amp;n, &amp;ad[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) {</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        string o;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">        o.<span class=\"built_in\">resize</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> key;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%d%s\"</span>, &amp;s[<span class=\"number\">0</span>], &amp;key, &amp;o[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        hash_table[s] = { s,key,o };</span><br><span class=\"line\">        <span class=\"comment\">//        nodes.push_back({s,key,o});</span></span><br><span class=\"line\">                <span class=\"comment\">// if(o==\"-1\")cout&lt;&lt;\"yes\\n\"&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"string\">\"-1\"</span>)cout &lt;&lt; <span class=\"string\">\"yes\\n\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//    if(nodes)</span></span><br><span class=\"line\">    <span class=\"comment\">// string current_addr = ad;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;(hash_table[\"11111\"].addr_next==\"22222\")&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// 下面的while循环部分失效 导致死循环 string之间的比较失效。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ad != <span class=\"string\">\"-1\"</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> top_node = hash_table[ad];</span><br><span class=\"line\">        nodes.<span class=\"built_in\">push_back</span>(top_node);</span><br><span class=\"line\">        ad = top_node.addr_next;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;\"-1\"&lt;&lt;endl;</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//     sort(nodes.begin(),nodes.end());</span></span><br><span class=\"line\">    <span class=\"comment\">// //    cout&lt;&lt;nodes.size()&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">//     printf(\"%d %s\",nodes.size(),nodes[0].addr.c_str());</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> n : nodes) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d %s\"</span>, n.addr.<span class=\"built_in\">c_str</span>(), n.key, n.addr_next.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"字符串比较失效-2\"><p>sanf 读入字符串的原因，导致比较失效了。不建议使用scanf读入string 类型的数据。</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"关于二分找边界：\"><a href=\"#关于二分找边界：\" class=\"headerlink\" title=\"关于二分找边界：\"></a>关于二分找边界：</h1><p>暂时没弄明白，先记着。</p>\n<div class=\"tabs\" id=\"二分找边界问题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#二分找边界问题-1\">基本的二分模板</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#二分找边界问题-2\">找有序数组中的某一个数的左边界</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#二分找边界问题-3\">找有序数组中的某一个数的右边界</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"二分找边界问题-1\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bs</span><span class=\"params\">(<span class=\"type\">int</span> q[],<span class=\"type\">int</span> t)</span></span>{</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">0</span>,r = n<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q[mid]&lt;t) l = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q[l]!=t) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> q[l];</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"二分找边界问题-2\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bs_left</span><span class=\"params\">(<span class=\"type\">int</span> nums[],<span class=\"type\">int</span> t)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> r = n<span class=\"number\">-1</span>,l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]&gt;=t) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;\"targ: \"&lt;&lt;t&lt;&lt;\" left:\"&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[l]==t) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"二分找边界问题-3\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bs_right</span><span class=\"params\">(<span class=\"type\">int</span> nums[],<span class=\"type\">int</span> t)</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> r = n<span class=\"number\">-1</span>,l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;r){</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]&lt;=t) l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;\"targ: \"&lt;&lt;t&lt;&lt;\" right:\"&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[l]==t) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n"},{"title":"考研二战-DS整理复习","copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-03-30T06:53:21.000Z","updated":"2023-03-30T06:53:21.000Z","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/86446119_p0.png","_content":"\n\n\n\n\n{% timeline 2023,blue %}\n\n<!-- timeline 04-01 -->\nDS第一章节绪论部分。\n<!-- endtimeline -->\n\n<!-- timeline 04-02 -->\nDS第一章节绪论部分。\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n\n\n[toc]\n\n\n\n# DS再复习\n\n# 第一章\n\n## 绪论部分的基本概念\n\n- 数据：一个很宽泛的概念 他是数据元素的集合\n- 数据元素：组成数据的基本元素。通常作为一个整体考虑。用来表示一个对象，例如学生数据中 的一条学生信息（包含id，姓名……）\n- 数据项：组成数据元素的最小不可分割单元。不可分割是逻辑意义上的，例如上述学生数据中的基本组成就是 id 姓名…… 这些单独拿出来就是一个数据项。\n- 数据对象：数据的一个子集，由多个数据元素组成。是具有相同性质的数据元素的集合（这里的相同性质的解释如下：例如整数集合，也就是组成该数据对象的数据元素都是整数；或者混合类型：例如上述的学生信息表，但是组成整个数据对象的数据元素的“类型”都是一样的）\n- 数据类型：一个值的==集合==以及定义在这个集合上的==一系列操作==。\n- 数据结构：相互之间存在==一种或多种关系的数据元素的集合== 数据的“结构”就是这里的数据元素之间的关系。\n  - 逻辑结构：从逻辑关系上描述数据，是从具体问题中抽象出来的数学模型。  通常有四类：集合、线性、树、图结构\n\n{% tabs 逻辑结构图 %}\n<!-- tab -->\n\n{% mermaid %}\ngraph TD\n逻辑结构-->线性结构\n逻辑结构-->非线性结构\n线性结构-->一般线性表\n线性结构-->特殊线性表\n线性结构-->线性表的推广\n非线性结构-->树结构\n非线性结构-->图结构\n非线性结构-->集合\n树结构-->树\n树结构-->二叉树\n图结构-->有向图\n图结构-->无向图\n一般线性表-->线性表\n线性表-->顺序存储:顺序表\n线性表-->随机存储:链表\n\n特殊线性表-->栈与队列\n特殊线性表-->字符串\n线性表的推广-->广义表\n线性表的推广-->数组\n{% endmermaid %}\n\n<!-- endtab -->\n\n<!-- tab -->\n\nmarkdown mermaid 代码部分\n\n```mermaid\ngraph TD\n逻辑结构-->线性结构\n逻辑结构-->非线性结构\n线性结构-->一般线性表\n线性结构-->特殊线性表\n线性结构-->线性表的推广\n非线性结构-->树结构\n非线性结构-->图结构\n非线性结构-->集合\n树结构-->树\n树结构-->二叉树\n图结构-->有向图\n图结构-->无向图\n一般线性表-->线性表\n线性表-->顺序存储:顺序表\n线性表-->随机存储:链表\n\n特殊线性表-->栈与队列\n特殊线性表-->字符串\n线性表的推广-->广义表\n线性表的推广-->数组\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n- 物理结构:  ==数据对象==在计算机中的==存储表示==。（）\n  - 通常有两种结构：顺序存储和链式存储。（严书第二版只提到两种存储结构，其实是四种。）\n\n\n\n{% tabs 物理结构图 %}\n<!-- tab -->\n\n{% mermaid %}\ngraph TD\n\n存储结构-->顺序存储\n存储结构-->随机存储\n随机存储-->链式存储\n随机存储-->索引存储\n随机存储-->散列存储Hash\n\n{% endmermaid %}\n\n<!-- endtab -->\n\n<!-- tab -->\n\n```mermaid\ngraph TD\n存储结构-->顺序存储\n存储结构-->随机存储\n随机存储-->链式存储\n随机存储-->索引存储\n随机存储-->散列存储Hash\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n一个表示 数据、数据元素、数据项、数据对象之间的关系的图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618173532304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMxNjU3ODg5,size_16,color_FFFFFF,t_70)\n\n### 存储结构\\存取结构\n\n- 存取结构\n  - 随机存取, 重点在\"取\"上,指访问指定单元的速度与其位置无关,\n  - 非随机存取(顺序存取): 取第i个位置上的元素必须遍历前面的i-1个元素,  链表\n- 存储结构,如上 四种\n  - 顺序存储:  指的是计算机开辟一个连续的空间来存储他们.重点在于物理上的存储空间的\"开辟\".\n  - 随机存储: 不是开辟一段连续的物理空间.\n    - 索引存储\n    - 散列存储\n    - 链式存储\n\n存取结构描述的是啥?\n\n存储结构是数据结构中的一个重要的组成\n\n\n\n## 算法和算法分析 \n\n### 算法的定义和要求\n\n定义：是为了解决某一问题而设计的一系列的（有穷）有限长度的操作（步骤）序列。\n\n一个合格的算法应该具备下列的性质：\n\n- 有穷性\n- 确定性：算法过程中遇到的所有情况都有特定的解决方案，==不会产生二义性==\n- 可行性：可以由已经定义的所有基本操作实现。\n- 输入：有0个或者多个输入。\n- 输出：有一个或者多个输出。\n\n### 评价算法的指标\n\n- 可读性\n- 高效性\n- 健壮性\n- 正确性\n\n### 时间复杂度和空间复杂度\n\n- 问题规模：算法输入量的大小，输入规模的大小\n- 语句频度：一条语句执行的次数\n\n算法的效率分析并不是单纯的计算程序从编译到执行所用的所有时间，而是计算程序中所有的语句频度之和而得出的一个估计。\n\n因而一个算法的执行时间可以用该算法内部所有的语句频度之和来表示。\n\n#### 时间复杂度\n\n衡量一个算法的时间复杂度用其基本语句的执行频度。（基本语句：指的是其在算法中执行次数与算法的运行时间成正比的语句）从而得出算法的运行时间的函数$$f(n)$$ 而程序的时间复杂度记为$$T(n) = O(f(n))$$ 其定义是:\n$$\nT(n)和f(n)都是定义在正整数上的函数，则T(n) = O(f(n))的含义是，存在正整数C \\ 当 \\ n\\ge n_{0} \\ 时0 \\ \\le T(n) \\le Cf(n)\n$$\n故O的含义是当输入规模趋近于无穷的时候问题的执行时间的上限不会超过$$f(n)$$ （定义了算法执行时间的上限）。\n\n- 最好时间复杂度、最坏时间复杂度、平均时间复杂度。\n\n这个和概率相关。后面的实例会遇到。\n\n### 普通循环结构的时间复杂度的分析\n\n```\nfor(int i = 0;i<n;++i){\n\toperate();\n}\n```\n\n## 第一章小结\n\n- 弄清楚考察重点在哪：时间复杂度和空间复杂度的估计。\n  - 递归函数的时间复杂度计算。\n  - 某些特定算法的时间复杂度  例如 2013年的题目：\n- 构建起对后面将要学习的内容的一个框架。\n\n### 2013年计算时间复杂度的题目个人理解\n\n需要用到时间复杂度的[定义](####时间复杂度)，可以粗略计算出当前的相对准确的语句频度，然后在选项中找到其乘以一个系数一定大于这个频度的$$f(x)$$\n\n2013统考的这道题目的正确解法：\n\n先想出最坏的情况：连续上升元素交替出现在两个链表中。故最坏的频度是m+n 又$$2max(m,n) \\ge m+n$$ 所以根据时间复杂度的定义\n$$\nT(n) = O(f(x)) \\rightarrow \\ 0 \\le T(n) \\le Cf(x)\n$$\n只有答案 $$O(max(m,n))$$ 符合定义。\n\n时间复杂度的计算中三次连续的求和的最终值为$$T(n)=O\\left(\\sum_{i=1}^n \\sum_{j=1}^i \\sum_{k=1}^j 1\\right)=O\\left(\\frac{1}{6} n^3\\right)=O\\left(n^3\\right) 。$$\n\n\n\n\n\n# 线性表\n\n个人感觉，这一章没啥好讲的，线性表的存储。重点在于最后的线性表的应用相关的算法。\n\n## 线性表的定义[^1]\n\n由n个数据特性相同的元素构成的有限序列称为线性表；n为其线性表的长度。\n\n一个非空的线性表或者线性结构具有以下特点：\n\n- 存在唯一一个头\n- 存在唯一一个尾\n- 除尾元素外，每个元素都有一个直接后继\n- 除头元素外，每个元素都有一个直接前驱。\n\n## 线性表的顺序存储表示（也称作：顺序表）\n\n特点：逻辑上相邻的数据元素其物理次序也是相邻的。\n\n## 线性表的链式存储表示(链表)\n\n### 单链表\n\n- 头插\n- 尾插\n- 插入\n- 删除\n\n### 双链表\n\n### 循环链表\n\n判空条件\n\n### 双循环链表\n\n判空条件\n\n\n\n# 王道课后习题速查\n\n## 第二章线性表\n\n### 2.1 线性表的定义和基本操作\n\n1. c\n2. b\n3. a \n\n### 2.2  线性表的顺序表示\n\n1. A   (D 存疑)\n\n2. A   (存储结构.)\n\n3. B\n\n4. ==B  --正解- >D==  :存取操作--插入删除操作\n\n   > 随机存取\\顺序存取   顺序存储\\随机存储(上面有介绍)\n   >\n   > 本题的重点在于存取操作,而不是插入删除操作.  需要明确对于顺序表来说,插入&删除操作所需要的时间复杂度高.\n\n5. A\n\n6. C\n\n7. C\n\n8. C\n\n9. C\n\n10. B\n\n11. D\n\n### 2.3线性表的链式表示\n\n\n\n# 学习过程中发现模糊的点\n\n## 程序从编译到执行的过程。\n\n# 计组中的边界对齐\n\n\n\n\n\n[^1]: 数据结构 C语言版 （第二版）（严蔚敏、李冬梅、吴伟民）\n","source":"_posts/考研二战-DS整理复习.md","raw":"---\ntitle: 考研二战-DS整理复习\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-03-30 14:53:21\nupdated: 2023-03-30 14:53:21\ntags:\n- 考研\n- DS\n- 二战\n- 复习\ncategories: 一个计科生的考研二战日记\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/86446119_p0.png\n---\n\n\n\n\n\n{% timeline 2023,blue %}\n\n<!-- timeline 04-01 -->\nDS第一章节绪论部分。\n<!-- endtimeline -->\n\n<!-- timeline 04-02 -->\nDS第一章节绪论部分。\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n\n\n[toc]\n\n\n\n# DS再复习\n\n# 第一章\n\n## 绪论部分的基本概念\n\n- 数据：一个很宽泛的概念 他是数据元素的集合\n- 数据元素：组成数据的基本元素。通常作为一个整体考虑。用来表示一个对象，例如学生数据中 的一条学生信息（包含id，姓名……）\n- 数据项：组成数据元素的最小不可分割单元。不可分割是逻辑意义上的，例如上述学生数据中的基本组成就是 id 姓名…… 这些单独拿出来就是一个数据项。\n- 数据对象：数据的一个子集，由多个数据元素组成。是具有相同性质的数据元素的集合（这里的相同性质的解释如下：例如整数集合，也就是组成该数据对象的数据元素都是整数；或者混合类型：例如上述的学生信息表，但是组成整个数据对象的数据元素的“类型”都是一样的）\n- 数据类型：一个值的==集合==以及定义在这个集合上的==一系列操作==。\n- 数据结构：相互之间存在==一种或多种关系的数据元素的集合== 数据的“结构”就是这里的数据元素之间的关系。\n  - 逻辑结构：从逻辑关系上描述数据，是从具体问题中抽象出来的数学模型。  通常有四类：集合、线性、树、图结构\n\n{% tabs 逻辑结构图 %}\n<!-- tab -->\n\n{% mermaid %}\ngraph TD\n逻辑结构-->线性结构\n逻辑结构-->非线性结构\n线性结构-->一般线性表\n线性结构-->特殊线性表\n线性结构-->线性表的推广\n非线性结构-->树结构\n非线性结构-->图结构\n非线性结构-->集合\n树结构-->树\n树结构-->二叉树\n图结构-->有向图\n图结构-->无向图\n一般线性表-->线性表\n线性表-->顺序存储:顺序表\n线性表-->随机存储:链表\n\n特殊线性表-->栈与队列\n特殊线性表-->字符串\n线性表的推广-->广义表\n线性表的推广-->数组\n{% endmermaid %}\n\n<!-- endtab -->\n\n<!-- tab -->\n\nmarkdown mermaid 代码部分\n\n```mermaid\ngraph TD\n逻辑结构-->线性结构\n逻辑结构-->非线性结构\n线性结构-->一般线性表\n线性结构-->特殊线性表\n线性结构-->线性表的推广\n非线性结构-->树结构\n非线性结构-->图结构\n非线性结构-->集合\n树结构-->树\n树结构-->二叉树\n图结构-->有向图\n图结构-->无向图\n一般线性表-->线性表\n线性表-->顺序存储:顺序表\n线性表-->随机存储:链表\n\n特殊线性表-->栈与队列\n特殊线性表-->字符串\n线性表的推广-->广义表\n线性表的推广-->数组\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n- 物理结构:  ==数据对象==在计算机中的==存储表示==。（）\n  - 通常有两种结构：顺序存储和链式存储。（严书第二版只提到两种存储结构，其实是四种。）\n\n\n\n{% tabs 物理结构图 %}\n<!-- tab -->\n\n{% mermaid %}\ngraph TD\n\n存储结构-->顺序存储\n存储结构-->随机存储\n随机存储-->链式存储\n随机存储-->索引存储\n随机存储-->散列存储Hash\n\n{% endmermaid %}\n\n<!-- endtab -->\n\n<!-- tab -->\n\n```mermaid\ngraph TD\n存储结构-->顺序存储\n存储结构-->随机存储\n随机存储-->链式存储\n随机存储-->索引存储\n随机存储-->散列存储Hash\n```\n\n<!-- endtab -->\n{% endtabs %}\n\n一个表示 数据、数据元素、数据项、数据对象之间的关系的图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618173532304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMxNjU3ODg5,size_16,color_FFFFFF,t_70)\n\n### 存储结构\\存取结构\n\n- 存取结构\n  - 随机存取, 重点在\"取\"上,指访问指定单元的速度与其位置无关,\n  - 非随机存取(顺序存取): 取第i个位置上的元素必须遍历前面的i-1个元素,  链表\n- 存储结构,如上 四种\n  - 顺序存储:  指的是计算机开辟一个连续的空间来存储他们.重点在于物理上的存储空间的\"开辟\".\n  - 随机存储: 不是开辟一段连续的物理空间.\n    - 索引存储\n    - 散列存储\n    - 链式存储\n\n存取结构描述的是啥?\n\n存储结构是数据结构中的一个重要的组成\n\n\n\n## 算法和算法分析 \n\n### 算法的定义和要求\n\n定义：是为了解决某一问题而设计的一系列的（有穷）有限长度的操作（步骤）序列。\n\n一个合格的算法应该具备下列的性质：\n\n- 有穷性\n- 确定性：算法过程中遇到的所有情况都有特定的解决方案，==不会产生二义性==\n- 可行性：可以由已经定义的所有基本操作实现。\n- 输入：有0个或者多个输入。\n- 输出：有一个或者多个输出。\n\n### 评价算法的指标\n\n- 可读性\n- 高效性\n- 健壮性\n- 正确性\n\n### 时间复杂度和空间复杂度\n\n- 问题规模：算法输入量的大小，输入规模的大小\n- 语句频度：一条语句执行的次数\n\n算法的效率分析并不是单纯的计算程序从编译到执行所用的所有时间，而是计算程序中所有的语句频度之和而得出的一个估计。\n\n因而一个算法的执行时间可以用该算法内部所有的语句频度之和来表示。\n\n#### 时间复杂度\n\n衡量一个算法的时间复杂度用其基本语句的执行频度。（基本语句：指的是其在算法中执行次数与算法的运行时间成正比的语句）从而得出算法的运行时间的函数$$f(n)$$ 而程序的时间复杂度记为$$T(n) = O(f(n))$$ 其定义是:\n$$\nT(n)和f(n)都是定义在正整数上的函数，则T(n) = O(f(n))的含义是，存在正整数C \\ 当 \\ n\\ge n_{0} \\ 时0 \\ \\le T(n) \\le Cf(n)\n$$\n故O的含义是当输入规模趋近于无穷的时候问题的执行时间的上限不会超过$$f(n)$$ （定义了算法执行时间的上限）。\n\n- 最好时间复杂度、最坏时间复杂度、平均时间复杂度。\n\n这个和概率相关。后面的实例会遇到。\n\n### 普通循环结构的时间复杂度的分析\n\n```\nfor(int i = 0;i<n;++i){\n\toperate();\n}\n```\n\n## 第一章小结\n\n- 弄清楚考察重点在哪：时间复杂度和空间复杂度的估计。\n  - 递归函数的时间复杂度计算。\n  - 某些特定算法的时间复杂度  例如 2013年的题目：\n- 构建起对后面将要学习的内容的一个框架。\n\n### 2013年计算时间复杂度的题目个人理解\n\n需要用到时间复杂度的[定义](####时间复杂度)，可以粗略计算出当前的相对准确的语句频度，然后在选项中找到其乘以一个系数一定大于这个频度的$$f(x)$$\n\n2013统考的这道题目的正确解法：\n\n先想出最坏的情况：连续上升元素交替出现在两个链表中。故最坏的频度是m+n 又$$2max(m,n) \\ge m+n$$ 所以根据时间复杂度的定义\n$$\nT(n) = O(f(x)) \\rightarrow \\ 0 \\le T(n) \\le Cf(x)\n$$\n只有答案 $$O(max(m,n))$$ 符合定义。\n\n时间复杂度的计算中三次连续的求和的最终值为$$T(n)=O\\left(\\sum_{i=1}^n \\sum_{j=1}^i \\sum_{k=1}^j 1\\right)=O\\left(\\frac{1}{6} n^3\\right)=O\\left(n^3\\right) 。$$\n\n\n\n\n\n# 线性表\n\n个人感觉，这一章没啥好讲的，线性表的存储。重点在于最后的线性表的应用相关的算法。\n\n## 线性表的定义[^1]\n\n由n个数据特性相同的元素构成的有限序列称为线性表；n为其线性表的长度。\n\n一个非空的线性表或者线性结构具有以下特点：\n\n- 存在唯一一个头\n- 存在唯一一个尾\n- 除尾元素外，每个元素都有一个直接后继\n- 除头元素外，每个元素都有一个直接前驱。\n\n## 线性表的顺序存储表示（也称作：顺序表）\n\n特点：逻辑上相邻的数据元素其物理次序也是相邻的。\n\n## 线性表的链式存储表示(链表)\n\n### 单链表\n\n- 头插\n- 尾插\n- 插入\n- 删除\n\n### 双链表\n\n### 循环链表\n\n判空条件\n\n### 双循环链表\n\n判空条件\n\n\n\n# 王道课后习题速查\n\n## 第二章线性表\n\n### 2.1 线性表的定义和基本操作\n\n1. c\n2. b\n3. a \n\n### 2.2  线性表的顺序表示\n\n1. A   (D 存疑)\n\n2. A   (存储结构.)\n\n3. B\n\n4. ==B  --正解- >D==  :存取操作--插入删除操作\n\n   > 随机存取\\顺序存取   顺序存储\\随机存储(上面有介绍)\n   >\n   > 本题的重点在于存取操作,而不是插入删除操作.  需要明确对于顺序表来说,插入&删除操作所需要的时间复杂度高.\n\n5. A\n\n6. C\n\n7. C\n\n8. C\n\n9. C\n\n10. B\n\n11. D\n\n### 2.3线性表的链式表示\n\n\n\n# 学习过程中发现模糊的点\n\n## 程序从编译到执行的过程。\n\n# 计组中的边界对齐\n\n\n\n\n\n[^1]: 数据结构 C语言版 （第二版）（严蔚敏、李冬梅、吴伟民）\n","slug":"考研二战-DS整理复习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwm9000dbsuoc3bee1sh","content":"<div class=\"timeline blue\"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p>\n</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-01</p>\n</div></div><div class='timeline-item-content'><p>DS第一章节绪论部分。</p>\n</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-02</p>\n</div></div><div class='timeline-item-content'><p>DS第一章节绪论部分。</p>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"DS再复习\"><a href=\"#DS再复习\" class=\"headerlink\" title=\"DS再复习\"></a>DS再复习</h1><h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"绪论部分的基本概念\"><a href=\"#绪论部分的基本概念\" class=\"headerlink\" title=\"绪论部分的基本概念\"></a>绪论部分的基本概念</h2><ul>\n<li>数据：一个很宽泛的概念 他是数据元素的集合</li>\n<li>数据元素：组成数据的基本元素。通常作为一个整体考虑。用来表示一个对象，例如学生数据中 的一条学生信息（包含id，姓名……）</li>\n<li>数据项：组成数据元素的最小不可分割单元。不可分割是逻辑意义上的，例如上述学生数据中的基本组成就是 id 姓名…… 这些单独拿出来就是一个数据项。</li>\n<li>数据对象：数据的一个子集，由多个数据元素组成。是具有相同性质的数据元素的集合（这里的相同性质的解释如下：例如整数集合，也就是组成该数据对象的数据元素都是整数；或者混合类型：例如上述的学生信息表，但是组成整个数据对象的数据元素的“类型”都是一样的）</li>\n<li>数据类型：一个值的==集合==以及定义在这个集合上的==一系列操作==。</li>\n<li>数据结构：相互之间存在==一种或多种关系的数据元素的集合== 数据的“结构”就是这里的数据元素之间的关系。<ul>\n<li>逻辑结构：从逻辑关系上描述数据，是从具体问题中抽象出来的数学模型。  通常有四类：集合、线性、树、图结构</li>\n</ul>\n</li>\n</ul>\n<div class=\"tabs\" id=\"逻辑结构图\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#逻辑结构图-1\">逻辑结构图 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#逻辑结构图-2\">逻辑结构图 2</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"逻辑结构图-1\"><div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n逻辑结构--&gt;线性结构\n逻辑结构--&gt;非线性结构\n线性结构--&gt;一般线性表\n线性结构--&gt;特殊线性表\n线性结构--&gt;线性表的推广\n非线性结构--&gt;树结构\n非线性结构--&gt;图结构\n非线性结构--&gt;集合\n树结构--&gt;树\n树结构--&gt;二叉树\n图结构--&gt;有向图\n图结构--&gt;无向图\n一般线性表--&gt;线性表\n线性表--&gt;顺序存储:顺序表\n线性表--&gt;随机存储:链表\n\n特殊线性表--&gt;栈与队列\n特殊线性表--&gt;字符串\n线性表的推广--&gt;广义表\n线性表的推广--&gt;数组\n  </pre></div><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"逻辑结构图-2\"><p>markdown mermaid 代码部分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">逻辑结构--&gt;线性结构</span><br><span class=\"line\">逻辑结构--&gt;非线性结构</span><br><span class=\"line\">线性结构--&gt;一般线性表</span><br><span class=\"line\">线性结构--&gt;特殊线性表</span><br><span class=\"line\">线性结构--&gt;线性表的推广</span><br><span class=\"line\">非线性结构--&gt;树结构</span><br><span class=\"line\">非线性结构--&gt;图结构</span><br><span class=\"line\">非线性结构--&gt;集合</span><br><span class=\"line\">树结构--&gt;树</span><br><span class=\"line\">树结构--&gt;二叉树</span><br><span class=\"line\">图结构--&gt;有向图</span><br><span class=\"line\">图结构--&gt;无向图</span><br><span class=\"line\">一般线性表--&gt;线性表</span><br><span class=\"line\">线性表--&gt;顺序存储:顺序表</span><br><span class=\"line\">线性表--&gt;随机存储:链表</span><br><span class=\"line\"></span><br><span class=\"line\">特殊线性表--&gt;栈与队列</span><br><span class=\"line\">特殊线性表--&gt;字符串</span><br><span class=\"line\">线性表的推广--&gt;广义表</span><br><span class=\"line\">线性表的推广--&gt;数组</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<ul>\n<li>物理结构:  ==数据对象==在计算机中的==存储表示==。（）<ul>\n<li>通常有两种结构：顺序存储和链式存储。（严书第二版只提到两种存储结构，其实是四种。）</li>\n</ul>\n</li>\n</ul>\n<div class=\"tabs\" id=\"物理结构图\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#物理结构图-1\">物理结构图 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#物理结构图-2\">物理结构图 2</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"物理结构图-1\"><div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\n存储结构--&gt;顺序存储\n存储结构--&gt;随机存储\n随机存储--&gt;链式存储\n随机存储--&gt;索引存储\n随机存储--&gt;散列存储Hash\n\n  </pre></div><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"物理结构图-2\"><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">存储结构--&gt;顺序存储</span><br><span class=\"line\">存储结构--&gt;随机存储</span><br><span class=\"line\">随机存储--&gt;链式存储</span><br><span class=\"line\">随机存储--&gt;索引存储</span><br><span class=\"line\">随机存储--&gt;散列存储Hash</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<p>一个表示 数据、数据元素、数据项、数据对象之间的关系的图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190618173532304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMxNjU3ODg5,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"存储结构-存取结构\"><a href=\"#存储结构-存取结构\" class=\"headerlink\" title=\"存储结构\\存取结构\"></a>存储结构\\存取结构</h3><ul>\n<li>存取结构<ul>\n<li>随机存取, 重点在”取”上,指访问指定单元的速度与其位置无关,</li>\n<li>非随机存取(顺序存取): 取第i个位置上的元素必须遍历前面的i-1个元素,  链表</li>\n</ul>\n</li>\n<li>存储结构,如上 四种<ul>\n<li>顺序存储:  指的是计算机开辟一个连续的空间来存储他们.重点在于物理上的存储空间的”开辟”.</li>\n<li>随机存储: 不是开辟一段连续的物理空间.<ul>\n<li>索引存储</li>\n<li>散列存储</li>\n<li>链式存储</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>存取结构描述的是啥?</p>\n<p>存储结构是数据结构中的一个重要的组成</p>\n<h2 id=\"算法和算法分析\"><a href=\"#算法和算法分析\" class=\"headerlink\" title=\"算法和算法分析\"></a>算法和算法分析</h2><h3 id=\"算法的定义和要求\"><a href=\"#算法的定义和要求\" class=\"headerlink\" title=\"算法的定义和要求\"></a>算法的定义和要求</h3><p>定义：是为了解决某一问题而设计的一系列的（有穷）有限长度的操作（步骤）序列。</p>\n<p>一个合格的算法应该具备下列的性质：</p>\n<ul>\n<li>有穷性</li>\n<li>确定性：算法过程中遇到的所有情况都有特定的解决方案，==不会产生二义性==</li>\n<li>可行性：可以由已经定义的所有基本操作实现。</li>\n<li>输入：有0个或者多个输入。</li>\n<li>输出：有一个或者多个输出。</li>\n</ul>\n<h3 id=\"评价算法的指标\"><a href=\"#评价算法的指标\" class=\"headerlink\" title=\"评价算法的指标\"></a>评价算法的指标</h3><ul>\n<li>可读性</li>\n<li>高效性</li>\n<li>健壮性</li>\n<li>正确性</li>\n</ul>\n<h3 id=\"时间复杂度和空间复杂度\"><a href=\"#时间复杂度和空间复杂度\" class=\"headerlink\" title=\"时间复杂度和空间复杂度\"></a>时间复杂度和空间复杂度</h3><ul>\n<li>问题规模：算法输入量的大小，输入规模的大小</li>\n<li>语句频度：一条语句执行的次数</li>\n</ul>\n<p>算法的效率分析并不是单纯的计算程序从编译到执行所用的所有时间，而是计算程序中所有的语句频度之和而得出的一个估计。</p>\n<p>因而一个算法的执行时间可以用该算法内部所有的语句频度之和来表示。</p>\n<h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>衡量一个算法的时间复杂度用其基本语句的执行频度。（基本语句：指的是其在算法中执行次数与算法的运行时间成正比的语句）从而得出算法的运行时间的函数<script type=\"math/tex\">f(n)</script> 而程序的时间复杂度记为<script type=\"math/tex\">T(n) = O(f(n))</script> 其定义是:</p>\n<script type=\"math/tex; mode=display\">\nT(n)和f(n)都是定义在正整数上的函数，则T(n) = O(f(n))的含义是，存在正整数C \\ 当 \\ n\\ge n_{0} \\ 时0 \\ \\le T(n) \\le Cf(n)</script><p>故O的含义是当输入规模趋近于无穷的时候问题的执行时间的上限不会超过<script type=\"math/tex\">f(n)</script> （定义了算法执行时间的上限）。</p>\n<ul>\n<li>最好时间复杂度、最坏时间复杂度、平均时间复杂度。</li>\n</ul>\n<p>这个和概率相关。后面的实例会遇到。</p>\n<h3 id=\"普通循环结构的时间复杂度的分析\"><a href=\"#普通循环结构的时间复杂度的分析\" class=\"headerlink\" title=\"普通循环结构的时间复杂度的分析\"></a>普通循环结构的时间复杂度的分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i = 0;i&lt;n;++i)&#123;</span><br><span class=\"line\">\toperate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第一章小结\"><a href=\"#第一章小结\" class=\"headerlink\" title=\"第一章小结\"></a>第一章小结</h2><ul>\n<li>弄清楚考察重点在哪：时间复杂度和空间复杂度的估计。<ul>\n<li>递归函数的时间复杂度计算。</li>\n<li>某些特定算法的时间复杂度  例如 2013年的题目：</li>\n</ul>\n</li>\n<li>构建起对后面将要学习的内容的一个框架。</li>\n</ul>\n<h3 id=\"2013年计算时间复杂度的题目个人理解\"><a href=\"#2013年计算时间复杂度的题目个人理解\" class=\"headerlink\" title=\"2013年计算时间复杂度的题目个人理解\"></a>2013年计算时间复杂度的题目个人理解</h3><p>需要用到时间复杂度的<a href=\"####时间复杂度\">定义</a>，可以粗略计算出当前的相对准确的语句频度，然后在选项中找到其乘以一个系数一定大于这个频度的<script type=\"math/tex\">f(x)</script></p>\n<p>2013统考的这道题目的正确解法：</p>\n<p>先想出最坏的情况：连续上升元素交替出现在两个链表中。故最坏的频度是m+n 又<script type=\"math/tex\">2max(m,n) \\ge m+n</script> 所以根据时间复杂度的定义</p>\n<script type=\"math/tex; mode=display\">\nT(n) = O(f(x)) \\rightarrow \\ 0 \\le T(n) \\le Cf(x)</script><p>只有答案 <script type=\"math/tex\">O(max(m,n))</script> 符合定义。</p>\n<p>时间复杂度的计算中三次连续的求和的最终值为<script type=\"math/tex\">T(n)=O\\left(\\sum_{i=1}^n \\sum_{j=1}^i \\sum_{k=1}^j 1\\right)=O\\left(\\frac{1}{6} n^3\\right)=O\\left(n^3\\right) 。</script></p>\n<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><p>个人感觉，这一章没啥好讲的，线性表的存储。重点在于最后的线性表的应用相关的算法。</p>\n<h2 id=\"线性表的定义1\"><a href=\"#线性表的定义1\" class=\"headerlink\" title=\"线性表的定义1\"></a>线性表的定义<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></h2><p>由n个数据特性相同的元素构成的有限序列称为线性表；n为其线性表的长度。</p>\n<p>一个非空的线性表或者线性结构具有以下特点：</p>\n<ul>\n<li>存在唯一一个头</li>\n<li>存在唯一一个尾</li>\n<li>除尾元素外，每个元素都有一个直接后继</li>\n<li>除头元素外，每个元素都有一个直接前驱。</li>\n</ul>\n<h2 id=\"线性表的顺序存储表示（也称作：顺序表）\"><a href=\"#线性表的顺序存储表示（也称作：顺序表）\" class=\"headerlink\" title=\"线性表的顺序存储表示（也称作：顺序表）\"></a>线性表的顺序存储表示（也称作：顺序表）</h2><p>特点：逻辑上相邻的数据元素其物理次序也是相邻的。</p>\n<h2 id=\"线性表的链式存储表示-链表\"><a href=\"#线性表的链式存储表示-链表\" class=\"headerlink\" title=\"线性表的链式存储表示(链表)\"></a>线性表的链式存储表示(链表)</h2><h3 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h3><ul>\n<li>头插</li>\n<li>尾插</li>\n<li>插入</li>\n<li>删除</li>\n</ul>\n<h3 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h3><h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><p>判空条件</p>\n<h3 id=\"双循环链表\"><a href=\"#双循环链表\" class=\"headerlink\" title=\"双循环链表\"></a>双循环链表</h3><p>判空条件</p>\n<h1 id=\"王道课后习题速查\"><a href=\"#王道课后习题速查\" class=\"headerlink\" title=\"王道课后习题速查\"></a>王道课后习题速查</h1><h2 id=\"第二章线性表\"><a href=\"#第二章线性表\" class=\"headerlink\" title=\"第二章线性表\"></a>第二章线性表</h2><h3 id=\"2-1-线性表的定义和基本操作\"><a href=\"#2-1-线性表的定义和基本操作\" class=\"headerlink\" title=\"2.1 线性表的定义和基本操作\"></a>2.1 线性表的定义和基本操作</h3><ol>\n<li>c</li>\n<li>b</li>\n<li>a </li>\n</ol>\n<h3 id=\"2-2-线性表的顺序表示\"><a href=\"#2-2-线性表的顺序表示\" class=\"headerlink\" title=\"2.2  线性表的顺序表示\"></a>2.2  线性表的顺序表示</h3><ol>\n<li><p>A   (D 存疑)</p>\n</li>\n<li><p>A   (存储结构.)</p>\n</li>\n<li><p>B</p>\n</li>\n<li><p>==B  —正解- &gt;D==  :存取操作—插入删除操作</p>\n<blockquote>\n<p>随机存取\\顺序存取   顺序存储\\随机存储(上面有介绍)</p>\n<p>本题的重点在于存取操作,而不是插入删除操作.  需要明确对于顺序表来说,插入&amp;删除操作所需要的时间复杂度高.</p>\n</blockquote>\n</li>\n<li><p>A</p>\n</li>\n<li><p>C</p>\n</li>\n<li><p>C</p>\n</li>\n<li><p>C</p>\n</li>\n<li><p>C</p>\n</li>\n<li><p>B</p>\n</li>\n<li><p>D</p>\n</li>\n</ol>\n<h3 id=\"2-3线性表的链式表示\"><a href=\"#2-3线性表的链式表示\" class=\"headerlink\" title=\"2.3线性表的链式表示\"></a>2.3线性表的链式表示</h3><h1 id=\"学习过程中发现模糊的点\"><a href=\"#学习过程中发现模糊的点\" class=\"headerlink\" title=\"学习过程中发现模糊的点\"></a>学习过程中发现模糊的点</h1><h2 id=\"程序从编译到执行的过程。\"><a href=\"#程序从编译到执行的过程。\" class=\"headerlink\" title=\"程序从编译到执行的过程。\"></a>程序从编译到执行的过程。</h2><h1 id=\"计组中的边界对齐\"><a href=\"#计组中的边界对齐\" class=\"headerlink\" title=\"计组中的边界对齐\"></a>计组中的边界对齐</h1><blockquote id=\"fn_1\">\n<sup>1</sup>. 数据结构 C语言版 （第二版）（严蔚敏、李冬梅、吴伟民）<a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> &#8617;</a>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p>\n</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-01</p>\n</div></div><div class='timeline-item-content'><p>DS第一章节绪论部分。</p>\n</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-02</p>\n</div></div><div class='timeline-item-content'><p>DS第一章节绪论部分。</p>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"DS再复习\"><a href=\"#DS再复习\" class=\"headerlink\" title=\"DS再复习\"></a>DS再复习</h1><h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"绪论部分的基本概念\"><a href=\"#绪论部分的基本概念\" class=\"headerlink\" title=\"绪论部分的基本概念\"></a>绪论部分的基本概念</h2><ul>\n<li>数据：一个很宽泛的概念 他是数据元素的集合</li>\n<li>数据元素：组成数据的基本元素。通常作为一个整体考虑。用来表示一个对象，例如学生数据中 的一条学生信息（包含id，姓名……）</li>\n<li>数据项：组成数据元素的最小不可分割单元。不可分割是逻辑意义上的，例如上述学生数据中的基本组成就是 id 姓名…… 这些单独拿出来就是一个数据项。</li>\n<li>数据对象：数据的一个子集，由多个数据元素组成。是具有相同性质的数据元素的集合（这里的相同性质的解释如下：例如整数集合，也就是组成该数据对象的数据元素都是整数；或者混合类型：例如上述的学生信息表，但是组成整个数据对象的数据元素的“类型”都是一样的）</li>\n<li>数据类型：一个值的==集合==以及定义在这个集合上的==一系列操作==。</li>\n<li>数据结构：相互之间存在==一种或多种关系的数据元素的集合== 数据的“结构”就是这里的数据元素之间的关系。<ul>\n<li>逻辑结构：从逻辑关系上描述数据，是从具体问题中抽象出来的数学模型。  通常有四类：集合、线性、树、图结构</li>\n</ul>\n</li>\n</ul>\n<div class=\"tabs\" id=\"逻辑结构图\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#逻辑结构图-1\">逻辑结构图 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#逻辑结构图-2\">逻辑结构图 2</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"逻辑结构图-1\"><div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n逻辑结构--&gt;线性结构\n逻辑结构--&gt;非线性结构\n线性结构--&gt;一般线性表\n线性结构--&gt;特殊线性表\n线性结构--&gt;线性表的推广\n非线性结构--&gt;树结构\n非线性结构--&gt;图结构\n非线性结构--&gt;集合\n树结构--&gt;树\n树结构--&gt;二叉树\n图结构--&gt;有向图\n图结构--&gt;无向图\n一般线性表--&gt;线性表\n线性表--&gt;顺序存储:顺序表\n线性表--&gt;随机存储:链表\n\n特殊线性表--&gt;栈与队列\n特殊线性表--&gt;字符串\n线性表的推广--&gt;广义表\n线性表的推广--&gt;数组\n  </pre></div><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"逻辑结构图-2\"><p>markdown mermaid 代码部分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">逻辑结构--&gt;线性结构</span><br><span class=\"line\">逻辑结构--&gt;非线性结构</span><br><span class=\"line\">线性结构--&gt;一般线性表</span><br><span class=\"line\">线性结构--&gt;特殊线性表</span><br><span class=\"line\">线性结构--&gt;线性表的推广</span><br><span class=\"line\">非线性结构--&gt;树结构</span><br><span class=\"line\">非线性结构--&gt;图结构</span><br><span class=\"line\">非线性结构--&gt;集合</span><br><span class=\"line\">树结构--&gt;树</span><br><span class=\"line\">树结构--&gt;二叉树</span><br><span class=\"line\">图结构--&gt;有向图</span><br><span class=\"line\">图结构--&gt;无向图</span><br><span class=\"line\">一般线性表--&gt;线性表</span><br><span class=\"line\">线性表--&gt;顺序存储:顺序表</span><br><span class=\"line\">线性表--&gt;随机存储:链表</span><br><span class=\"line\"></span><br><span class=\"line\">特殊线性表--&gt;栈与队列</span><br><span class=\"line\">特殊线性表--&gt;字符串</span><br><span class=\"line\">线性表的推广--&gt;广义表</span><br><span class=\"line\">线性表的推广--&gt;数组</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<ul>\n<li>物理结构:  ==数据对象==在计算机中的==存储表示==。（）<ul>\n<li>通常有两种结构：顺序存储和链式存储。（严书第二版只提到两种存储结构，其实是四种。）</li>\n</ul>\n</li>\n</ul>\n<div class=\"tabs\" id=\"物理结构图\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#物理结构图-1\">物理结构图 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#物理结构图-2\">物理结构图 2</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"物理结构图-1\"><div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\n存储结构--&gt;顺序存储\n存储结构--&gt;随机存储\n随机存储--&gt;链式存储\n随机存储--&gt;索引存储\n随机存储--&gt;散列存储Hash\n\n  </pre></div><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"物理结构图-2\"><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">存储结构--&gt;顺序存储</span><br><span class=\"line\">存储结构--&gt;随机存储</span><br><span class=\"line\">随机存储--&gt;链式存储</span><br><span class=\"line\">随机存储--&gt;索引存储</span><br><span class=\"line\">随机存储--&gt;散列存储Hash</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<p>一个表示 数据、数据元素、数据项、数据对象之间的关系的图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190618173532304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMxNjU3ODg5,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"存储结构-存取结构\"><a href=\"#存储结构-存取结构\" class=\"headerlink\" title=\"存储结构\\存取结构\"></a>存储结构\\存取结构</h3><ul>\n<li>存取结构<ul>\n<li>随机存取, 重点在”取”上,指访问指定单元的速度与其位置无关,</li>\n<li>非随机存取(顺序存取): 取第i个位置上的元素必须遍历前面的i-1个元素,  链表</li>\n</ul>\n</li>\n<li>存储结构,如上 四种<ul>\n<li>顺序存储:  指的是计算机开辟一个连续的空间来存储他们.重点在于物理上的存储空间的”开辟”.</li>\n<li>随机存储: 不是开辟一段连续的物理空间.<ul>\n<li>索引存储</li>\n<li>散列存储</li>\n<li>链式存储</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>存取结构描述的是啥?</p>\n<p>存储结构是数据结构中的一个重要的组成</p>\n<h2 id=\"算法和算法分析\"><a href=\"#算法和算法分析\" class=\"headerlink\" title=\"算法和算法分析\"></a>算法和算法分析</h2><h3 id=\"算法的定义和要求\"><a href=\"#算法的定义和要求\" class=\"headerlink\" title=\"算法的定义和要求\"></a>算法的定义和要求</h3><p>定义：是为了解决某一问题而设计的一系列的（有穷）有限长度的操作（步骤）序列。</p>\n<p>一个合格的算法应该具备下列的性质：</p>\n<ul>\n<li>有穷性</li>\n<li>确定性：算法过程中遇到的所有情况都有特定的解决方案，==不会产生二义性==</li>\n<li>可行性：可以由已经定义的所有基本操作实现。</li>\n<li>输入：有0个或者多个输入。</li>\n<li>输出：有一个或者多个输出。</li>\n</ul>\n<h3 id=\"评价算法的指标\"><a href=\"#评价算法的指标\" class=\"headerlink\" title=\"评价算法的指标\"></a>评价算法的指标</h3><ul>\n<li>可读性</li>\n<li>高效性</li>\n<li>健壮性</li>\n<li>正确性</li>\n</ul>\n<h3 id=\"时间复杂度和空间复杂度\"><a href=\"#时间复杂度和空间复杂度\" class=\"headerlink\" title=\"时间复杂度和空间复杂度\"></a>时间复杂度和空间复杂度</h3><ul>\n<li>问题规模：算法输入量的大小，输入规模的大小</li>\n<li>语句频度：一条语句执行的次数</li>\n</ul>\n<p>算法的效率分析并不是单纯的计算程序从编译到执行所用的所有时间，而是计算程序中所有的语句频度之和而得出的一个估计。</p>\n<p>因而一个算法的执行时间可以用该算法内部所有的语句频度之和来表示。</p>\n<h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>衡量一个算法的时间复杂度用其基本语句的执行频度。（基本语句：指的是其在算法中执行次数与算法的运行时间成正比的语句）从而得出算法的运行时间的函数<script type=\"math/tex\">f(n)</script> 而程序的时间复杂度记为<script type=\"math/tex\">T(n) = O(f(n))</script> 其定义是:</p>\n<script type=\"math/tex; mode=display\">\nT(n)和f(n)都是定义在正整数上的函数，则T(n) = O(f(n))的含义是，存在正整数C \\ 当 \\ n\\ge n_{0} \\ 时0 \\ \\le T(n) \\le Cf(n)</script><p>故O的含义是当输入规模趋近于无穷的时候问题的执行时间的上限不会超过<script type=\"math/tex\">f(n)</script> （定义了算法执行时间的上限）。</p>\n<ul>\n<li>最好时间复杂度、最坏时间复杂度、平均时间复杂度。</li>\n</ul>\n<p>这个和概率相关。后面的实例会遇到。</p>\n<h3 id=\"普通循环结构的时间复杂度的分析\"><a href=\"#普通循环结构的时间复杂度的分析\" class=\"headerlink\" title=\"普通循环结构的时间复杂度的分析\"></a>普通循环结构的时间复杂度的分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i = 0;i&lt;n;++i)&#123;</span><br><span class=\"line\">\toperate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第一章小结\"><a href=\"#第一章小结\" class=\"headerlink\" title=\"第一章小结\"></a>第一章小结</h2><ul>\n<li>弄清楚考察重点在哪：时间复杂度和空间复杂度的估计。<ul>\n<li>递归函数的时间复杂度计算。</li>\n<li>某些特定算法的时间复杂度  例如 2013年的题目：</li>\n</ul>\n</li>\n<li>构建起对后面将要学习的内容的一个框架。</li>\n</ul>\n<h3 id=\"2013年计算时间复杂度的题目个人理解\"><a href=\"#2013年计算时间复杂度的题目个人理解\" class=\"headerlink\" title=\"2013年计算时间复杂度的题目个人理解\"></a>2013年计算时间复杂度的题目个人理解</h3><p>需要用到时间复杂度的<a href=\"####时间复杂度\">定义</a>，可以粗略计算出当前的相对准确的语句频度，然后在选项中找到其乘以一个系数一定大于这个频度的<script type=\"math/tex\">f(x)</script></p>\n<p>2013统考的这道题目的正确解法：</p>\n<p>先想出最坏的情况：连续上升元素交替出现在两个链表中。故最坏的频度是m+n 又<script type=\"math/tex\">2max(m,n) \\ge m+n</script> 所以根据时间复杂度的定义</p>\n<script type=\"math/tex; mode=display\">\nT(n) = O(f(x)) \\rightarrow \\ 0 \\le T(n) \\le Cf(x)</script><p>只有答案 <script type=\"math/tex\">O(max(m,n))</script> 符合定义。</p>\n<p>时间复杂度的计算中三次连续的求和的最终值为<script type=\"math/tex\">T(n)=O\\left(\\sum_{i=1}^n \\sum_{j=1}^i \\sum_{k=1}^j 1\\right)=O\\left(\\frac{1}{6} n^3\\right)=O\\left(n^3\\right) 。</script></p>\n<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><p>个人感觉，这一章没啥好讲的，线性表的存储。重点在于最后的线性表的应用相关的算法。</p>\n<h2 id=\"线性表的定义1\"><a href=\"#线性表的定义1\" class=\"headerlink\" title=\"线性表的定义1\"></a>线性表的定义<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></h2><p>由n个数据特性相同的元素构成的有限序列称为线性表；n为其线性表的长度。</p>\n<p>一个非空的线性表或者线性结构具有以下特点：</p>\n<ul>\n<li>存在唯一一个头</li>\n<li>存在唯一一个尾</li>\n<li>除尾元素外，每个元素都有一个直接后继</li>\n<li>除头元素外，每个元素都有一个直接前驱。</li>\n</ul>\n<h2 id=\"线性表的顺序存储表示（也称作：顺序表）\"><a href=\"#线性表的顺序存储表示（也称作：顺序表）\" class=\"headerlink\" title=\"线性表的顺序存储表示（也称作：顺序表）\"></a>线性表的顺序存储表示（也称作：顺序表）</h2><p>特点：逻辑上相邻的数据元素其物理次序也是相邻的。</p>\n<h2 id=\"线性表的链式存储表示-链表\"><a href=\"#线性表的链式存储表示-链表\" class=\"headerlink\" title=\"线性表的链式存储表示(链表)\"></a>线性表的链式存储表示(链表)</h2><h3 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h3><ul>\n<li>头插</li>\n<li>尾插</li>\n<li>插入</li>\n<li>删除</li>\n</ul>\n<h3 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h3><h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><p>判空条件</p>\n<h3 id=\"双循环链表\"><a href=\"#双循环链表\" class=\"headerlink\" title=\"双循环链表\"></a>双循环链表</h3><p>判空条件</p>\n<h1 id=\"王道课后习题速查\"><a href=\"#王道课后习题速查\" class=\"headerlink\" title=\"王道课后习题速查\"></a>王道课后习题速查</h1><h2 id=\"第二章线性表\"><a href=\"#第二章线性表\" class=\"headerlink\" title=\"第二章线性表\"></a>第二章线性表</h2><h3 id=\"2-1-线性表的定义和基本操作\"><a href=\"#2-1-线性表的定义和基本操作\" class=\"headerlink\" title=\"2.1 线性表的定义和基本操作\"></a>2.1 线性表的定义和基本操作</h3><ol>\n<li>c</li>\n<li>b</li>\n<li>a </li>\n</ol>\n<h3 id=\"2-2-线性表的顺序表示\"><a href=\"#2-2-线性表的顺序表示\" class=\"headerlink\" title=\"2.2  线性表的顺序表示\"></a>2.2  线性表的顺序表示</h3><ol>\n<li><p>A   (D 存疑)</p>\n</li>\n<li><p>A   (存储结构.)</p>\n</li>\n<li><p>B</p>\n</li>\n<li><p>==B  —正解- &gt;D==  :存取操作—插入删除操作</p>\n<blockquote>\n<p>随机存取\\顺序存取   顺序存储\\随机存储(上面有介绍)</p>\n<p>本题的重点在于存取操作,而不是插入删除操作.  需要明确对于顺序表来说,插入&amp;删除操作所需要的时间复杂度高.</p>\n</blockquote>\n</li>\n<li><p>A</p>\n</li>\n<li><p>C</p>\n</li>\n<li><p>C</p>\n</li>\n<li><p>C</p>\n</li>\n<li><p>C</p>\n</li>\n<li><p>B</p>\n</li>\n<li><p>D</p>\n</li>\n</ol>\n<h3 id=\"2-3线性表的链式表示\"><a href=\"#2-3线性表的链式表示\" class=\"headerlink\" title=\"2.3线性表的链式表示\"></a>2.3线性表的链式表示</h3><h1 id=\"学习过程中发现模糊的点\"><a href=\"#学习过程中发现模糊的点\" class=\"headerlink\" title=\"学习过程中发现模糊的点\"></a>学习过程中发现模糊的点</h1><h2 id=\"程序从编译到执行的过程。\"><a href=\"#程序从编译到执行的过程。\" class=\"headerlink\" title=\"程序从编译到执行的过程。\"></a>程序从编译到执行的过程。</h2><h1 id=\"计组中的边界对齐\"><a href=\"#计组中的边界对齐\" class=\"headerlink\" title=\"计组中的边界对齐\"></a>计组中的边界对齐</h1><blockquote id=\"fn_1\">\n<sup>1</sup>. 数据结构 C语言版 （第二版）（严蔚敏、李冬梅、吴伟民）<a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> &#8617;</a>\n</blockquote>\n"},{"title":"考研数学（概率论部分，第一章）学习","copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-11T00:51:27.000Z","updated":"2023-04-11T00:51:27.000Z","mathjax":true,"keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg","_content":"\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-11 -->\n\n概率论基础第一章学习\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n\n\n[toc]\n\n\n\n# 概率论\n\n## 概率论部分的框架\n\n概率部分\n\n- 随机事件与概率\n- 一维随机变量\n- 二维随机变量\n- 数值特征\n- 大数定律\n\n统计部分\n\n- 统计量\n- 参数估计\n\n## 分值设置\n\n3+1+1 = 32分  三道选择，一道填空，一道大题。\n\n# 一： 随机事件与概率\n\n## 章节设置\n\n- 概念\n- 古典和几何概型\n- 三大公式\n- 伯努利\n\n## 1.1 随机事件的概念\n\n### 1.1.1事件的定义\n\n- 事件：样本点的==集合==\n\n### 1.1.2性质 8\n\n### 1.1.3关系 3+1\n\n- 包含关系：一次实验只有一个样本点发生，A中的样本点发生则A发生，若B包含A，则只要A发生事件B一定发生,记作$$A \\subset B$$\n\n- 和：事件A和B==至少==有一个发生，称为A与B的和，记作$$A\\cup B$$\n- 积：事件A与B同时发生，称为A与B 的积，记作$$AB$$\n- 互不相容（互斥）：两个不相交的集合\n- 对立（互逆）：不能同时发生，但是必有一个发生\n- 差：事件A发生但是事件B不发生称为A与B的差 \n\n### 1.1.4运算律\n\n- 交换律\n- 结合律\n- 分配律（注意分配律的逆用）$$  A(B \\cup C) = AB \\cup AC , \\ \\ \\ (A \\cup B)(A \\cup C) = A\\cup(BC) , \\ \\ \\   $$\n- 摩根律 $$  \\overline{A \\cup B}  = \\overline{A} \\ \\overline{B} \\ \\ , \\ \\ \\overline{AB} = \\overline{A} \\cup \\overline{B} $$\n- 吸收律: $$  A \\cup (AB) = A, \\ \\ A (A \\cup B) = A  $$\n\n## 1.2 概率的概念\n\n### 1.2.1 概率的定义\n\n事件发生的可能性大小\n\n- 非负性\n- 规范性\n- 可列可加性\n\n### 1.2.2 概率的性质\n\n- 有限可加\n- 单调不减\n- 加法公式\n- 减法公式\n- 求逆公式\n\n### 1.2.3 古典概型的定义\n\n抽签原理。\n\n### 1.2.4 几何概型的定义\n\n## 1.3三大概率公式\n\n### 1.3.1 条件概率公式\n\n缩减样本空间\n\n推论：乘法公式 \n$$\nP(A|B) = \\frac{P(AB)}{P(B)},关键在于如何理解P(AB),AB事件发生的概率（这里可能要联系后面的事件独立性）\\\\\n乘法公式: \\ \\  P(AB) = P(B)P(A|B)\n$$\n\n\n### 1.3.2 全概率公式\n\n### 1.3.3 贝叶斯公式\n\n\n\n## 1.4 事件独立性与伯努利概型\n\n### 1.4.1 事件独立性的定义\n\n$$\n如果事件A,B 满足P(AB) = P(A)P(B),则称事件AB相互独立 \n$$\n\n\n\n### 1.4.2 事件独立性的充要条件\n\n$$\n\\begin{align}\n& A,B事件独立 \\Leftrightarrow \\\\\n& P(A)P(B) = P(AB) \\\\\n& P(A) = P(A|B) = P(A | \\bar{B}) [同理 P(B)] \\\\\n& A与\\bar{B} 或\\bar{A}与B 或\\bar{A}与\\bar{B} 相互独立\n\\end{align}\n$$\n\n","source":"_posts/考研数学（概率论部分，第一章）学习.md","raw":"---\ntitle: 考研数学（概率论部分，第一章）学习\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-11 08:51:27\nupdated: 2023-04-11 08:51:27\nmathjax: true\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg\n---\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-11 -->\n\n概率论基础第一章学习\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n\n\n[toc]\n\n\n\n# 概率论\n\n## 概率论部分的框架\n\n概率部分\n\n- 随机事件与概率\n- 一维随机变量\n- 二维随机变量\n- 数值特征\n- 大数定律\n\n统计部分\n\n- 统计量\n- 参数估计\n\n## 分值设置\n\n3+1+1 = 32分  三道选择，一道填空，一道大题。\n\n# 一： 随机事件与概率\n\n## 章节设置\n\n- 概念\n- 古典和几何概型\n- 三大公式\n- 伯努利\n\n## 1.1 随机事件的概念\n\n### 1.1.1事件的定义\n\n- 事件：样本点的==集合==\n\n### 1.1.2性质 8\n\n### 1.1.3关系 3+1\n\n- 包含关系：一次实验只有一个样本点发生，A中的样本点发生则A发生，若B包含A，则只要A发生事件B一定发生,记作$$A \\subset B$$\n\n- 和：事件A和B==至少==有一个发生，称为A与B的和，记作$$A\\cup B$$\n- 积：事件A与B同时发生，称为A与B 的积，记作$$AB$$\n- 互不相容（互斥）：两个不相交的集合\n- 对立（互逆）：不能同时发生，但是必有一个发生\n- 差：事件A发生但是事件B不发生称为A与B的差 \n\n### 1.1.4运算律\n\n- 交换律\n- 结合律\n- 分配律（注意分配律的逆用）$$  A(B \\cup C) = AB \\cup AC , \\ \\ \\ (A \\cup B)(A \\cup C) = A\\cup(BC) , \\ \\ \\   $$\n- 摩根律 $$  \\overline{A \\cup B}  = \\overline{A} \\ \\overline{B} \\ \\ , \\ \\ \\overline{AB} = \\overline{A} \\cup \\overline{B} $$\n- 吸收律: $$  A \\cup (AB) = A, \\ \\ A (A \\cup B) = A  $$\n\n## 1.2 概率的概念\n\n### 1.2.1 概率的定义\n\n事件发生的可能性大小\n\n- 非负性\n- 规范性\n- 可列可加性\n\n### 1.2.2 概率的性质\n\n- 有限可加\n- 单调不减\n- 加法公式\n- 减法公式\n- 求逆公式\n\n### 1.2.3 古典概型的定义\n\n抽签原理。\n\n### 1.2.4 几何概型的定义\n\n## 1.3三大概率公式\n\n### 1.3.1 条件概率公式\n\n缩减样本空间\n\n推论：乘法公式 \n$$\nP(A|B) = \\frac{P(AB)}{P(B)},关键在于如何理解P(AB),AB事件发生的概率（这里可能要联系后面的事件独立性）\\\\\n乘法公式: \\ \\  P(AB) = P(B)P(A|B)\n$$\n\n\n### 1.3.2 全概率公式\n\n### 1.3.3 贝叶斯公式\n\n\n\n## 1.4 事件独立性与伯努利概型\n\n### 1.4.1 事件独立性的定义\n\n$$\n如果事件A,B 满足P(AB) = P(A)P(B),则称事件AB相互独立 \n$$\n\n\n\n### 1.4.2 事件独立性的充要条件\n\n$$\n\\begin{align}\n& A,B事件独立 \\Leftrightarrow \\\\\n& P(A)P(B) = P(AB) \\\\\n& P(A) = P(A|B) = P(A | \\bar{B}) [同理 P(B)] \\\\\n& A与\\bar{B} 或\\bar{A}与B 或\\bar{A}与\\bar{B} 相互独立\n\\end{align}\n$$\n\n","slug":"考研数学（概率论部分，第一章）学习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwma000ebsuo4a9ib89f","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-11</p>\n</div></div><div class=\"timeline-item-content\"><p>概率论基础第一章学习</p>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"概率论\"><a href=\"#概率论\" class=\"headerlink\" title=\"概率论\"></a>概率论</h1><h2 id=\"概率论部分的框架\"><a href=\"#概率论部分的框架\" class=\"headerlink\" title=\"概率论部分的框架\"></a>概率论部分的框架</h2><p>概率部分</p>\n<ul>\n<li>随机事件与概率</li>\n<li>一维随机变量</li>\n<li>二维随机变量</li>\n<li>数值特征</li>\n<li>大数定律</li>\n</ul>\n<p>统计部分</p>\n<ul>\n<li>统计量</li>\n<li>参数估计</li>\n</ul>\n<h2 id=\"分值设置\"><a href=\"#分值设置\" class=\"headerlink\" title=\"分值设置\"></a>分值设置</h2><p>3+1+1 = 32分  三道选择，一道填空，一道大题。</p>\n<h1 id=\"一：-随机事件与概率\"><a href=\"#一：-随机事件与概率\" class=\"headerlink\" title=\"一： 随机事件与概率\"></a>一： 随机事件与概率</h1><h2 id=\"章节设置\"><a href=\"#章节设置\" class=\"headerlink\" title=\"章节设置\"></a>章节设置</h2><ul>\n<li>概念</li>\n<li>古典和几何概型</li>\n<li>三大公式</li>\n<li>伯努利</li>\n</ul>\n<h2 id=\"1-1-随机事件的概念\"><a href=\"#1-1-随机事件的概念\" class=\"headerlink\" title=\"1.1 随机事件的概念\"></a>1.1 随机事件的概念</h2><h3 id=\"1-1-1事件的定义\"><a href=\"#1-1-1事件的定义\" class=\"headerlink\" title=\"1.1.1事件的定义\"></a>1.1.1事件的定义</h3><ul>\n<li>事件：样本点的==集合==</li>\n</ul>\n<h3 id=\"1-1-2性质-8\"><a href=\"#1-1-2性质-8\" class=\"headerlink\" title=\"1.1.2性质 8\"></a>1.1.2性质 8</h3><h3 id=\"1-1-3关系-3-1\"><a href=\"#1-1-3关系-3-1\" class=\"headerlink\" title=\"1.1.3关系 3+1\"></a>1.1.3关系 3+1</h3><ul>\n<li><p>包含关系：一次实验只有一个样本点发生，A中的样本点发生则A发生，若B包含A，则只要A发生事件B一定发生,记作<script type=\"math/tex\">A \\subset B</script></p>\n</li>\n<li><p>和：事件A和B==至少==有一个发生，称为A与B的和，记作<script type=\"math/tex\">A\\cup B</script></p>\n</li>\n<li>积：事件A与B同时发生，称为A与B 的积，记作<script type=\"math/tex\">AB</script></li>\n<li>互不相容（互斥）：两个不相交的集合</li>\n<li>对立（互逆）：不能同时发生，但是必有一个发生</li>\n<li>差：事件A发生但是事件B不发生称为A与B的差 </li>\n</ul>\n<h3 id=\"1-1-4运算律\"><a href=\"#1-1-4运算律\" class=\"headerlink\" title=\"1.1.4运算律\"></a>1.1.4运算律</h3><ul>\n<li>交换律</li>\n<li>结合律</li>\n<li>分配律（注意分配律的逆用）<script type=\"math/tex\">A(B \\cup C) = AB \\cup AC , \\ \\ \\ (A \\cup B)(A \\cup C) = A\\cup(BC) , \\ \\ \\</script></li>\n<li>摩根律 <script type=\"math/tex\">\\overline{A \\cup B}  = \\overline{A} \\ \\overline{B} \\ \\ , \\ \\ \\overline{AB} = \\overline{A} \\cup \\overline{B}</script></li>\n<li>吸收律: <script type=\"math/tex\">A \\cup (AB) = A, \\ \\ A (A \\cup B) = A</script></li>\n</ul>\n<h2 id=\"1-2-概率的概念\"><a href=\"#1-2-概率的概念\" class=\"headerlink\" title=\"1.2 概率的概念\"></a>1.2 概率的概念</h2><h3 id=\"1-2-1-概率的定义\"><a href=\"#1-2-1-概率的定义\" class=\"headerlink\" title=\"1.2.1 概率的定义\"></a>1.2.1 概率的定义</h3><p>事件发生的可能性大小</p>\n<ul>\n<li>非负性</li>\n<li>规范性</li>\n<li>可列可加性</li>\n</ul>\n<h3 id=\"1-2-2-概率的性质\"><a href=\"#1-2-2-概率的性质\" class=\"headerlink\" title=\"1.2.2 概率的性质\"></a>1.2.2 概率的性质</h3><ul>\n<li>有限可加</li>\n<li>单调不减</li>\n<li>加法公式</li>\n<li>减法公式</li>\n<li>求逆公式</li>\n</ul>\n<h3 id=\"1-2-3-古典概型的定义\"><a href=\"#1-2-3-古典概型的定义\" class=\"headerlink\" title=\"1.2.3 古典概型的定义\"></a>1.2.3 古典概型的定义</h3><p>抽签原理。</p>\n<h3 id=\"1-2-4-几何概型的定义\"><a href=\"#1-2-4-几何概型的定义\" class=\"headerlink\" title=\"1.2.4 几何概型的定义\"></a>1.2.4 几何概型的定义</h3><h2 id=\"1-3三大概率公式\"><a href=\"#1-3三大概率公式\" class=\"headerlink\" title=\"1.3三大概率公式\"></a>1.3三大概率公式</h2><h3 id=\"1-3-1-条件概率公式\"><a href=\"#1-3-1-条件概率公式\" class=\"headerlink\" title=\"1.3.1 条件概率公式\"></a>1.3.1 条件概率公式</h3><p>缩减样本空间</p>\n<p>推论：乘法公式 </p>\n<script type=\"math/tex; mode=display\">\nP(A|B) = \\frac{P(AB)}{P(B)},关键在于如何理解P(AB),AB事件发生的概率（这里可能要联系后面的事件独立性）\\\\\n乘法公式: \\ \\  P(AB) = P(B)P(A|B)</script><h3 id=\"1-3-2-全概率公式\"><a href=\"#1-3-2-全概率公式\" class=\"headerlink\" title=\"1.3.2 全概率公式\"></a>1.3.2 全概率公式</h3><h3 id=\"1-3-3-贝叶斯公式\"><a href=\"#1-3-3-贝叶斯公式\" class=\"headerlink\" title=\"1.3.3 贝叶斯公式\"></a>1.3.3 贝叶斯公式</h3><h2 id=\"1-4-事件独立性与伯努利概型\"><a href=\"#1-4-事件独立性与伯努利概型\" class=\"headerlink\" title=\"1.4 事件独立性与伯努利概型\"></a>1.4 事件独立性与伯努利概型</h2><h3 id=\"1-4-1-事件独立性的定义\"><a href=\"#1-4-1-事件独立性的定义\" class=\"headerlink\" title=\"1.4.1 事件独立性的定义\"></a>1.4.1 事件独立性的定义</h3><script type=\"math/tex; mode=display\">\n如果事件A,B 满足P(AB) = P(A)P(B),则称事件AB相互独立</script><h3 id=\"1-4-2-事件独立性的充要条件\"><a href=\"#1-4-2-事件独立性的充要条件\" class=\"headerlink\" title=\"1.4.2 事件独立性的充要条件\"></a>1.4.2 事件独立性的充要条件</h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& A,B事件独立 \\Leftrightarrow \\\\\n& P(A)P(B) = P(AB) \\\\\n& P(A) = P(A|B) = P(A | \\bar{B}) [同理 P(B)] \\\\\n& A与\\bar{B} 或\\bar{A}与B 或\\bar{A}与\\bar{B} 相互独立\n\\end{align}</script>","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-11</p>\n</div></div><div class=\"timeline-item-content\"><p>概率论基础第一章学习</p>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"概率论\"><a href=\"#概率论\" class=\"headerlink\" title=\"概率论\"></a>概率论</h1><h2 id=\"概率论部分的框架\"><a href=\"#概率论部分的框架\" class=\"headerlink\" title=\"概率论部分的框架\"></a>概率论部分的框架</h2><p>概率部分</p>\n<ul>\n<li>随机事件与概率</li>\n<li>一维随机变量</li>\n<li>二维随机变量</li>\n<li>数值特征</li>\n<li>大数定律</li>\n</ul>\n<p>统计部分</p>\n<ul>\n<li>统计量</li>\n<li>参数估计</li>\n</ul>\n<h2 id=\"分值设置\"><a href=\"#分值设置\" class=\"headerlink\" title=\"分值设置\"></a>分值设置</h2><p>3+1+1 = 32分  三道选择，一道填空，一道大题。</p>\n<h1 id=\"一：-随机事件与概率\"><a href=\"#一：-随机事件与概率\" class=\"headerlink\" title=\"一： 随机事件与概率\"></a>一： 随机事件与概率</h1><h2 id=\"章节设置\"><a href=\"#章节设置\" class=\"headerlink\" title=\"章节设置\"></a>章节设置</h2><ul>\n<li>概念</li>\n<li>古典和几何概型</li>\n<li>三大公式</li>\n<li>伯努利</li>\n</ul>\n<h2 id=\"1-1-随机事件的概念\"><a href=\"#1-1-随机事件的概念\" class=\"headerlink\" title=\"1.1 随机事件的概念\"></a>1.1 随机事件的概念</h2><h3 id=\"1-1-1事件的定义\"><a href=\"#1-1-1事件的定义\" class=\"headerlink\" title=\"1.1.1事件的定义\"></a>1.1.1事件的定义</h3><ul>\n<li>事件：样本点的==集合==</li>\n</ul>\n<h3 id=\"1-1-2性质-8\"><a href=\"#1-1-2性质-8\" class=\"headerlink\" title=\"1.1.2性质 8\"></a>1.1.2性质 8</h3><h3 id=\"1-1-3关系-3-1\"><a href=\"#1-1-3关系-3-1\" class=\"headerlink\" title=\"1.1.3关系 3+1\"></a>1.1.3关系 3+1</h3><ul>\n<li><p>包含关系：一次实验只有一个样本点发生，A中的样本点发生则A发生，若B包含A，则只要A发生事件B一定发生,记作<script type=\"math/tex\">A \\subset B</script></p>\n</li>\n<li><p>和：事件A和B==至少==有一个发生，称为A与B的和，记作<script type=\"math/tex\">A\\cup B</script></p>\n</li>\n<li>积：事件A与B同时发生，称为A与B 的积，记作<script type=\"math/tex\">AB</script></li>\n<li>互不相容（互斥）：两个不相交的集合</li>\n<li>对立（互逆）：不能同时发生，但是必有一个发生</li>\n<li>差：事件A发生但是事件B不发生称为A与B的差 </li>\n</ul>\n<h3 id=\"1-1-4运算律\"><a href=\"#1-1-4运算律\" class=\"headerlink\" title=\"1.1.4运算律\"></a>1.1.4运算律</h3><ul>\n<li>交换律</li>\n<li>结合律</li>\n<li>分配律（注意分配律的逆用）<script type=\"math/tex\">A(B \\cup C) = AB \\cup AC , \\ \\ \\ (A \\cup B)(A \\cup C) = A\\cup(BC) , \\ \\ \\</script></li>\n<li>摩根律 <script type=\"math/tex\">\\overline{A \\cup B}  = \\overline{A} \\ \\overline{B} \\ \\ , \\ \\ \\overline{AB} = \\overline{A} \\cup \\overline{B}</script></li>\n<li>吸收律: <script type=\"math/tex\">A \\cup (AB) = A, \\ \\ A (A \\cup B) = A</script></li>\n</ul>\n<h2 id=\"1-2-概率的概念\"><a href=\"#1-2-概率的概念\" class=\"headerlink\" title=\"1.2 概率的概念\"></a>1.2 概率的概念</h2><h3 id=\"1-2-1-概率的定义\"><a href=\"#1-2-1-概率的定义\" class=\"headerlink\" title=\"1.2.1 概率的定义\"></a>1.2.1 概率的定义</h3><p>事件发生的可能性大小</p>\n<ul>\n<li>非负性</li>\n<li>规范性</li>\n<li>可列可加性</li>\n</ul>\n<h3 id=\"1-2-2-概率的性质\"><a href=\"#1-2-2-概率的性质\" class=\"headerlink\" title=\"1.2.2 概率的性质\"></a>1.2.2 概率的性质</h3><ul>\n<li>有限可加</li>\n<li>单调不减</li>\n<li>加法公式</li>\n<li>减法公式</li>\n<li>求逆公式</li>\n</ul>\n<h3 id=\"1-2-3-古典概型的定义\"><a href=\"#1-2-3-古典概型的定义\" class=\"headerlink\" title=\"1.2.3 古典概型的定义\"></a>1.2.3 古典概型的定义</h3><p>抽签原理。</p>\n<h3 id=\"1-2-4-几何概型的定义\"><a href=\"#1-2-4-几何概型的定义\" class=\"headerlink\" title=\"1.2.4 几何概型的定义\"></a>1.2.4 几何概型的定义</h3><h2 id=\"1-3三大概率公式\"><a href=\"#1-3三大概率公式\" class=\"headerlink\" title=\"1.3三大概率公式\"></a>1.3三大概率公式</h2><h3 id=\"1-3-1-条件概率公式\"><a href=\"#1-3-1-条件概率公式\" class=\"headerlink\" title=\"1.3.1 条件概率公式\"></a>1.3.1 条件概率公式</h3><p>缩减样本空间</p>\n<p>推论：乘法公式 </p>\n<script type=\"math/tex; mode=display\">\nP(A|B) = \\frac{P(AB)}{P(B)},关键在于如何理解P(AB),AB事件发生的概率（这里可能要联系后面的事件独立性）\\\\\n乘法公式: \\ \\  P(AB) = P(B)P(A|B)</script><h3 id=\"1-3-2-全概率公式\"><a href=\"#1-3-2-全概率公式\" class=\"headerlink\" title=\"1.3.2 全概率公式\"></a>1.3.2 全概率公式</h3><h3 id=\"1-3-3-贝叶斯公式\"><a href=\"#1-3-3-贝叶斯公式\" class=\"headerlink\" title=\"1.3.3 贝叶斯公式\"></a>1.3.3 贝叶斯公式</h3><h2 id=\"1-4-事件独立性与伯努利概型\"><a href=\"#1-4-事件独立性与伯努利概型\" class=\"headerlink\" title=\"1.4 事件独立性与伯努利概型\"></a>1.4 事件独立性与伯努利概型</h2><h3 id=\"1-4-1-事件独立性的定义\"><a href=\"#1-4-1-事件独立性的定义\" class=\"headerlink\" title=\"1.4.1 事件独立性的定义\"></a>1.4.1 事件独立性的定义</h3><script type=\"math/tex; mode=display\">\n如果事件A,B 满足P(AB) = P(A)P(B),则称事件AB相互独立</script><h3 id=\"1-4-2-事件独立性的充要条件\"><a href=\"#1-4-2-事件独立性的充要条件\" class=\"headerlink\" title=\"1.4.2 事件独立性的充要条件\"></a>1.4.2 事件独立性的充要条件</h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& A,B事件独立 \\Leftrightarrow \\\\\n& P(A)P(B) = P(AB) \\\\\n& P(A) = P(A|B) = P(A | \\bar{B}) [同理 P(B)] \\\\\n& A与\\bar{B} 或\\bar{A}与B 或\\bar{A}与\\bar{B} 相互独立\n\\end{align}</script>"},{"title":"考研数学（概率论部分，第三章）学习","mathjax":true,"copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-20T01:38:17.000Z","updated":"2023-04-20T01:38:17.000Z","keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg","_content":"\n\n\n\n\n\n\n\n\n[toc]\n\n第二章中的所有的概率分布的类型一定还要特别熟悉！！！\n\n# 二维随机变量及其分布   \n\n## 定义\n\n### 二维随机变量的定义\n\n二维随机变量的定义 设$$ X=Y(\\omega),Y=Y(\\omega) $$为样本空间Ω上的两个随机变量，称(X，Y)为二维随机变量\n\n### 联合（二维）分布函数的定义\n\n联合分布函数的定义 设(X，Y)为二维随机变量，对任意实数x，y,称$$ F(x,y)=P \\left\\{ X \\leq x,Y \\leq y\\right\\} $$为(X,Y)的联合分布函数，简称分布函数。可以将其中的$$P \\left\\{ X \\leq x,Y \\leq y\\right\\}$$看作是 $$P(AB),\\ \\ \\ A\\sim X \\leq x \\ \\ \\  B \\sim Y \\leq y $$\n\n### 边缘分布函数的定义\n\n设二维随机变量(X，Y)的联合分布函数为F(x，y),分别称\n$$\nF_{X}(x)=P \\left\\{ X \\leq x \\right\\} =P \\left\\{ X \\leq x,Y \\leq + \\infty \\right\\} =F(x,+ \\infty) \\\\\nF_{Y}(y)=P \\left\\{ Y \\leq y \\right\\} =P \\left\\{ X \\leq + \\infty ,Y \\leq y \\right\\} =F(+ \\infty ,y)\n$$\n为(X，Y)关于X和Y的边缘分布函数.\n\n### 独立性的充要条件\n\n如果联合分布函数中 边缘分布函数的乘积等于联合分布函数的乘积那么就是两个独立事件。\n\n## 性质 5（构成充要条件）\n\n- 非负性\n- 规范性$$ F(- \\infty ,y)=F(x,- \\infty)=F(- \\infty ,- \\infty)=0,F(+ \\infty ,+ \\infty)=1; $$\n- 单调不减\n- 右连续\n- 计算 $$ P \\left\\{ a<X \\leq b,c<Y \\leq d \\right\\} =F(b,d)-F(b,c)-F(a,d)+F(a,c) $$矩形域。想想前缀和。\n\n\n\n{% tabs 判断一个分布函数是否是联合分布函数%}\n\n<!-- tab 例题-->\n\n【例3.1】下列四个函数哪个不能作为联合分布函数\n$$(A)  F_{1} (x,y)= \\begin{cases}  (1-e^{-x})(1-e^{-y}),x>0,y>0  \\\\  0, 其他 \\end{cases} $$\n$$(B) F_{2}(x,y)= \\frac{1}{\\pi ^{2}}(\\frac{\\pi}{2}+ \\arctan \\frac{x}{2})(\\frac{\\pi}{2}+ \\arctan \\frac{y}{3}) $$\n$$(C)  F_{3} $$(x,y)=$$\\left\\{ \\begin{matrix}  1,x+2y \\geq 1  \\\\  0,x+2y<1  \\end{matrix} \\right.$$\n$$(D) F_{4} (x,y)= \\begin{cases}  1-2^{-x}-2^{-y}+2^{-x-y} , x>0  ,y \\geq 0  \\\\  0，其他 \\end{cases} $$\n\n<!-- endtab -->\n\n<!-- tab 如何快速判断一个函数是否是一个一维的分布函数-->\n\n使用分布函数的四条性质（充要条件）\n\n非负性、规范性、右连续、单调不减\n\n<!-- endtab -->\n\n{% endtabs %}\n\n# 二维离散型随机变量\n\n## 定义\n\n一定要分清 概率分布和分布函数之间的关系，（离散中，概率分布是点，一个特殊的样本点出现的概率） 而分布函数是一个样本几何的出现概率\n\n### 联合概率分布\n\n联合概率分布的定义 设二维随机变量(X，Y)的取值为有限个或可列个，称(X，Y)为二维离散型随机变量.设(X，Y)的取值为( $$ x_{1} $$，$$ y_{j} $$),i$$ j=1,2 $$，...,称$$ P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{i,},i,j=1,2 $$...为(X，Y)的联合概\n率分布，简称概率分布，也可用列表法表示.\n\n简记：一张表！\n\n### 边缘概率分布\n\n边缘概率分布的定义 设二维随机变量(X，Y)的联合概率分布为\n$$ P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2, $$，...,分别称\n$$ p_{i}.=P \\left\\{ X=x_{i}\\right\\} = \\sum p_{ij},i=1,2,\\cdots $$\n$$ p_{ij}=P \\left\\{ Y=y_{j}\\right\\} = \\sum _{ij},j=1,2,\\cdots $$\n为(X，Y)关于X和Y的边缘概率分布.\n\n简记表中的一行或者一列。\n\n### 条件概率分布的定义\n\n条件概率分布的定义 设二维随机变量(X，Y)的联合概率分布为\n$$ P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2\\cdots $$称$$ P \\left\\{ X=x_{i}|Y=y_{j}\\right\\} = \\frac{P_{ij}}{p_{\\bullet j}} $$为在$$ Y=y_{j} $$的条件下，X的条件概率分布;称$$ P \\left\\{ Y=y_{j}|X=x_{i}\\right\\} = \\frac{p_{ij}}{p_{i\\bullet}} $$为在$$ X=x_{i} $$的条件下，Y的条件概率分布.\n\n## 性质\n\n\n\n# 二维连续\n\n## 定义\n\n### 联合概率密度定义\n\n### 边缘概率密度的定义\n\n### 条件概率密度的定义\n\n条件概率密度的定义 设二维随机变量(X，Y)的联合概率密度为f(x，y),称$$ f_{X|Y}(x|y)= \\frac{f(x,y)}{f_{Y}(y)} $$\n为在$$ Y=y $$的条件下，X的条件概率密度;称$$ f_{\\gamma |x}(y|x)= \\frac{f(x,y)}{f_{x}(x)} $$为在$$ X=x $$的条件下，Y的条件概率密度.\n\n## 性质\n\n- 非负性\n- 规范性\n- 计算随机变量取值的概率 $$ P \\left\\{(X,Y)\\in D \\right\\} = \\int \\int f(x,y)dxdy. $$\n\n性质(1)，(2)是判定概率密度的充要条件;性质(3)用于计算随机变量取值的概率\n\n# 随机变量的独立性\n\n## 定义\n\n随机变量相互独立的定义 设二维随机变量(X，Y)的联合分布函数为F(x，y),边缘分布函数分别为$$ F_{x}(x) $$和 $$ F_{1} $$(y),若对任意实数x，y,有$$ F(x,y)=F_{X}(x)F_{Y}(y) $$，则称随机变量X与Y相互独立.\n\n## 充要条件\n\n$$\nX与Y相互独立 \\\\ \n\\begin{matrix}\n& \\Leftrightarrow  F(x,y)=F_{x}(x)F_{Y}(y) \\\\\n& \\Leftrightarrow p_{ij}=p_{i\\bullet}p_{\\bullet j} \\\\ \n& \\Leftrightarrow f(x,y)=f_{x}(x)f_{Y}(y) \n\\end{matrix}\n$$\n\n\n\n# 二维均匀分布与二维正态分布\n\n## 二维均匀分布\n\n设二维随机变量(X，Y)的联合概率密度为\n$$ f(x,y)= \\begin{cases} \\frac{1}{S_{D}},(x,y)\\in D \\\\ 0,其他 \\\\ \\end{cases}  $$\n称(X，Y)服从区域D上的均匀分布，记作(X，Y)~U(D)\n\n### 二维均匀分布性质（充要条件）\n\n设$$ (X,Y)\\sim U(a,b)\\times(c,d)  \\ \\ \\ \\Leftrightarrow $$，则$$ X \\sim U(a,b),Y \\sim U(c,d) $$，且X与Y相互独立. 【两个一维的均匀分布（相互独立）的联合随机变量复合其两个区间组成的矩形】\n\n## 二维正态分布\n\n设二维随机变量(X，Y)的联合概率密度为\n$$\nf(x,y)= \\frac{1}{2 \\pi \\sigma _{1}\\sigma _{2}\\sqrt{1- \\rho ^{2}}}e^{-\\frac{1}{2(1- \\rho ^{2})}\\left[(\\frac{x- \\mu _{1}}{\\sigma _{1}})^{2}- \\frac{2 \\rho(x- \\mu _{1})(y- \\mu _{2})}{\\sigma _{1}\\sigma _{2}}+(\\frac{y- \\mu _{2}}{\\sigma _{2}})^{2}\\right] } \n$$\n其中$$  \\sigma _{1}>0, \\sigma _{2}>0,| \\rho |<1 $$，称(X，Y)服从参数为 $$  \\mu _{1} $$，$$  \\mu _{2} $$，$$  \\sigma _{1} $$，$$  \\sigma _{2} $$，p的二维正态分布，记\n(X,Y)~N( $$  \\mu _{1} $$，$$  \\mu _{2} $$; $$  \\sigma _{1}^{2} $$，$$  \\sigma _{2}^{2} $$;ρ)\n\n### 二维正态分布的性质\n\n- 设$$ (X，Y)\\sim N(  \\mu _{1} ，\\mu _{2} ;   \\sigma _{1}^{2} , \\sigma _{2}^{2} ;\\rho)$$,则 $$X\\sim N( \\mu _{1} ，  \\sigma _{1}^{2} ),Y\\sim N( \\mu _{2} ，  \\sigma _{2}^{2} )$$,反之不成立;\n\n- X与Y相互独立X与Y不相关$$ (\\rho =0 $$);\n\n- 相互独立的正态分布的线性组合任然为正态分布\n\n  $$ aX+bY \\sim N(a \\mu _{1}+b \\mu _{2},a^{2}\\sigma _{1}^{2}+b^{2}\\sigma _{2}^{2}+2ab \\rho \\sigma _{1}\\sigma _{2}); $$\n\n  特别的若X与Y相互独立，X~N( $$  \\mu _{1} $$，$$  \\sigma _{1}^{2} $$),Y~N( $$  \\mu _{2} $$，$$  \\sigma _{2}^{2} $$),则\n\n- 若$$ U=aX+bY,V=cX+dY $$，即U\n  $$ \\begin{pmatrix}U \\\\ V \\\\ \\end{pmatrix} = \\begin{pmatrix} a \\boxed b \\\\ c \\boxed d \\\\ \\end{pmatrix} \\begin{pmatrix} X \\\\ Y \\\\ \\end{pmatrix} $$，则(U，V)服从二维正态分布，二维正太经过可逆线性变换任然为二维正态。\n  ,\n\n# 二维随机变量函数的分布\n\n## 二维离散型\n\n## 二维连续型随机变量函数的分布 \n\n### 分布函数法\n\n### 公式带入\n","source":"_posts/考研数学（概率论部分，第三章）学习.md","raw":"---\ntitle: 考研数学（概率论部分，第三章）学习\nmathjax: true\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-20 09:38:17\nupdated: 2023-04-20 09:38:17\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg\n---\n\n\n\n\n\n\n\n\n\n[toc]\n\n第二章中的所有的概率分布的类型一定还要特别熟悉！！！\n\n# 二维随机变量及其分布   \n\n## 定义\n\n### 二维随机变量的定义\n\n二维随机变量的定义 设$$ X=Y(\\omega),Y=Y(\\omega) $$为样本空间Ω上的两个随机变量，称(X，Y)为二维随机变量\n\n### 联合（二维）分布函数的定义\n\n联合分布函数的定义 设(X，Y)为二维随机变量，对任意实数x，y,称$$ F(x,y)=P \\left\\{ X \\leq x,Y \\leq y\\right\\} $$为(X,Y)的联合分布函数，简称分布函数。可以将其中的$$P \\left\\{ X \\leq x,Y \\leq y\\right\\}$$看作是 $$P(AB),\\ \\ \\ A\\sim X \\leq x \\ \\ \\  B \\sim Y \\leq y $$\n\n### 边缘分布函数的定义\n\n设二维随机变量(X，Y)的联合分布函数为F(x，y),分别称\n$$\nF_{X}(x)=P \\left\\{ X \\leq x \\right\\} =P \\left\\{ X \\leq x,Y \\leq + \\infty \\right\\} =F(x,+ \\infty) \\\\\nF_{Y}(y)=P \\left\\{ Y \\leq y \\right\\} =P \\left\\{ X \\leq + \\infty ,Y \\leq y \\right\\} =F(+ \\infty ,y)\n$$\n为(X，Y)关于X和Y的边缘分布函数.\n\n### 独立性的充要条件\n\n如果联合分布函数中 边缘分布函数的乘积等于联合分布函数的乘积那么就是两个独立事件。\n\n## 性质 5（构成充要条件）\n\n- 非负性\n- 规范性$$ F(- \\infty ,y)=F(x,- \\infty)=F(- \\infty ,- \\infty)=0,F(+ \\infty ,+ \\infty)=1; $$\n- 单调不减\n- 右连续\n- 计算 $$ P \\left\\{ a<X \\leq b,c<Y \\leq d \\right\\} =F(b,d)-F(b,c)-F(a,d)+F(a,c) $$矩形域。想想前缀和。\n\n\n\n{% tabs 判断一个分布函数是否是联合分布函数%}\n\n<!-- tab 例题-->\n\n【例3.1】下列四个函数哪个不能作为联合分布函数\n$$(A)  F_{1} (x,y)= \\begin{cases}  (1-e^{-x})(1-e^{-y}),x>0,y>0  \\\\  0, 其他 \\end{cases} $$\n$$(B) F_{2}(x,y)= \\frac{1}{\\pi ^{2}}(\\frac{\\pi}{2}+ \\arctan \\frac{x}{2})(\\frac{\\pi}{2}+ \\arctan \\frac{y}{3}) $$\n$$(C)  F_{3} $$(x,y)=$$\\left\\{ \\begin{matrix}  1,x+2y \\geq 1  \\\\  0,x+2y<1  \\end{matrix} \\right.$$\n$$(D) F_{4} (x,y)= \\begin{cases}  1-2^{-x}-2^{-y}+2^{-x-y} , x>0  ,y \\geq 0  \\\\  0，其他 \\end{cases} $$\n\n<!-- endtab -->\n\n<!-- tab 如何快速判断一个函数是否是一个一维的分布函数-->\n\n使用分布函数的四条性质（充要条件）\n\n非负性、规范性、右连续、单调不减\n\n<!-- endtab -->\n\n{% endtabs %}\n\n# 二维离散型随机变量\n\n## 定义\n\n一定要分清 概率分布和分布函数之间的关系，（离散中，概率分布是点，一个特殊的样本点出现的概率） 而分布函数是一个样本几何的出现概率\n\n### 联合概率分布\n\n联合概率分布的定义 设二维随机变量(X，Y)的取值为有限个或可列个，称(X，Y)为二维离散型随机变量.设(X，Y)的取值为( $$ x_{1} $$，$$ y_{j} $$),i$$ j=1,2 $$，...,称$$ P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{i,},i,j=1,2 $$...为(X，Y)的联合概\n率分布，简称概率分布，也可用列表法表示.\n\n简记：一张表！\n\n### 边缘概率分布\n\n边缘概率分布的定义 设二维随机变量(X，Y)的联合概率分布为\n$$ P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2, $$，...,分别称\n$$ p_{i}.=P \\left\\{ X=x_{i}\\right\\} = \\sum p_{ij},i=1,2,\\cdots $$\n$$ p_{ij}=P \\left\\{ Y=y_{j}\\right\\} = \\sum _{ij},j=1,2,\\cdots $$\n为(X，Y)关于X和Y的边缘概率分布.\n\n简记表中的一行或者一列。\n\n### 条件概率分布的定义\n\n条件概率分布的定义 设二维随机变量(X，Y)的联合概率分布为\n$$ P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2\\cdots $$称$$ P \\left\\{ X=x_{i}|Y=y_{j}\\right\\} = \\frac{P_{ij}}{p_{\\bullet j}} $$为在$$ Y=y_{j} $$的条件下，X的条件概率分布;称$$ P \\left\\{ Y=y_{j}|X=x_{i}\\right\\} = \\frac{p_{ij}}{p_{i\\bullet}} $$为在$$ X=x_{i} $$的条件下，Y的条件概率分布.\n\n## 性质\n\n\n\n# 二维连续\n\n## 定义\n\n### 联合概率密度定义\n\n### 边缘概率密度的定义\n\n### 条件概率密度的定义\n\n条件概率密度的定义 设二维随机变量(X，Y)的联合概率密度为f(x，y),称$$ f_{X|Y}(x|y)= \\frac{f(x,y)}{f_{Y}(y)} $$\n为在$$ Y=y $$的条件下，X的条件概率密度;称$$ f_{\\gamma |x}(y|x)= \\frac{f(x,y)}{f_{x}(x)} $$为在$$ X=x $$的条件下，Y的条件概率密度.\n\n## 性质\n\n- 非负性\n- 规范性\n- 计算随机变量取值的概率 $$ P \\left\\{(X,Y)\\in D \\right\\} = \\int \\int f(x,y)dxdy. $$\n\n性质(1)，(2)是判定概率密度的充要条件;性质(3)用于计算随机变量取值的概率\n\n# 随机变量的独立性\n\n## 定义\n\n随机变量相互独立的定义 设二维随机变量(X，Y)的联合分布函数为F(x，y),边缘分布函数分别为$$ F_{x}(x) $$和 $$ F_{1} $$(y),若对任意实数x，y,有$$ F(x,y)=F_{X}(x)F_{Y}(y) $$，则称随机变量X与Y相互独立.\n\n## 充要条件\n\n$$\nX与Y相互独立 \\\\ \n\\begin{matrix}\n& \\Leftrightarrow  F(x,y)=F_{x}(x)F_{Y}(y) \\\\\n& \\Leftrightarrow p_{ij}=p_{i\\bullet}p_{\\bullet j} \\\\ \n& \\Leftrightarrow f(x,y)=f_{x}(x)f_{Y}(y) \n\\end{matrix}\n$$\n\n\n\n# 二维均匀分布与二维正态分布\n\n## 二维均匀分布\n\n设二维随机变量(X，Y)的联合概率密度为\n$$ f(x,y)= \\begin{cases} \\frac{1}{S_{D}},(x,y)\\in D \\\\ 0,其他 \\\\ \\end{cases}  $$\n称(X，Y)服从区域D上的均匀分布，记作(X，Y)~U(D)\n\n### 二维均匀分布性质（充要条件）\n\n设$$ (X,Y)\\sim U(a,b)\\times(c,d)  \\ \\ \\ \\Leftrightarrow $$，则$$ X \\sim U(a,b),Y \\sim U(c,d) $$，且X与Y相互独立. 【两个一维的均匀分布（相互独立）的联合随机变量复合其两个区间组成的矩形】\n\n## 二维正态分布\n\n设二维随机变量(X，Y)的联合概率密度为\n$$\nf(x,y)= \\frac{1}{2 \\pi \\sigma _{1}\\sigma _{2}\\sqrt{1- \\rho ^{2}}}e^{-\\frac{1}{2(1- \\rho ^{2})}\\left[(\\frac{x- \\mu _{1}}{\\sigma _{1}})^{2}- \\frac{2 \\rho(x- \\mu _{1})(y- \\mu _{2})}{\\sigma _{1}\\sigma _{2}}+(\\frac{y- \\mu _{2}}{\\sigma _{2}})^{2}\\right] } \n$$\n其中$$  \\sigma _{1}>0, \\sigma _{2}>0,| \\rho |<1 $$，称(X，Y)服从参数为 $$  \\mu _{1} $$，$$  \\mu _{2} $$，$$  \\sigma _{1} $$，$$  \\sigma _{2} $$，p的二维正态分布，记\n(X,Y)~N( $$  \\mu _{1} $$，$$  \\mu _{2} $$; $$  \\sigma _{1}^{2} $$，$$  \\sigma _{2}^{2} $$;ρ)\n\n### 二维正态分布的性质\n\n- 设$$ (X，Y)\\sim N(  \\mu _{1} ，\\mu _{2} ;   \\sigma _{1}^{2} , \\sigma _{2}^{2} ;\\rho)$$,则 $$X\\sim N( \\mu _{1} ，  \\sigma _{1}^{2} ),Y\\sim N( \\mu _{2} ，  \\sigma _{2}^{2} )$$,反之不成立;\n\n- X与Y相互独立X与Y不相关$$ (\\rho =0 $$);\n\n- 相互独立的正态分布的线性组合任然为正态分布\n\n  $$ aX+bY \\sim N(a \\mu _{1}+b \\mu _{2},a^{2}\\sigma _{1}^{2}+b^{2}\\sigma _{2}^{2}+2ab \\rho \\sigma _{1}\\sigma _{2}); $$\n\n  特别的若X与Y相互独立，X~N( $$  \\mu _{1} $$，$$  \\sigma _{1}^{2} $$),Y~N( $$  \\mu _{2} $$，$$  \\sigma _{2}^{2} $$),则\n\n- 若$$ U=aX+bY,V=cX+dY $$，即U\n  $$ \\begin{pmatrix}U \\\\ V \\\\ \\end{pmatrix} = \\begin{pmatrix} a \\boxed b \\\\ c \\boxed d \\\\ \\end{pmatrix} \\begin{pmatrix} X \\\\ Y \\\\ \\end{pmatrix} $$，则(U，V)服从二维正态分布，二维正太经过可逆线性变换任然为二维正态。\n  ,\n\n# 二维随机变量函数的分布\n\n## 二维离散型\n\n## 二维连续型随机变量函数的分布 \n\n### 分布函数法\n\n### 公式带入\n","slug":"考研数学（概率论部分，第三章）学习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmb000ibsuo4yt3dg66","content":"<p>[toc]</p>\n<p>第二章中的所有的概率分布的类型一定还要特别熟悉！！！</p>\n<h1 id=\"二维随机变量及其分布\"><a href=\"#二维随机变量及其分布\" class=\"headerlink\" title=\"二维随机变量及其分布\"></a>二维随机变量及其分布</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><h3 id=\"二维随机变量的定义\"><a href=\"#二维随机变量的定义\" class=\"headerlink\" title=\"二维随机变量的定义\"></a>二维随机变量的定义</h3><p>二维随机变量的定义 设<script type=\"math/tex\">X=Y(\\omega),Y=Y(\\omega)</script>为样本空间Ω上的两个随机变量，称(X，Y)为二维随机变量</p>\n<h3 id=\"联合（二维）分布函数的定义\"><a href=\"#联合（二维）分布函数的定义\" class=\"headerlink\" title=\"联合（二维）分布函数的定义\"></a>联合（二维）分布函数的定义</h3><p>联合分布函数的定义 设(X，Y)为二维随机变量，对任意实数x，y,称<script type=\"math/tex\">F(x,y)=P \\left\\{ X \\leq x,Y \\leq y\\right\\}</script>为(X,Y)的联合分布函数，简称分布函数。可以将其中的<script type=\"math/tex\">P \\left\\{ X \\leq x,Y \\leq y\\right\\}</script>看作是 <script type=\"math/tex\">P(AB),\\ \\ \\ A\\sim X \\leq x \\ \\ \\  B \\sim Y \\leq y</script></p>\n<h3 id=\"边缘分布函数的定义\"><a href=\"#边缘分布函数的定义\" class=\"headerlink\" title=\"边缘分布函数的定义\"></a>边缘分布函数的定义</h3><p>设二维随机变量(X，Y)的联合分布函数为F(x，y),分别称</p>\n<script type=\"math/tex; mode=display\">\nF_{X}(x)=P \\left\\{ X \\leq x \\right\\} =P \\left\\{ X \\leq x,Y \\leq + \\infty \\right\\} =F(x,+ \\infty) \\\\\nF_{Y}(y)=P \\left\\{ Y \\leq y \\right\\} =P \\left\\{ X \\leq + \\infty ,Y \\leq y \\right\\} =F(+ \\infty ,y)</script><p>为(X，Y)关于X和Y的边缘分布函数.</p>\n<h3 id=\"独立性的充要条件\"><a href=\"#独立性的充要条件\" class=\"headerlink\" title=\"独立性的充要条件\"></a>独立性的充要条件</h3><p>如果联合分布函数中 边缘分布函数的乘积等于联合分布函数的乘积那么就是两个独立事件。</p>\n<h2 id=\"性质-5（构成充要条件）\"><a href=\"#性质-5（构成充要条件）\" class=\"headerlink\" title=\"性质 5（构成充要条件）\"></a>性质 5（构成充要条件）</h2><ul>\n<li>非负性</li>\n<li>规范性<script type=\"math/tex\">F(- \\infty ,y)=F(x,- \\infty)=F(- \\infty ,- \\infty)=0,F(+ \\infty ,+ \\infty)=1;</script></li>\n<li>单调不减</li>\n<li>右连续</li>\n<li>计算 <script type=\"math/tex\">P \\left\\{ a<X \\leq b,c<Y \\leq d \\right\\} =F(b,d)-F(b,c)-F(a,d)+F(a,c)</script>矩形域。想想前缀和。</li>\n</ul>\n<div class=\"tabs\" id=\"判断一个分布函数是否是联合分布函数\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#判断一个分布函数是否是联合分布函数-1\">例题</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#判断一个分布函数是否是联合分布函数-2\">如何快速判断一个函数是否是一个一维的分布函数</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"判断一个分布函数是否是联合分布函数-1\"><p>【例3.1】下列四个函数哪个不能作为联合分布函数</p>\n<script type=\"math/tex; mode=display\">(A)  F_{1} (x,y)= \\begin{cases}  (1-e^{-x})(1-e^{-y}),x>0,y>0  \\\\  0, 其他 \\end{cases}</script><script type=\"math/tex; mode=display\">(B) F_{2}(x,y)= \\frac{1}{\\pi ^{2}}(\\frac{\\pi}{2}+ \\arctan \\frac{x}{2})(\\frac{\\pi}{2}+ \\arctan \\frac{y}{3})</script><script type=\"math/tex; mode=display\">(C)  F_{3} $$(x,y)=$$\\left\\{ \\begin{matrix}  1,x+2y \\geq 1  \\\\  0,x+2y<1  \\end{matrix} \\right.</script><script type=\"math/tex; mode=display\">(D) F_{4} (x,y)= \\begin{cases}  1-2^{-x}-2^{-y}+2^{-x-y} , x>0  ,y \\geq 0  \\\\  0，其他 \\end{cases}</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"判断一个分布函数是否是联合分布函数-2\"><p>使用分布函数的四条性质（充要条件）</p>\n<p>非负性、规范性、右连续、单调不减</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"二维离散型随机变量\"><a href=\"#二维离散型随机变量\" class=\"headerlink\" title=\"二维离散型随机变量\"></a>二维离散型随机变量</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>一定要分清 概率分布和分布函数之间的关系，（离散中，概率分布是点，一个特殊的样本点出现的概率） 而分布函数是一个样本几何的出现概率</p>\n<h3 id=\"联合概率分布\"><a href=\"#联合概率分布\" class=\"headerlink\" title=\"联合概率分布\"></a>联合概率分布</h3><p>联合概率分布的定义 设二维随机变量(X，Y)的取值为有限个或可列个，称(X，Y)为二维离散型随机变量.设(X，Y)的取值为( <script type=\"math/tex\">x_{1}</script>，<script type=\"math/tex\">y_{j}</script>),i<script type=\"math/tex\">j=1,2</script>，…,称<script type=\"math/tex\">P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{i,},i,j=1,2</script>…为(X，Y)的联合概<br>率分布，简称概率分布，也可用列表法表示.</p>\n<p>简记：一张表！</p>\n<h3 id=\"边缘概率分布\"><a href=\"#边缘概率分布\" class=\"headerlink\" title=\"边缘概率分布\"></a>边缘概率分布</h3><p>边缘概率分布的定义 设二维随机变量(X，Y)的联合概率分布为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2, $$，...,分别称\n$$ p_{i}.=P \\left\\{ X=x_{i}\\right\\} = \\sum p_{ij},i=1,2,\\cdots</script><script type=\"math/tex; mode=display\">p_{ij}=P \\left\\{ Y=y_{j}\\right\\} = \\sum _{ij},j=1,2,\\cdots</script><p>为(X，Y)关于X和Y的边缘概率分布.</p>\n<p>简记表中的一行或者一列。</p>\n<h3 id=\"条件概率分布的定义\"><a href=\"#条件概率分布的定义\" class=\"headerlink\" title=\"条件概率分布的定义\"></a>条件概率分布的定义</h3><p>条件概率分布的定义 设二维随机变量(X，Y)的联合概率分布为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2\\cdots $$称$$ P \\left\\{ X=x_{i}|Y=y_{j}\\right\\} = \\frac{P_{ij}}{p_{\\bullet j}} $$为在$$ Y=y_{j} $$的条件下，X的条件概率分布;称$$ P \\left\\{ Y=y_{j}|X=x_{i}\\right\\} = \\frac{p_{ij}}{p_{i\\bullet}} $$为在$$ X=x_{i} $$的条件下，Y的条件概率分布.\n\n## 性质\n\n\n\n# 二维连续\n\n## 定义\n\n### 联合概率密度定义\n\n### 边缘概率密度的定义\n\n### 条件概率密度的定义\n\n条件概率密度的定义 设二维随机变量(X，Y)的联合概率密度为f(x，y),称$$ f_{X|Y}(x|y)= \\frac{f(x,y)}{f_{Y}(y)}</script><p>为在<script type=\"math/tex\">Y=y</script>的条件下，X的条件概率密度;称<script type=\"math/tex\">f_{\\gamma |x}(y|x)= \\frac{f(x,y)}{f_{x}(x)}</script>为在<script type=\"math/tex\">X=x</script>的条件下，Y的条件概率密度.</p>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><ul>\n<li>非负性</li>\n<li>规范性</li>\n<li>计算随机变量取值的概率 <script type=\"math/tex\">P \\left\\{(X,Y)\\in D \\right\\} = \\int \\int f(x,y)dxdy.</script></li>\n</ul>\n<p>性质(1)，(2)是判定概率密度的充要条件;性质(3)用于计算随机变量取值的概率</p>\n<h1 id=\"随机变量的独立性\"><a href=\"#随机变量的独立性\" class=\"headerlink\" title=\"随机变量的独立性\"></a>随机变量的独立性</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>随机变量相互独立的定义 设二维随机变量(X，Y)的联合分布函数为F(x，y),边缘分布函数分别为<script type=\"math/tex\">F_{x}(x)</script>和 <script type=\"math/tex\">F_{1}</script>(y),若对任意实数x，y,有<script type=\"math/tex\">F(x,y)=F_{X}(x)F_{Y}(y)</script>，则称随机变量X与Y相互独立.</p>\n<h2 id=\"充要条件\"><a href=\"#充要条件\" class=\"headerlink\" title=\"充要条件\"></a>充要条件</h2><script type=\"math/tex; mode=display\">\nX与Y相互独立 \\\\ \n\\begin{matrix}\n& \\Leftrightarrow  F(x,y)=F_{x}(x)F_{Y}(y) \\\\\n& \\Leftrightarrow p_{ij}=p_{i\\bullet}p_{\\bullet j} \\\\ \n& \\Leftrightarrow f(x,y)=f_{x}(x)f_{Y}(y) \n\\end{matrix}</script><h1 id=\"二维均匀分布与二维正态分布\"><a href=\"#二维均匀分布与二维正态分布\" class=\"headerlink\" title=\"二维均匀分布与二维正态分布\"></a>二维均匀分布与二维正态分布</h1><h2 id=\"二维均匀分布\"><a href=\"#二维均匀分布\" class=\"headerlink\" title=\"二维均匀分布\"></a>二维均匀分布</h2><p>设二维随机变量(X，Y)的联合概率密度为</p>\n<script type=\"math/tex; mode=display\">f(x,y)= \\begin{cases} \\frac{1}{S_{D}},(x,y)\\in D \\\\ 0,其他 \\\\ \\end{cases}</script><p>称(X，Y)服从区域D上的均匀分布，记作(X，Y)~U(D)</p>\n<h3 id=\"二维均匀分布性质（充要条件）\"><a href=\"#二维均匀分布性质（充要条件）\" class=\"headerlink\" title=\"二维均匀分布性质（充要条件）\"></a>二维均匀分布性质（充要条件）</h3><p>设<script type=\"math/tex\">(X,Y)\\sim U(a,b)\\times(c,d)  \\ \\ \\ \\Leftrightarrow</script>，则<script type=\"math/tex\">X \\sim U(a,b),Y \\sim U(c,d)</script>，且X与Y相互独立. 【两个一维的均匀分布（相互独立）的联合随机变量复合其两个区间组成的矩形】</p>\n<h2 id=\"二维正态分布\"><a href=\"#二维正态分布\" class=\"headerlink\" title=\"二维正态分布\"></a>二维正态分布</h2><p>设二维随机变量(X，Y)的联合概率密度为</p>\n<script type=\"math/tex; mode=display\">\nf(x,y)= \\frac{1}{2 \\pi \\sigma _{1}\\sigma _{2}\\sqrt{1- \\rho ^{2}}}e^{-\\frac{1}{2(1- \\rho ^{2})}\\left[(\\frac{x- \\mu _{1}}{\\sigma _{1}})^{2}- \\frac{2 \\rho(x- \\mu _{1})(y- \\mu _{2})}{\\sigma _{1}\\sigma _{2}}+(\\frac{y- \\mu _{2}}{\\sigma _{2}})^{2}\\right] }</script><p>其中<script type=\"math/tex\">\\sigma _{1}>0, \\sigma _{2}>0,| \\rho |<1</script>，称(X，Y)服从参数为 <script type=\"math/tex\">\\mu _{1}</script>，<script type=\"math/tex\">\\mu _{2}</script>，<script type=\"math/tex\">\\sigma _{1}</script>，<script type=\"math/tex\">\\sigma _{2}</script>，p的二维正态分布，记<br>(X,Y)~N( <script type=\"math/tex\">\\mu _{1}</script>，<script type=\"math/tex\">\\mu _{2}</script>; <script type=\"math/tex\">\\sigma _{1}^{2}</script>，<script type=\"math/tex\">\\sigma _{2}^{2}</script>;ρ)</p>\n<h3 id=\"二维正态分布的性质\"><a href=\"#二维正态分布的性质\" class=\"headerlink\" title=\"二维正态分布的性质\"></a>二维正态分布的性质</h3><ul>\n<li><p>设<script type=\"math/tex\">(X，Y)\\sim N(  \\mu _{1} ，\\mu _{2} ;   \\sigma _{1}^{2} , \\sigma _{2}^{2} ;\\rho)</script>,则 <script type=\"math/tex\">X\\sim N( \\mu _{1} ，  \\sigma _{1}^{2} ),Y\\sim N( \\mu _{2} ，  \\sigma _{2}^{2} )</script>,反之不成立;</p>\n</li>\n<li><p>X与Y相互独立X与Y不相关<script type=\"math/tex\">(\\rho =0</script>);</p>\n</li>\n<li><p>相互独立的正态分布的线性组合任然为正态分布</p>\n<script type=\"math/tex; mode=display\">aX+bY \\sim N(a \\mu _{1}+b \\mu _{2},a^{2}\\sigma _{1}^{2}+b^{2}\\sigma _{2}^{2}+2ab \\rho \\sigma _{1}\\sigma _{2});</script><p>特别的若X与Y相互独立，X~N( <script type=\"math/tex\">\\mu _{1}</script>，<script type=\"math/tex\">\\sigma _{1}^{2}</script>),Y~N( <script type=\"math/tex\">\\mu _{2}</script>，<script type=\"math/tex\">\\sigma _{2}^{2}</script>),则</p>\n</li>\n<li><p>若<script type=\"math/tex\">U=aX+bY,V=cX+dY</script>，即U<br><script type=\"math/tex\">\\begin{pmatrix}U \\\\ V \\\\ \\end{pmatrix} = \\begin{pmatrix} a \\boxed b \\\\ c \\boxed d \\\\ \\end{pmatrix} \\begin{pmatrix} X \\\\ Y \\\\ \\end{pmatrix}</script>，则(U，V)服从二维正态分布，二维正太经过可逆线性变换任然为二维正态。<br>,</p>\n</li>\n</ul>\n<h1 id=\"二维随机变量函数的分布\"><a href=\"#二维随机变量函数的分布\" class=\"headerlink\" title=\"二维随机变量函数的分布\"></a>二维随机变量函数的分布</h1><h2 id=\"二维离散型\"><a href=\"#二维离散型\" class=\"headerlink\" title=\"二维离散型\"></a>二维离散型</h2><h2 id=\"二维连续型随机变量函数的分布\"><a href=\"#二维连续型随机变量函数的分布\" class=\"headerlink\" title=\"二维连续型随机变量函数的分布\"></a>二维连续型随机变量函数的分布</h2><h3 id=\"分布函数法\"><a href=\"#分布函数法\" class=\"headerlink\" title=\"分布函数法\"></a>分布函数法</h3><h3 id=\"公式带入\"><a href=\"#公式带入\" class=\"headerlink\" title=\"公式带入\"></a>公式带入</h3>","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<p>[toc]</p>\n<p>第二章中的所有的概率分布的类型一定还要特别熟悉！！！</p>\n<h1 id=\"二维随机变量及其分布\"><a href=\"#二维随机变量及其分布\" class=\"headerlink\" title=\"二维随机变量及其分布\"></a>二维随机变量及其分布</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><h3 id=\"二维随机变量的定义\"><a href=\"#二维随机变量的定义\" class=\"headerlink\" title=\"二维随机变量的定义\"></a>二维随机变量的定义</h3><p>二维随机变量的定义 设<script type=\"math/tex\">X=Y(\\omega),Y=Y(\\omega)</script>为样本空间Ω上的两个随机变量，称(X，Y)为二维随机变量</p>\n<h3 id=\"联合（二维）分布函数的定义\"><a href=\"#联合（二维）分布函数的定义\" class=\"headerlink\" title=\"联合（二维）分布函数的定义\"></a>联合（二维）分布函数的定义</h3><p>联合分布函数的定义 设(X，Y)为二维随机变量，对任意实数x，y,称<script type=\"math/tex\">F(x,y)=P \\left\\{ X \\leq x,Y \\leq y\\right\\}</script>为(X,Y)的联合分布函数，简称分布函数。可以将其中的<script type=\"math/tex\">P \\left\\{ X \\leq x,Y \\leq y\\right\\}</script>看作是 <script type=\"math/tex\">P(AB),\\ \\ \\ A\\sim X \\leq x \\ \\ \\  B \\sim Y \\leq y</script></p>\n<h3 id=\"边缘分布函数的定义\"><a href=\"#边缘分布函数的定义\" class=\"headerlink\" title=\"边缘分布函数的定义\"></a>边缘分布函数的定义</h3><p>设二维随机变量(X，Y)的联合分布函数为F(x，y),分别称</p>\n<script type=\"math/tex; mode=display\">\nF_{X}(x)=P \\left\\{ X \\leq x \\right\\} =P \\left\\{ X \\leq x,Y \\leq + \\infty \\right\\} =F(x,+ \\infty) \\\\\nF_{Y}(y)=P \\left\\{ Y \\leq y \\right\\} =P \\left\\{ X \\leq + \\infty ,Y \\leq y \\right\\} =F(+ \\infty ,y)</script><p>为(X，Y)关于X和Y的边缘分布函数.</p>\n<h3 id=\"独立性的充要条件\"><a href=\"#独立性的充要条件\" class=\"headerlink\" title=\"独立性的充要条件\"></a>独立性的充要条件</h3><p>如果联合分布函数中 边缘分布函数的乘积等于联合分布函数的乘积那么就是两个独立事件。</p>\n<h2 id=\"性质-5（构成充要条件）\"><a href=\"#性质-5（构成充要条件）\" class=\"headerlink\" title=\"性质 5（构成充要条件）\"></a>性质 5（构成充要条件）</h2><ul>\n<li>非负性</li>\n<li>规范性<script type=\"math/tex\">F(- \\infty ,y)=F(x,- \\infty)=F(- \\infty ,- \\infty)=0,F(+ \\infty ,+ \\infty)=1;</script></li>\n<li>单调不减</li>\n<li>右连续</li>\n<li>计算 <script type=\"math/tex\">P \\left\\{ a<X \\leq b,c<Y \\leq d \\right\\} =F(b,d)-F(b,c)-F(a,d)+F(a,c)</script>矩形域。想想前缀和。</li>\n</ul>\n<div class=\"tabs\" id=\"判断一个分布函数是否是联合分布函数\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#判断一个分布函数是否是联合分布函数-1\">例题</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#判断一个分布函数是否是联合分布函数-2\">如何快速判断一个函数是否是一个一维的分布函数</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"判断一个分布函数是否是联合分布函数-1\"><p>【例3.1】下列四个函数哪个不能作为联合分布函数</p>\n<script type=\"math/tex; mode=display\">(A)  F_{1} (x,y)= \\begin{cases}  (1-e^{-x})(1-e^{-y}),x>0,y>0  \\\\  0, 其他 \\end{cases}</script><script type=\"math/tex; mode=display\">(B) F_{2}(x,y)= \\frac{1}{\\pi ^{2}}(\\frac{\\pi}{2}+ \\arctan \\frac{x}{2})(\\frac{\\pi}{2}+ \\arctan \\frac{y}{3})</script><script type=\"math/tex; mode=display\">(C)  F_{3} $$(x,y)=$$\\left\\{ \\begin{matrix}  1,x+2y \\geq 1  \\\\  0,x+2y<1  \\end{matrix} \\right.</script><script type=\"math/tex; mode=display\">(D) F_{4} (x,y)= \\begin{cases}  1-2^{-x}-2^{-y}+2^{-x-y} , x>0  ,y \\geq 0  \\\\  0，其他 \\end{cases}</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"判断一个分布函数是否是联合分布函数-2\"><p>使用分布函数的四条性质（充要条件）</p>\n<p>非负性、规范性、右连续、单调不减</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"二维离散型随机变量\"><a href=\"#二维离散型随机变量\" class=\"headerlink\" title=\"二维离散型随机变量\"></a>二维离散型随机变量</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>一定要分清 概率分布和分布函数之间的关系，（离散中，概率分布是点，一个特殊的样本点出现的概率） 而分布函数是一个样本几何的出现概率</p>\n<h3 id=\"联合概率分布\"><a href=\"#联合概率分布\" class=\"headerlink\" title=\"联合概率分布\"></a>联合概率分布</h3><p>联合概率分布的定义 设二维随机变量(X，Y)的取值为有限个或可列个，称(X，Y)为二维离散型随机变量.设(X，Y)的取值为( <script type=\"math/tex\">x_{1}</script>，<script type=\"math/tex\">y_{j}</script>),i<script type=\"math/tex\">j=1,2</script>，…,称<script type=\"math/tex\">P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{i,},i,j=1,2</script>…为(X，Y)的联合概<br>率分布，简称概率分布，也可用列表法表示.</p>\n<p>简记：一张表！</p>\n<h3 id=\"边缘概率分布\"><a href=\"#边缘概率分布\" class=\"headerlink\" title=\"边缘概率分布\"></a>边缘概率分布</h3><p>边缘概率分布的定义 设二维随机变量(X，Y)的联合概率分布为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2, $$，...,分别称\n$$ p_{i}.=P \\left\\{ X=x_{i}\\right\\} = \\sum p_{ij},i=1,2,\\cdots</script><script type=\"math/tex; mode=display\">p_{ij}=P \\left\\{ Y=y_{j}\\right\\} = \\sum _{ij},j=1,2,\\cdots</script><p>为(X，Y)关于X和Y的边缘概率分布.</p>\n<p>简记表中的一行或者一列。</p>\n<h3 id=\"条件概率分布的定义\"><a href=\"#条件概率分布的定义\" class=\"headerlink\" title=\"条件概率分布的定义\"></a>条件概率分布的定义</h3><p>条件概率分布的定义 设二维随机变量(X，Y)的联合概率分布为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2\\cdots $$称$$ P \\left\\{ X=x_{i}|Y=y_{j}\\right\\} = \\frac{P_{ij}}{p_{\\bullet j}} $$为在$$ Y=y_{j} $$的条件下，X的条件概率分布;称$$ P \\left\\{ Y=y_{j}|X=x_{i}\\right\\} = \\frac{p_{ij}}{p_{i\\bullet}} $$为在$$ X=x_{i} $$的条件下，Y的条件概率分布.\n\n## 性质\n\n\n\n# 二维连续\n\n## 定义\n\n### 联合概率密度定义\n\n### 边缘概率密度的定义\n\n### 条件概率密度的定义\n\n条件概率密度的定义 设二维随机变量(X，Y)的联合概率密度为f(x，y),称$$ f_{X|Y}(x|y)= \\frac{f(x,y)}{f_{Y}(y)}</script><p>为在<script type=\"math/tex\">Y=y</script>的条件下，X的条件概率密度;称<script type=\"math/tex\">f_{\\gamma |x}(y|x)= \\frac{f(x,y)}{f_{x}(x)}</script>为在<script type=\"math/tex\">X=x</script>的条件下，Y的条件概率密度.</p>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><ul>\n<li>非负性</li>\n<li>规范性</li>\n<li>计算随机变量取值的概率 <script type=\"math/tex\">P \\left\\{(X,Y)\\in D \\right\\} = \\int \\int f(x,y)dxdy.</script></li>\n</ul>\n<p>性质(1)，(2)是判定概率密度的充要条件;性质(3)用于计算随机变量取值的概率</p>\n<h1 id=\"随机变量的独立性\"><a href=\"#随机变量的独立性\" class=\"headerlink\" title=\"随机变量的独立性\"></a>随机变量的独立性</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>随机变量相互独立的定义 设二维随机变量(X，Y)的联合分布函数为F(x，y),边缘分布函数分别为<script type=\"math/tex\">F_{x}(x)</script>和 <script type=\"math/tex\">F_{1}</script>(y),若对任意实数x，y,有<script type=\"math/tex\">F(x,y)=F_{X}(x)F_{Y}(y)</script>，则称随机变量X与Y相互独立.</p>\n<h2 id=\"充要条件\"><a href=\"#充要条件\" class=\"headerlink\" title=\"充要条件\"></a>充要条件</h2><script type=\"math/tex; mode=display\">\nX与Y相互独立 \\\\ \n\\begin{matrix}\n& \\Leftrightarrow  F(x,y)=F_{x}(x)F_{Y}(y) \\\\\n& \\Leftrightarrow p_{ij}=p_{i\\bullet}p_{\\bullet j} \\\\ \n& \\Leftrightarrow f(x,y)=f_{x}(x)f_{Y}(y) \n\\end{matrix}</script><h1 id=\"二维均匀分布与二维正态分布\"><a href=\"#二维均匀分布与二维正态分布\" class=\"headerlink\" title=\"二维均匀分布与二维正态分布\"></a>二维均匀分布与二维正态分布</h1><h2 id=\"二维均匀分布\"><a href=\"#二维均匀分布\" class=\"headerlink\" title=\"二维均匀分布\"></a>二维均匀分布</h2><p>设二维随机变量(X，Y)的联合概率密度为</p>\n<script type=\"math/tex; mode=display\">f(x,y)= \\begin{cases} \\frac{1}{S_{D}},(x,y)\\in D \\\\ 0,其他 \\\\ \\end{cases}</script><p>称(X，Y)服从区域D上的均匀分布，记作(X，Y)~U(D)</p>\n<h3 id=\"二维均匀分布性质（充要条件）\"><a href=\"#二维均匀分布性质（充要条件）\" class=\"headerlink\" title=\"二维均匀分布性质（充要条件）\"></a>二维均匀分布性质（充要条件）</h3><p>设<script type=\"math/tex\">(X,Y)\\sim U(a,b)\\times(c,d)  \\ \\ \\ \\Leftrightarrow</script>，则<script type=\"math/tex\">X \\sim U(a,b),Y \\sim U(c,d)</script>，且X与Y相互独立. 【两个一维的均匀分布（相互独立）的联合随机变量复合其两个区间组成的矩形】</p>\n<h2 id=\"二维正态分布\"><a href=\"#二维正态分布\" class=\"headerlink\" title=\"二维正态分布\"></a>二维正态分布</h2><p>设二维随机变量(X，Y)的联合概率密度为</p>\n<script type=\"math/tex; mode=display\">\nf(x,y)= \\frac{1}{2 \\pi \\sigma _{1}\\sigma _{2}\\sqrt{1- \\rho ^{2}}}e^{-\\frac{1}{2(1- \\rho ^{2})}\\left[(\\frac{x- \\mu _{1}}{\\sigma _{1}})^{2}- \\frac{2 \\rho(x- \\mu _{1})(y- \\mu _{2})}{\\sigma _{1}\\sigma _{2}}+(\\frac{y- \\mu _{2}}{\\sigma _{2}})^{2}\\right] }</script><p>其中<script type=\"math/tex\">\\sigma _{1}>0, \\sigma _{2}>0,| \\rho |<1</script>，称(X，Y)服从参数为 <script type=\"math/tex\">\\mu _{1}</script>，<script type=\"math/tex\">\\mu _{2}</script>，<script type=\"math/tex\">\\sigma _{1}</script>，<script type=\"math/tex\">\\sigma _{2}</script>，p的二维正态分布，记<br>(X,Y)~N( <script type=\"math/tex\">\\mu _{1}</script>，<script type=\"math/tex\">\\mu _{2}</script>; <script type=\"math/tex\">\\sigma _{1}^{2}</script>，<script type=\"math/tex\">\\sigma _{2}^{2}</script>;ρ)</p>\n<h3 id=\"二维正态分布的性质\"><a href=\"#二维正态分布的性质\" class=\"headerlink\" title=\"二维正态分布的性质\"></a>二维正态分布的性质</h3><ul>\n<li><p>设<script type=\"math/tex\">(X，Y)\\sim N(  \\mu _{1} ，\\mu _{2} ;   \\sigma _{1}^{2} , \\sigma _{2}^{2} ;\\rho)</script>,则 <script type=\"math/tex\">X\\sim N( \\mu _{1} ，  \\sigma _{1}^{2} ),Y\\sim N( \\mu _{2} ，  \\sigma _{2}^{2} )</script>,反之不成立;</p>\n</li>\n<li><p>X与Y相互独立X与Y不相关<script type=\"math/tex\">(\\rho =0</script>);</p>\n</li>\n<li><p>相互独立的正态分布的线性组合任然为正态分布</p>\n<script type=\"math/tex; mode=display\">aX+bY \\sim N(a \\mu _{1}+b \\mu _{2},a^{2}\\sigma _{1}^{2}+b^{2}\\sigma _{2}^{2}+2ab \\rho \\sigma _{1}\\sigma _{2});</script><p>特别的若X与Y相互独立，X~N( <script type=\"math/tex\">\\mu _{1}</script>，<script type=\"math/tex\">\\sigma _{1}^{2}</script>),Y~N( <script type=\"math/tex\">\\mu _{2}</script>，<script type=\"math/tex\">\\sigma _{2}^{2}</script>),则</p>\n</li>\n<li><p>若<script type=\"math/tex\">U=aX+bY,V=cX+dY</script>，即U<br><script type=\"math/tex\">\\begin{pmatrix}U \\\\ V \\\\ \\end{pmatrix} = \\begin{pmatrix} a \\boxed b \\\\ c \\boxed d \\\\ \\end{pmatrix} \\begin{pmatrix} X \\\\ Y \\\\ \\end{pmatrix}</script>，则(U，V)服从二维正态分布，二维正太经过可逆线性变换任然为二维正态。<br>,</p>\n</li>\n</ul>\n<h1 id=\"二维随机变量函数的分布\"><a href=\"#二维随机变量函数的分布\" class=\"headerlink\" title=\"二维随机变量函数的分布\"></a>二维随机变量函数的分布</h1><h2 id=\"二维离散型\"><a href=\"#二维离散型\" class=\"headerlink\" title=\"二维离散型\"></a>二维离散型</h2><h2 id=\"二维连续型随机变量函数的分布\"><a href=\"#二维连续型随机变量函数的分布\" class=\"headerlink\" title=\"二维连续型随机变量函数的分布\"></a>二维连续型随机变量函数的分布</h2><h3 id=\"分布函数法\"><a href=\"#分布函数法\" class=\"headerlink\" title=\"分布函数法\"></a>分布函数法</h3><h3 id=\"公式带入\"><a href=\"#公式带入\" class=\"headerlink\" title=\"公式带入\"></a>公式带入</h3>"},{"title":"c++中的输入","copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-03-29T05:27:08.000Z","updated":"2023-03-29T05:27:08.000Z","cover":"https://resource.ninoneumann.cn/Cover_img/86446119_p0.png","_content":"\n# 记录一下程序设计中遇到的c++输入形式\n## cin\n\n以空格和换行符作为结束的标志，（不读入这两个字符）所以在cin和getline的组合运用中一定要注意。\n\n性能差，但是可以通过\n\n```C++\nstd::ios::sync_with_stdio(false);\n```\n\n将其速度优化到和scanf差不多。\n\n应用场景：一连串读入 （空格分隔 或者 回车分割）\n\n```\n1 2 3 4 5 6\n1\n2\n3\n4\n5\n6\n-------------------\ncin>>a;\n```\n\n## scanf()\n\n性能好 ;\n\n应用场景和cin差不多\n\n## getchar()\n\n读一个字符\n\n## getline()\n\n读入一行 以回车为分隔。\n\n通过换行符确定读入边界，最后将换行符丢弃掉。一般读入一个str\n\n```c++\nstring str;\ngetline(cin,str);\n```\n\n\n\n## cin getline 组合运用\n\n先使用cin 再使用getline的场景下一定要再使用完cin后面读入换行符要不然getline会多读一个空白字符。\n\n","source":"_posts/c-中的输入.md","raw":"---\ntitle: c++中的输入\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-03-29 13:27:08\nupdated: 2023-03-29 13:27:08\ntags:\n- c++\ncategories:\n- 算法\ncover: https://resource.ninoneumann.cn/Cover_img/86446119_p0.png\n---\n\n# 记录一下程序设计中遇到的c++输入形式\n## cin\n\n以空格和换行符作为结束的标志，（不读入这两个字符）所以在cin和getline的组合运用中一定要注意。\n\n性能差，但是可以通过\n\n```C++\nstd::ios::sync_with_stdio(false);\n```\n\n将其速度优化到和scanf差不多。\n\n应用场景：一连串读入 （空格分隔 或者 回车分割）\n\n```\n1 2 3 4 5 6\n1\n2\n3\n4\n5\n6\n-------------------\ncin>>a;\n```\n\n## scanf()\n\n性能好 ;\n\n应用场景和cin差不多\n\n## getchar()\n\n读一个字符\n\n## getline()\n\n读入一行 以回车为分隔。\n\n通过换行符确定读入边界，最后将换行符丢弃掉。一般读入一个str\n\n```c++\nstring str;\ngetline(cin,str);\n```\n\n\n\n## cin getline 组合运用\n\n先使用cin 再使用getline的场景下一定要再使用完cin后面读入换行符要不然getline会多读一个空白字符。\n\n","slug":"c-中的输入","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmc000lbsuo21we7ffg","content":"<h1 id=\"记录一下程序设计中遇到的c-输入形式\"><a href=\"#记录一下程序设计中遇到的c-输入形式\" class=\"headerlink\" title=\"记录一下程序设计中遇到的c++输入形式\"></a>记录一下程序设计中遇到的c++输入形式</h1><h2 id=\"cin\"><a href=\"#cin\" class=\"headerlink\" title=\"cin\"></a>cin</h2><p>以空格和换行符作为结束的标志，（不读入这两个字符）所以在cin和getline的组合运用中一定要注意。</p>\n<p>性能差，但是可以通过</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>将其速度优化到和scanf差不多。</p>\n<p>应用场景：一连串读入 （空格分隔 或者 回车分割）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5 6</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">cin&gt;&gt;a;</span><br></pre></td></tr></table></figure>\n<h2 id=\"scanf\"><a href=\"#scanf\" class=\"headerlink\" title=\"scanf()\"></a>scanf()</h2><p>性能好 ;</p>\n<p>应用场景和cin差不多</p>\n<h2 id=\"getchar\"><a href=\"#getchar\" class=\"headerlink\" title=\"getchar()\"></a>getchar()</h2><p>读一个字符</p>\n<h2 id=\"getline\"><a href=\"#getline\" class=\"headerlink\" title=\"getline()\"></a>getline()</h2><p>读入一行 以回车为分隔。</p>\n<p>通过换行符确定读入边界，最后将换行符丢弃掉。一般读入一个str</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>\n<h2 id=\"cin-getline-组合运用\"><a href=\"#cin-getline-组合运用\" class=\"headerlink\" title=\"cin getline 组合运用\"></a>cin getline 组合运用</h2><p>先使用cin 再使用getline的场景下一定要再使用完cin后面读入换行符要不然getline会多读一个空白字符。</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"记录一下程序设计中遇到的c-输入形式\"><a href=\"#记录一下程序设计中遇到的c-输入形式\" class=\"headerlink\" title=\"记录一下程序设计中遇到的c++输入形式\"></a>记录一下程序设计中遇到的c++输入形式</h1><h2 id=\"cin\"><a href=\"#cin\" class=\"headerlink\" title=\"cin\"></a>cin</h2><p>以空格和换行符作为结束的标志，（不读入这两个字符）所以在cin和getline的组合运用中一定要注意。</p>\n<p>性能差，但是可以通过</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>将其速度优化到和scanf差不多。</p>\n<p>应用场景：一连串读入 （空格分隔 或者 回车分割）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5 6</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">cin&gt;&gt;a;</span><br></pre></td></tr></table></figure>\n<h2 id=\"scanf\"><a href=\"#scanf\" class=\"headerlink\" title=\"scanf()\"></a>scanf()</h2><p>性能好 ;</p>\n<p>应用场景和cin差不多</p>\n<h2 id=\"getchar\"><a href=\"#getchar\" class=\"headerlink\" title=\"getchar()\"></a>getchar()</h2><p>读一个字符</p>\n<h2 id=\"getline\"><a href=\"#getline\" class=\"headerlink\" title=\"getline()\"></a>getline()</h2><p>读入一行 以回车为分隔。</p>\n<p>通过换行符确定读入边界，最后将换行符丢弃掉。一般读入一个str</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>\n<h2 id=\"cin-getline-组合运用\"><a href=\"#cin-getline-组合运用\" class=\"headerlink\" title=\"cin getline 组合运用\"></a>cin getline 组合运用</h2><p>先使用cin 再使用getline的场景下一定要再使用完cin后面读入换行符要不然getline会多读一个空白字符。</p>\n"},{"title":"考研数学（概率论部分，第二章）学习","mathjax":true,"copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-15T05:52:38.000Z","updated":"2023-04-15T05:52:38.000Z","keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg","_content":"\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-15 -->\n\n第二章：一维随机变量，第一遍学习框架。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-19 -->\n\n第二章：一维随机变量，第一遍学习框架。\n\n补充内容！\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n\n\n[toc]\n\n\n\n# 第二章 一维随机变量\n\n## 章节设置\n\n- 分布函数\n  - 随机变量的定义\n  - 分布函数的定义\n  - 分布函数的性质\n  - 如何判断一个函数是否为分布函数（分布函数的充要条件）\n- 离散型随机变量\n  - 概率分布\n- 连续型随机变量\n  - 概率密度\n- 八大分布函数\n- 随机变量函数\n\n## 2.1 分布函数\n\n### 2.1.1 随机变量的定义\n\n设试验样本空间为$$\\Omega$$，称实值函数$$X = X(\\omega),\\omega \\in \\Omega $$ 为随机变量，简记为$$X$$。样本点的函数。\n\n### 2.1.2 分布函数的定义\n\n设$$X$$为随机变量，对任意实数$$x$$，称$$F(x)=P\\{X\\le x \\}$$ 为$$X$$的分布函数。\n\n### 2.1.3 分布函数的性质\n\n1. 非负性\n2. 规范性\n3. 右连续 $$F(x_0+0) = F(x_0)$$\n4. 单调不减 当$$x_1 \\le x_2$$ 时 $$F(x_1)\\le F(x_2)$$\n5. 计算单点 $$P\\left\\{X=x_0\\right\\}=F\\left(x_0\\right)-F\\left(x_0-0\\right)$$\n6. 计算区间 $$P\\{a<X \\leq b\\}=F(b)-F(a)$$\n\n前四个性质是分布函数的==充要条件== 后两个是==计算==某一个区间的概率的公式\n\n> TIPS: 需要弄清楚$$F(x) 与 f(x)$$ 之间的关系\n\n## 2.2 一维离散随机变量\n\n### 2.2.1 概率分布的定义\n\n- 概率分布的定义\n\n  概率分布的定义 设随机变量  $$X $$ 的取值为有限个或可列个, 称 $$ X$$  为离散型随机变量.\n  $$\n  设  X  的取值为  x_{1}, x_{2}, \\cdots,  称  P\\left\\{X=x_{i}\\right\\}=p_{i}, i=1,2, \\cdots  为  X  的概率分布或分布律, 也可用列表法表示\\\\\n  F(x)=P\\{X \\leq x\\}=\\sum_{x_{i} \\leq x} p_{i}\n  $$\n  \n- 什么是离散型随机变量\n\n### 2.2.2 概率分布的性质\n\n- 非负性\n\n- 规范性\n\n  前两条构成概率分布的充要条件。\n\n- 计算\n\n## 2.3 一维连续随机变量\n\n### 2.3.1 概率密度的定义\n\n- 什么是连续型随机变量\n\n- 概率密度的定义\n\n  概率密度的定义 设随机变量X的分布函数为F(x),若存在非负可积函数f(x),对任意实数x,有$$ F(x)= \\int _{- \\infty}^{x}f(t)dt $$,则称X为连续型随机变量,f(x)称为X的概率密度或密度函数.\n\n概率密度并不是单点的概率，而是概率在该处的变化率，连续型随机变量的单点的概率始终=0，所以研究单点的概率是无意义的\n\n### 2.3.2 概率密度的性质\n\n1. 非负性 $$ f(x)\\geq 0,- \\infty <x<+\\infty $$\n\n2. 规范性 $$  \\int _{- \\infty}^{+ \\infty}f(x)dx=1; $$\n\n   上述两个性质也是概率密度的充要条件。\n\n3. 计算$$ P \\left\\{ a<X \\leq b \\right\\} = \\int _{a}^{b}f(x)dx. $$\n\n【评注】性质(1)，(2)构成概率密度的充要条件，用于判定概率密度或已知概率密度反求参数;性\n质(3)用于计算随机变量取值的概率，可以推广为\n$$ P \\left\\{ a<X \\leq b \\right\\} =P \\left\\{ a \\leq X<b \\right\\} =P \\left\\{ a \\leq X \\leq b \\right\\} =P \\left\\{ a<X<b \\right\\} = \\int _{a}^{b}f(x)dx $$\n\n\n\n例题：\n\n{% tabs 有关概率密度定义&性质的题目 %}\n<!-- tab 例题-->\n\n【例2.4】(2002，数一)设 $$ X_{1} $$和 $$ X_{2} $$是任意两个相互独立的连续型随机变量，它们的概率密度分别为\n$$ f_{1} $$(x)与 $$ f_{2} $$(x),分布函数分别为 $$ F_{1} $$(x)与 $$ F_{2}(x) $$，则【 】\n(A)$$ f_{1}(x)+f_{2}(x) $$必为某一随机变量的概率密度\n(B) $$ f_{1}(x)f_{2} $$(x)必为某一随机变量的概率密度.\n(C)$$ F_{1}(x)+F_{2}(x) $$必为某一随机变量的分布函数.\n(D) $$ F_{1}(x)F_{2}(x) $$)必为某一随机变量的分布函数.\n\n<!-- endtab -->\n\n<!-- tab 总结-->\n\n- $$aF_1 +bF_2 \\ \\ (a,b \\gt 0) \\ 为一个分布函数 \\Leftrightarrow   a+b = 1 $$\n\n- $$F_1 F_2$$ 一定是一个分布函数\n\n- $$af_1 + bf_2 \\ \\ \\ (a,b \\gt 0)为概率密度 \\Leftrightarrow a+b=1$$\n- $$f_1f_2$$ 不一定是概率密度\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n## 2.4 八大概率分布（一定要关注定义）\n\n### 离散随机变量：\n\n- 01分布  一次伯努利\n\n- Bernuolli分布\n\n  设X为n重伯努利试验中事件A发生的次数，称X服从二项分布，记作$$ X \\sim B(n,p) $$，其概率分布\n  为\n  $$ P \\left\\{ X=k \\right\\} =C_{n}^{k}p^{k}(1-p)^{n-k},k=0,1, \\cdots ,n $$\n  当$$ n=1 $$时，$$ X \\sim B(1,p) $$，所以0-1分布为二项分布的特例\n\n  - 二项分布的性质\n\n    设$$X\\sim B(n，p)$$,则$$ Y=n-X \\sim B(n,1-p) $$\n\n- 几何分布\n\n  无穷次伯努利\n\n  设X为伯努利试验中事件A首次发生的试验次数，称X服从参数为p的几何分布，记作$$ X \\sim G(p) $$\n  其概率分布为$$ P \\left\\{ X=k \\right\\} =p(1-p)^{k-1},k=1,2, $$...\n\n  几何分布的性质(无记忆性)设$$ X \\sim G(p) $$，则对任意正整数m，n,有\n  $$ P \\left\\{ X>m+n|X>m \\right\\} =P \\left\\{ X>n\\right\\} $$\n  $$ P \\left\\{ X=m+n|X>m \\right\\} =P \\left\\{ X=n\\right\\} $$\n\n- 超几何分布\n\n  设N件产品，M件次品，从中任取n件，有X件次品，称X服从参数为N，M,n的超几何分布，记\n  作$$X\\sim H(N，M,n)$$,其概率分布为\n  $$ P \\left\\{ X=k \\right\\} = \\frac{C_{M}^{k}C_{N-M}^{n-k}}{C_{N}^{n}},k=0,1, \\cdots , \\min(n,M) ...,\\min(n,M)$$\n\n- Poisson分布\n\n  设随机变量 $$X$$ 的概率分布为\n  $$\n  P\\{X=k\\}=\\frac{\\lambda^k}{k !} e^{-\\lambda}, k=0,1, \\cdots(\\lambda>0)\n  $$\n  称 $$X$$ 服从参数为 $$\\lambda$$的泊松分布, 记作 $$X \\sim P(\\lambda)$$.\n\n  - Poisson 定理：\n\n  泊松定理 设 $$\\lim _{n \\rightarrow \\infty} n p_n=\\lambda(\\lambda>0)$$, 则对任意非负整数 $$k$$, 有\n  $$\n  \\lim _{n \\rightarrow \\infty} C_n^k p_n^k\\left(1-p_n\\right)^{n-k}=\\frac{\\lambda^k}{k !} e^{-\\lambda}\n  $$\n  在实际应用中可以得到二项分布的近似计算, 即当 $$n$$ 很大, $$p$$ 很小时, 有\n  $$\n  C_n^k p^k(1-p)^{n-k} \\approx \\frac{\\lambda^k}{k !} e^{-\\lambda} \\text {, 其中 } \\lambda=n p\n  $$\n\n### 连续随机变量：\n\n- 均匀分布\n\n  设随机变量X的概率密度为\n  $$\n  f(x)= \\left\\{ \n  \\begin{matrix}\n  \\frac{1}{b-a},&a \\leq x \\leq b \\\\ \n  0, &其他 \\\\ \n  \\end{matrix} \\right.\n  $$\n  \n\n  称X服从[a，b]上的均匀分布，记作$$X\\sim U(a，b)$$,其分布函数为 (U--uniform)\n  $$\n  F(x) = \n  \\begin{cases}\n  0, &\\ x \\lt a  \\\\\n  \\frac{x-a}{b-a}, &a\\le x \\lt b  \\\\\n  1, &x\\ge b  \\\\\n  \n  \\end{cases}\n  $$\n  \n- 指数分布\n\n  设随机变量X的概率密度为\n  $$ f(x)= \\begin{cases}   \\lambda e^{- \\lambda x} , \\ & x>0  \\\\ 0, & x \\leq 0  \\end{cases} (\\lambda >0) $$\n  称X服从参数为λ的指数分布，记作X~E(λ)，其分布函数为\n  $$F(x)= \\begin{cases}  1-e^{- \\lambda x},x>0  \\\\ 0, x \\leq 0  \\end{cases}$$\n\n- 正态分布 :exclamation:\n\n  设随机变量X的概率密度为\n  $$\n  f(x)= \\frac{1}{\\sqrt{2 \\pi}\\sigma}e^{\\frac{(x- \\mu)^{2}}{2 \\sigma ^{2}}}  - \\infty \n  $$\n  其中μ，σ为常数且$$  \\sigma >0 $$，称X服从参数为μ，σ的正态分布，记作$$ X \\sim N(\\mu , \\sigma ^{2}) $$，其分布函数为\n  $$\n  F(x)= \\int _{- \\infty}^{x}\\frac{1}{\\sqrt{2 \\pi}\\sigma}e^{\\frac{(t- \\mu)^{2}}{2 \\sigma ^{2}}} dt, - \\infty\n  $$\n\n  - 标准正态分布\n\n    当$$  \\mu =0, \\sigma ^{2}=1 $$ 时，X~N(0,1),称X服从标准正态分布，其概率密度为\n    $$\n    \\varphi(x)= \\frac{1}{\\sqrt{2 \\pi}}e^{- \\frac{x^{2}}{2}}  - \\infty  \\\\\n    分布函数:\\\\\n    \\Phi(x)= \\int _{- \\infty}^{x}\\frac{1}{\\sqrt{2 \\pi}}e^{- \\frac{t^{2}}{2}}dt,- \\infty\n    $$\n\n  - 正态分布的性质（其实是标准正态分布的性质）\n    1. $$  \\Phi(0)= \\frac{1}{2} ， \\Phi(-x)=1- \\Phi(x); $$\n    2. 设$$X\\sim N(0，1)$$,则$$ P \\left\\{ |X|<x \\right\\} = \\Phi(x)- \\Phi(-x)=2 \\Phi(x)-1 $$\n\n  - 正态分布的标准化\n\n     设$$ X \\sim N(\\mu , \\sigma ^{2}) $$，分布函数为F(x)，则$$  \\frac{X- \\mu}{\\sigma}\\sim N(0,1) $$，故\n    $$ F(x)= \\Phi(\\frac{x- \\mu}{\\sigma}),P \\left\\{ a<X \\leq b \\right\\} = \\Phi(\\frac{b- \\mu}{\\sigma})- \\Phi(\\frac{a- \\mu}{\\sigma}) $$\n\n## 2.5 一维随机变量函数的分布\n\n### 离散型的概率分布中计算其随机变量函数的分布函数\n\n### 连续型随机变量函数的分布\n\n设随机变量X的概率密度为 $$ f_{x}(x) $$，求$$ Y=g(X) $$的分布.\n\n#### 法一：分布函数法\n\n- 写分布函数： 设Y的分布函数为 $$ F_{Y}(y) $$),则$$ F_{Y}(y)=P \\left\\{ Y \\leq y \\right\\} =P \\left\\{ g(X)\\leq y\\right\\} $$\n\n- 讨论小y：图像法讨论： 求$$ Y=g(X) $$在X的==正概率密度==区间的值域$$[\\alpha，\\beta]$$,讨论y\n\n  当$$ y<\\alpha $$时，$$ F_{y}(y)=0 $$\n  当$$  \\alpha \\leq y<\\beta $$时，$$ F_{Y}(y)= \\int_{g(x)\\le y } f_{x}(x)dx; $$\n  当$$ y \\geq \\beta $$时，$$ F_{Y}(y)=1 $$\n\n- 求导\n\n#### 法二：公式法\n\n设$$ y=g(x) $$在X的正概率密度区间单调，值域为[α，β],反函数为$$ x=h(y) $$，则Y的概率密度为\n$$\nf_{Y}(y)= \n\n\\begin{cases} \nf_{x}(h(y))|h^{\\prime}(y)|&, a \\leq y \\leq \\beta \\\\ \n0  &, 其他 \\\\ \\end{cases}\n$$\n若$$ y=g(x) $$在X的正概率密度区间[a，b]==分段严格单调==，则分段运用公式法，然后将概率密度相加.  注意公式法里面的绝对值\n\n","source":"_posts/考研数学（概率论部分，第二章）学习.md","raw":"---\ntitle: 考研数学（概率论部分，第二章）学习\nmathjax: true\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-15 13:52:38\nupdated: 2023-04-15 13:52:38\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg\n---\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-15 -->\n\n第二章：一维随机变量，第一遍学习框架。\n\n<!-- endtimeline -->\n\n<!-- timeline 04-19 -->\n\n第二章：一维随机变量，第一遍学习框架。\n\n补充内容！\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n\n\n[toc]\n\n\n\n# 第二章 一维随机变量\n\n## 章节设置\n\n- 分布函数\n  - 随机变量的定义\n  - 分布函数的定义\n  - 分布函数的性质\n  - 如何判断一个函数是否为分布函数（分布函数的充要条件）\n- 离散型随机变量\n  - 概率分布\n- 连续型随机变量\n  - 概率密度\n- 八大分布函数\n- 随机变量函数\n\n## 2.1 分布函数\n\n### 2.1.1 随机变量的定义\n\n设试验样本空间为$$\\Omega$$，称实值函数$$X = X(\\omega),\\omega \\in \\Omega $$ 为随机变量，简记为$$X$$。样本点的函数。\n\n### 2.1.2 分布函数的定义\n\n设$$X$$为随机变量，对任意实数$$x$$，称$$F(x)=P\\{X\\le x \\}$$ 为$$X$$的分布函数。\n\n### 2.1.3 分布函数的性质\n\n1. 非负性\n2. 规范性\n3. 右连续 $$F(x_0+0) = F(x_0)$$\n4. 单调不减 当$$x_1 \\le x_2$$ 时 $$F(x_1)\\le F(x_2)$$\n5. 计算单点 $$P\\left\\{X=x_0\\right\\}=F\\left(x_0\\right)-F\\left(x_0-0\\right)$$\n6. 计算区间 $$P\\{a<X \\leq b\\}=F(b)-F(a)$$\n\n前四个性质是分布函数的==充要条件== 后两个是==计算==某一个区间的概率的公式\n\n> TIPS: 需要弄清楚$$F(x) 与 f(x)$$ 之间的关系\n\n## 2.2 一维离散随机变量\n\n### 2.2.1 概率分布的定义\n\n- 概率分布的定义\n\n  概率分布的定义 设随机变量  $$X $$ 的取值为有限个或可列个, 称 $$ X$$  为离散型随机变量.\n  $$\n  设  X  的取值为  x_{1}, x_{2}, \\cdots,  称  P\\left\\{X=x_{i}\\right\\}=p_{i}, i=1,2, \\cdots  为  X  的概率分布或分布律, 也可用列表法表示\\\\\n  F(x)=P\\{X \\leq x\\}=\\sum_{x_{i} \\leq x} p_{i}\n  $$\n  \n- 什么是离散型随机变量\n\n### 2.2.2 概率分布的性质\n\n- 非负性\n\n- 规范性\n\n  前两条构成概率分布的充要条件。\n\n- 计算\n\n## 2.3 一维连续随机变量\n\n### 2.3.1 概率密度的定义\n\n- 什么是连续型随机变量\n\n- 概率密度的定义\n\n  概率密度的定义 设随机变量X的分布函数为F(x),若存在非负可积函数f(x),对任意实数x,有$$ F(x)= \\int _{- \\infty}^{x}f(t)dt $$,则称X为连续型随机变量,f(x)称为X的概率密度或密度函数.\n\n概率密度并不是单点的概率，而是概率在该处的变化率，连续型随机变量的单点的概率始终=0，所以研究单点的概率是无意义的\n\n### 2.3.2 概率密度的性质\n\n1. 非负性 $$ f(x)\\geq 0,- \\infty <x<+\\infty $$\n\n2. 规范性 $$  \\int _{- \\infty}^{+ \\infty}f(x)dx=1; $$\n\n   上述两个性质也是概率密度的充要条件。\n\n3. 计算$$ P \\left\\{ a<X \\leq b \\right\\} = \\int _{a}^{b}f(x)dx. $$\n\n【评注】性质(1)，(2)构成概率密度的充要条件，用于判定概率密度或已知概率密度反求参数;性\n质(3)用于计算随机变量取值的概率，可以推广为\n$$ P \\left\\{ a<X \\leq b \\right\\} =P \\left\\{ a \\leq X<b \\right\\} =P \\left\\{ a \\leq X \\leq b \\right\\} =P \\left\\{ a<X<b \\right\\} = \\int _{a}^{b}f(x)dx $$\n\n\n\n例题：\n\n{% tabs 有关概率密度定义&性质的题目 %}\n<!-- tab 例题-->\n\n【例2.4】(2002，数一)设 $$ X_{1} $$和 $$ X_{2} $$是任意两个相互独立的连续型随机变量，它们的概率密度分别为\n$$ f_{1} $$(x)与 $$ f_{2} $$(x),分布函数分别为 $$ F_{1} $$(x)与 $$ F_{2}(x) $$，则【 】\n(A)$$ f_{1}(x)+f_{2}(x) $$必为某一随机变量的概率密度\n(B) $$ f_{1}(x)f_{2} $$(x)必为某一随机变量的概率密度.\n(C)$$ F_{1}(x)+F_{2}(x) $$必为某一随机变量的分布函数.\n(D) $$ F_{1}(x)F_{2}(x) $$)必为某一随机变量的分布函数.\n\n<!-- endtab -->\n\n<!-- tab 总结-->\n\n- $$aF_1 +bF_2 \\ \\ (a,b \\gt 0) \\ 为一个分布函数 \\Leftrightarrow   a+b = 1 $$\n\n- $$F_1 F_2$$ 一定是一个分布函数\n\n- $$af_1 + bf_2 \\ \\ \\ (a,b \\gt 0)为概率密度 \\Leftrightarrow a+b=1$$\n- $$f_1f_2$$ 不一定是概率密度\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n## 2.4 八大概率分布（一定要关注定义）\n\n### 离散随机变量：\n\n- 01分布  一次伯努利\n\n- Bernuolli分布\n\n  设X为n重伯努利试验中事件A发生的次数，称X服从二项分布，记作$$ X \\sim B(n,p) $$，其概率分布\n  为\n  $$ P \\left\\{ X=k \\right\\} =C_{n}^{k}p^{k}(1-p)^{n-k},k=0,1, \\cdots ,n $$\n  当$$ n=1 $$时，$$ X \\sim B(1,p) $$，所以0-1分布为二项分布的特例\n\n  - 二项分布的性质\n\n    设$$X\\sim B(n，p)$$,则$$ Y=n-X \\sim B(n,1-p) $$\n\n- 几何分布\n\n  无穷次伯努利\n\n  设X为伯努利试验中事件A首次发生的试验次数，称X服从参数为p的几何分布，记作$$ X \\sim G(p) $$\n  其概率分布为$$ P \\left\\{ X=k \\right\\} =p(1-p)^{k-1},k=1,2, $$...\n\n  几何分布的性质(无记忆性)设$$ X \\sim G(p) $$，则对任意正整数m，n,有\n  $$ P \\left\\{ X>m+n|X>m \\right\\} =P \\left\\{ X>n\\right\\} $$\n  $$ P \\left\\{ X=m+n|X>m \\right\\} =P \\left\\{ X=n\\right\\} $$\n\n- 超几何分布\n\n  设N件产品，M件次品，从中任取n件，有X件次品，称X服从参数为N，M,n的超几何分布，记\n  作$$X\\sim H(N，M,n)$$,其概率分布为\n  $$ P \\left\\{ X=k \\right\\} = \\frac{C_{M}^{k}C_{N-M}^{n-k}}{C_{N}^{n}},k=0,1, \\cdots , \\min(n,M) ...,\\min(n,M)$$\n\n- Poisson分布\n\n  设随机变量 $$X$$ 的概率分布为\n  $$\n  P\\{X=k\\}=\\frac{\\lambda^k}{k !} e^{-\\lambda}, k=0,1, \\cdots(\\lambda>0)\n  $$\n  称 $$X$$ 服从参数为 $$\\lambda$$的泊松分布, 记作 $$X \\sim P(\\lambda)$$.\n\n  - Poisson 定理：\n\n  泊松定理 设 $$\\lim _{n \\rightarrow \\infty} n p_n=\\lambda(\\lambda>0)$$, 则对任意非负整数 $$k$$, 有\n  $$\n  \\lim _{n \\rightarrow \\infty} C_n^k p_n^k\\left(1-p_n\\right)^{n-k}=\\frac{\\lambda^k}{k !} e^{-\\lambda}\n  $$\n  在实际应用中可以得到二项分布的近似计算, 即当 $$n$$ 很大, $$p$$ 很小时, 有\n  $$\n  C_n^k p^k(1-p)^{n-k} \\approx \\frac{\\lambda^k}{k !} e^{-\\lambda} \\text {, 其中 } \\lambda=n p\n  $$\n\n### 连续随机变量：\n\n- 均匀分布\n\n  设随机变量X的概率密度为\n  $$\n  f(x)= \\left\\{ \n  \\begin{matrix}\n  \\frac{1}{b-a},&a \\leq x \\leq b \\\\ \n  0, &其他 \\\\ \n  \\end{matrix} \\right.\n  $$\n  \n\n  称X服从[a，b]上的均匀分布，记作$$X\\sim U(a，b)$$,其分布函数为 (U--uniform)\n  $$\n  F(x) = \n  \\begin{cases}\n  0, &\\ x \\lt a  \\\\\n  \\frac{x-a}{b-a}, &a\\le x \\lt b  \\\\\n  1, &x\\ge b  \\\\\n  \n  \\end{cases}\n  $$\n  \n- 指数分布\n\n  设随机变量X的概率密度为\n  $$ f(x)= \\begin{cases}   \\lambda e^{- \\lambda x} , \\ & x>0  \\\\ 0, & x \\leq 0  \\end{cases} (\\lambda >0) $$\n  称X服从参数为λ的指数分布，记作X~E(λ)，其分布函数为\n  $$F(x)= \\begin{cases}  1-e^{- \\lambda x},x>0  \\\\ 0, x \\leq 0  \\end{cases}$$\n\n- 正态分布 :exclamation:\n\n  设随机变量X的概率密度为\n  $$\n  f(x)= \\frac{1}{\\sqrt{2 \\pi}\\sigma}e^{\\frac{(x- \\mu)^{2}}{2 \\sigma ^{2}}}  - \\infty \n  $$\n  其中μ，σ为常数且$$  \\sigma >0 $$，称X服从参数为μ，σ的正态分布，记作$$ X \\sim N(\\mu , \\sigma ^{2}) $$，其分布函数为\n  $$\n  F(x)= \\int _{- \\infty}^{x}\\frac{1}{\\sqrt{2 \\pi}\\sigma}e^{\\frac{(t- \\mu)^{2}}{2 \\sigma ^{2}}} dt, - \\infty\n  $$\n\n  - 标准正态分布\n\n    当$$  \\mu =0, \\sigma ^{2}=1 $$ 时，X~N(0,1),称X服从标准正态分布，其概率密度为\n    $$\n    \\varphi(x)= \\frac{1}{\\sqrt{2 \\pi}}e^{- \\frac{x^{2}}{2}}  - \\infty  \\\\\n    分布函数:\\\\\n    \\Phi(x)= \\int _{- \\infty}^{x}\\frac{1}{\\sqrt{2 \\pi}}e^{- \\frac{t^{2}}{2}}dt,- \\infty\n    $$\n\n  - 正态分布的性质（其实是标准正态分布的性质）\n    1. $$  \\Phi(0)= \\frac{1}{2} ， \\Phi(-x)=1- \\Phi(x); $$\n    2. 设$$X\\sim N(0，1)$$,则$$ P \\left\\{ |X|<x \\right\\} = \\Phi(x)- \\Phi(-x)=2 \\Phi(x)-1 $$\n\n  - 正态分布的标准化\n\n     设$$ X \\sim N(\\mu , \\sigma ^{2}) $$，分布函数为F(x)，则$$  \\frac{X- \\mu}{\\sigma}\\sim N(0,1) $$，故\n    $$ F(x)= \\Phi(\\frac{x- \\mu}{\\sigma}),P \\left\\{ a<X \\leq b \\right\\} = \\Phi(\\frac{b- \\mu}{\\sigma})- \\Phi(\\frac{a- \\mu}{\\sigma}) $$\n\n## 2.5 一维随机变量函数的分布\n\n### 离散型的概率分布中计算其随机变量函数的分布函数\n\n### 连续型随机变量函数的分布\n\n设随机变量X的概率密度为 $$ f_{x}(x) $$，求$$ Y=g(X) $$的分布.\n\n#### 法一：分布函数法\n\n- 写分布函数： 设Y的分布函数为 $$ F_{Y}(y) $$),则$$ F_{Y}(y)=P \\left\\{ Y \\leq y \\right\\} =P \\left\\{ g(X)\\leq y\\right\\} $$\n\n- 讨论小y：图像法讨论： 求$$ Y=g(X) $$在X的==正概率密度==区间的值域$$[\\alpha，\\beta]$$,讨论y\n\n  当$$ y<\\alpha $$时，$$ F_{y}(y)=0 $$\n  当$$  \\alpha \\leq y<\\beta $$时，$$ F_{Y}(y)= \\int_{g(x)\\le y } f_{x}(x)dx; $$\n  当$$ y \\geq \\beta $$时，$$ F_{Y}(y)=1 $$\n\n- 求导\n\n#### 法二：公式法\n\n设$$ y=g(x) $$在X的正概率密度区间单调，值域为[α，β],反函数为$$ x=h(y) $$，则Y的概率密度为\n$$\nf_{Y}(y)= \n\n\\begin{cases} \nf_{x}(h(y))|h^{\\prime}(y)|&, a \\leq y \\leq \\beta \\\\ \n0  &, 其他 \\\\ \\end{cases}\n$$\n若$$ y=g(x) $$在X的正概率密度区间[a，b]==分段严格单调==，则分段运用公式法，然后将概率密度相加.  注意公式法里面的绝对值\n\n","slug":"考研数学（概率论部分，第二章）学习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmd000qbsuoehp60gqe","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-15</p>\n</div></div><div class=\"timeline-item-content\"><p>第二章：一维随机变量，第一遍学习框架。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-19</p>\n</div></div><div class=\"timeline-item-content\"><p>第二章：一维随机变量，第一遍学习框架。</p>\n<p>补充内容！</p>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"第二章-一维随机变量\"><a href=\"#第二章-一维随机变量\" class=\"headerlink\" title=\"第二章 一维随机变量\"></a>第二章 一维随机变量</h1><h2 id=\"章节设置\"><a href=\"#章节设置\" class=\"headerlink\" title=\"章节设置\"></a>章节设置</h2><ul>\n<li>分布函数<ul>\n<li>随机变量的定义</li>\n<li>分布函数的定义</li>\n<li>分布函数的性质</li>\n<li>如何判断一个函数是否为分布函数（分布函数的充要条件）</li>\n</ul>\n</li>\n<li>离散型随机变量<ul>\n<li>概率分布</li>\n</ul>\n</li>\n<li>连续型随机变量<ul>\n<li>概率密度</li>\n</ul>\n</li>\n<li>八大分布函数</li>\n<li>随机变量函数</li>\n</ul>\n<h2 id=\"2-1-分布函数\"><a href=\"#2-1-分布函数\" class=\"headerlink\" title=\"2.1 分布函数\"></a>2.1 分布函数</h2><h3 id=\"2-1-1-随机变量的定义\"><a href=\"#2-1-1-随机变量的定义\" class=\"headerlink\" title=\"2.1.1 随机变量的定义\"></a>2.1.1 随机变量的定义</h3><p>设试验样本空间为<script type=\"math/tex\">\\Omega</script>，称实值函数<script type=\"math/tex\">X = X(\\omega),\\omega \\in \\Omega</script> 为随机变量，简记为<script type=\"math/tex\">X</script>。样本点的函数。</p>\n<h3 id=\"2-1-2-分布函数的定义\"><a href=\"#2-1-2-分布函数的定义\" class=\"headerlink\" title=\"2.1.2 分布函数的定义\"></a>2.1.2 分布函数的定义</h3><p>设<script type=\"math/tex\">X</script>为随机变量，对任意实数<script type=\"math/tex\">x</script>，称<script type=\"math/tex\">F(x)=P\\{X\\le x \\}</script> 为<script type=\"math/tex\">X</script>的分布函数。</p>\n<h3 id=\"2-1-3-分布函数的性质\"><a href=\"#2-1-3-分布函数的性质\" class=\"headerlink\" title=\"2.1.3 分布函数的性质\"></a>2.1.3 分布函数的性质</h3><ol>\n<li>非负性</li>\n<li>规范性</li>\n<li>右连续 <script type=\"math/tex\">F(x_0+0) = F(x_0)</script></li>\n<li>单调不减 当<script type=\"math/tex\">x_1 \\le x_2</script> 时 <script type=\"math/tex\">F(x_1)\\le F(x_2)</script></li>\n<li>计算单点 <script type=\"math/tex\">P\\left\\{X=x_0\\right\\}=F\\left(x_0\\right)-F\\left(x_0-0\\right)</script></li>\n<li>计算区间 <script type=\"math/tex\">P\\{a<X \\leq b\\}=F(b)-F(a)</script></li>\n</ol>\n<p>前四个性质是分布函数的==充要条件== 后两个是==计算==某一个区间的概率的公式</p>\n<blockquote>\n<p>TIPS: 需要弄清楚<script type=\"math/tex\">F(x) 与 f(x)</script> 之间的关系</p>\n</blockquote>\n<h2 id=\"2-2-一维离散随机变量\"><a href=\"#2-2-一维离散随机变量\" class=\"headerlink\" title=\"2.2 一维离散随机变量\"></a>2.2 一维离散随机变量</h2><h3 id=\"2-2-1-概率分布的定义\"><a href=\"#2-2-1-概率分布的定义\" class=\"headerlink\" title=\"2.2.1 概率分布的定义\"></a>2.2.1 概率分布的定义</h3><ul>\n<li><p>概率分布的定义</p>\n<p>概率分布的定义 设随机变量  <script type=\"math/tex\">X</script> 的取值为有限个或可列个, 称 <script type=\"math/tex\">X</script>  为离散型随机变量.</p>\n<script type=\"math/tex; mode=display\">\n设  X  的取值为  x_{1}, x_{2}, \\cdots,  称  P\\left\\{X=x_{i}\\right\\}=p_{i}, i=1,2, \\cdots  为  X  的概率分布或分布律, 也可用列表法表示\\\\\nF(x)=P\\{X \\leq x\\}=\\sum_{x_{i} \\leq x} p_{i}</script></li>\n<li><p>什么是离散型随机变量</p>\n</li>\n</ul>\n<h3 id=\"2-2-2-概率分布的性质\"><a href=\"#2-2-2-概率分布的性质\" class=\"headerlink\" title=\"2.2.2 概率分布的性质\"></a>2.2.2 概率分布的性质</h3><ul>\n<li><p>非负性</p>\n</li>\n<li><p>规范性</p>\n<p>前两条构成概率分布的充要条件。</p>\n</li>\n<li><p>计算</p>\n</li>\n</ul>\n<h2 id=\"2-3-一维连续随机变量\"><a href=\"#2-3-一维连续随机变量\" class=\"headerlink\" title=\"2.3 一维连续随机变量\"></a>2.3 一维连续随机变量</h2><h3 id=\"2-3-1-概率密度的定义\"><a href=\"#2-3-1-概率密度的定义\" class=\"headerlink\" title=\"2.3.1 概率密度的定义\"></a>2.3.1 概率密度的定义</h3><ul>\n<li><p>什么是连续型随机变量</p>\n</li>\n<li><p>概率密度的定义</p>\n<p>概率密度的定义 设随机变量X的分布函数为F(x),若存在非负可积函数f(x),对任意实数x,有<script type=\"math/tex\">F(x)= \\int _{- \\infty}^{x}f(t)dt</script>,则称X为连续型随机变量,f(x)称为X的概率密度或密度函数.</p>\n</li>\n</ul>\n<p>概率密度并不是单点的概率，而是概率在该处的变化率，连续型随机变量的单点的概率始终=0，所以研究单点的概率是无意义的</p>\n<h3 id=\"2-3-2-概率密度的性质\"><a href=\"#2-3-2-概率密度的性质\" class=\"headerlink\" title=\"2.3.2 概率密度的性质\"></a>2.3.2 概率密度的性质</h3><ol>\n<li><p>非负性 <script type=\"math/tex\">f(x)\\geq 0,- \\infty <x<+\\infty</script></p>\n</li>\n<li><p>规范性 <script type=\"math/tex\">\\int _{- \\infty}^{+ \\infty}f(x)dx=1;</script></p>\n<p>上述两个性质也是概率密度的充要条件。</p>\n</li>\n<li><p>计算<script type=\"math/tex\">P \\left\\{ a<X \\leq b \\right\\} = \\int _{a}^{b}f(x)dx.</script></p>\n</li>\n</ol>\n<p>【评注】性质(1)，(2)构成概率密度的充要条件，用于判定概率密度或已知概率密度反求参数;性<br>质(3)用于计算随机变量取值的概率，可以推广为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ a<X \\leq b \\right\\} =P \\left\\{ a \\leq X<b \\right\\} =P \\left\\{ a \\leq X \\leq b \\right\\} =P \\left\\{ a<X<b \\right\\} = \\int _{a}^{b}f(x)dx</script><p>例题：</p>\n<div class=\"tabs\" id=\"有关概率密度定义&性质的题目\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#有关概率密度定义&性质的题目-1\">例题</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#有关概率密度定义&性质的题目-2\">总结</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"有关概率密度定义&性质的题目-1\"><p>【例2.4】(2002，数一)设 <script type=\"math/tex\">X_{1}</script>和 <script type=\"math/tex\">X_{2}</script>是任意两个相互独立的连续型随机变量，它们的概率密度分别为</p>\n<p><script type=\"math/tex\">f_{1}</script>(x)与 <script type=\"math/tex\">f_{2}</script>(x),分布函数分别为 <script type=\"math/tex\">F_{1}</script>(x)与 <script type=\"math/tex\">F_{2}(x)</script>，则【 】<br>(A)<script type=\"math/tex\">f_{1}(x)+f_{2}(x)</script>必为某一随机变量的概率密度<br>(B) <script type=\"math/tex\">f_{1}(x)f_{2}</script>(x)必为某一随机变量的概率密度.<br>(C)<script type=\"math/tex\">F_{1}(x)+F_{2}(x)</script>必为某一随机变量的分布函数.<br>(D) <script type=\"math/tex\">F_{1}(x)F_{2}(x)</script>)必为某一随机变量的分布函数.</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"有关概率密度定义&性质的题目-2\"><ul>\n<li><script type=\"math/tex; mode=display\">aF_1 +bF_2 \\ \\ (a,b \\gt 0) \\ 为一个分布函数 \\Leftrightarrow   a+b = 1</script></li>\n<li><p><script type=\"math/tex\">F_1 F_2</script> 一定是一个分布函数</p>\n</li>\n<li><script type=\"math/tex; mode=display\">af_1 + bf_2 \\ \\ \\ (a,b \\gt 0)为概率密度 \\Leftrightarrow a+b=1</script></li>\n<li><script type=\"math/tex\">f_1f_2</script> 不一定是概率密度</li>\n</ul><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"2-4-八大概率分布（一定要关注定义）\"><a href=\"#2-4-八大概率分布（一定要关注定义）\" class=\"headerlink\" title=\"2.4 八大概率分布（一定要关注定义）\"></a>2.4 八大概率分布（一定要关注定义）</h2><h3 id=\"离散随机变量：\"><a href=\"#离散随机变量：\" class=\"headerlink\" title=\"离散随机变量：\"></a>离散随机变量：</h3><ul>\n<li><p>01分布  一次伯努利</p>\n</li>\n<li><p>Bernuolli分布</p>\n<p>设X为n重伯努利试验中事件A发生的次数，称X服从二项分布，记作<script type=\"math/tex\">X \\sim B(n,p)</script>，其概率分布<br>为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X=k \\right\\} =C_{n}^{k}p^{k}(1-p)^{n-k},k=0,1, \\cdots ,n</script><p>当<script type=\"math/tex\">n=1</script>时，<script type=\"math/tex\">X \\sim B(1,p)</script>，所以0-1分布为二项分布的特例</p>\n<ul>\n<li><p>二项分布的性质</p>\n<p>设<script type=\"math/tex\">X\\sim B(n，p)</script>,则<script type=\"math/tex\">Y=n-X \\sim B(n,1-p)</script></p>\n</li>\n</ul>\n</li>\n<li><p>几何分布</p>\n<p>无穷次伯努利</p>\n<p>设X为伯努利试验中事件A首次发生的试验次数，称X服从参数为p的几何分布，记作<script type=\"math/tex\">X \\sim G(p)</script><br>其概率分布为<script type=\"math/tex\">P \\left\\{ X=k \\right\\} =p(1-p)^{k-1},k=1,2,</script>…</p>\n<p>几何分布的性质(无记忆性)设<script type=\"math/tex\">X \\sim G(p)</script>，则对任意正整数m，n,有</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X>m+n|X>m \\right\\} =P \\left\\{ X>n\\right\\}</script><script type=\"math/tex; mode=display\">P \\left\\{ X=m+n|X>m \\right\\} =P \\left\\{ X=n\\right\\}</script></li>\n<li><p>超几何分布</p>\n<p>设N件产品，M件次品，从中任取n件，有X件次品，称X服从参数为N，M,n的超几何分布，记<br>作<script type=\"math/tex\">X\\sim H(N，M,n)</script>,其概率分布为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X=k \\right\\} = \\frac{C_{M}^{k}C_{N-M}^{n-k}}{C_{N}^{n}},k=0,1, \\cdots , \\min(n,M) ...,\\min(n,M)</script></li>\n<li><p>Poisson分布</p>\n<p>设随机变量 <script type=\"math/tex\">X</script> 的概率分布为</p>\n<script type=\"math/tex; mode=display\">\nP\\{X=k\\}=\\frac{\\lambda^k}{k !} e^{-\\lambda}, k=0,1, \\cdots(\\lambda>0)</script><p>称 <script type=\"math/tex\">X</script> 服从参数为 <script type=\"math/tex\">\\lambda</script>的泊松分布, 记作 <script type=\"math/tex\">X \\sim P(\\lambda)</script>.</p>\n<ul>\n<li>Poisson 定理：</li>\n</ul>\n<p>泊松定理 设 <script type=\"math/tex\">\\lim _{n \\rightarrow \\infty} n p_n=\\lambda(\\lambda>0)</script>, 则对任意非负整数 <script type=\"math/tex\">k</script>, 有</p>\n<script type=\"math/tex; mode=display\">\n\\lim _{n \\rightarrow \\infty} C_n^k p_n^k\\left(1-p_n\\right)^{n-k}=\\frac{\\lambda^k}{k !} e^{-\\lambda}</script><p>在实际应用中可以得到二项分布的近似计算, 即当 <script type=\"math/tex\">n</script> 很大, <script type=\"math/tex\">p</script> 很小时, 有</p>\n<script type=\"math/tex; mode=display\">\nC_n^k p^k(1-p)^{n-k} \\approx \\frac{\\lambda^k}{k !} e^{-\\lambda} \\text {, 其中 } \\lambda=n p</script></li>\n</ul>\n<h3 id=\"连续随机变量：\"><a href=\"#连续随机变量：\" class=\"headerlink\" title=\"连续随机变量：\"></a>连续随机变量：</h3><ul>\n<li><p>均匀分布</p>\n<p>设随机变量X的概率密度为</p>\n<script type=\"math/tex; mode=display\">\nf(x)= \\left\\{ \n\\begin{matrix}\n\\frac{1}{b-a},&a \\leq x \\leq b \\\\ \n0, &其他 \\\\ \n\\end{matrix} \\right.</script></li>\n</ul>\n<p>  称X服从[a，b]上的均匀分布，记作<script type=\"math/tex\">X\\sim U(a，b)</script>,其分布函数为 (U—uniform)</p>\n<script type=\"math/tex; mode=display\">\n  F(x) = \n  \\begin{cases}\n  0, &\\ x \\lt a  \\\\\n  \\frac{x-a}{b-a}, &a\\le x \\lt b  \\\\\n  1, &x\\ge b  \\\\\n\n  \\end{cases}</script><ul>\n<li><p>指数分布</p>\n<p>设随机变量X的概率密度为</p>\n<script type=\"math/tex; mode=display\">f(x)= \\begin{cases}   \\lambda e^{- \\lambda x} , \\ & x>0  \\\\ 0, & x \\leq 0  \\end{cases} (\\lambda >0)</script><p>称X服从参数为λ的指数分布，记作X~E(λ)，其分布函数为</p>\n<script type=\"math/tex; mode=display\">F(x)= \\begin{cases}  1-e^{- \\lambda x},x>0  \\\\ 0, x \\leq 0  \\end{cases}</script></li>\n<li><p>正态分布 :exclamation:</p>\n<p>设随机变量X的概率密度为</p>\n<script type=\"math/tex; mode=display\">\nf(x)= \\frac{1}{\\sqrt{2 \\pi}\\sigma}e^{\\frac{(x- \\mu)^{2}}{2 \\sigma ^{2}}}  - \\infty</script><p>其中μ，σ为常数且<script type=\"math/tex\">\\sigma >0</script>，称X服从参数为μ，σ的正态分布，记作<script type=\"math/tex\">X \\sim N(\\mu , \\sigma ^{2})</script>，其分布函数为</p>\n<script type=\"math/tex; mode=display\">\nF(x)= \\int _{- \\infty}^{x}\\frac{1}{\\sqrt{2 \\pi}\\sigma}e^{\\frac{(t- \\mu)^{2}}{2 \\sigma ^{2}}} dt, - \\infty</script><ul>\n<li><p>标准正态分布</p>\n<p>当<script type=\"math/tex\">\\mu =0, \\sigma ^{2}=1</script> 时，X~N(0,1),称X服从标准正态分布，其概率密度为</p>\n<script type=\"math/tex; mode=display\">\n\\varphi(x)= \\frac{1}{\\sqrt{2 \\pi}}e^{- \\frac{x^{2}}{2}}  - \\infty  \\\\\n分布函数:\\\\\n\\Phi(x)= \\int _{- \\infty}^{x}\\frac{1}{\\sqrt{2 \\pi}}e^{- \\frac{t^{2}}{2}}dt,- \\infty</script></li>\n<li><p>正态分布的性质（其实是标准正态分布的性质）</p>\n<ol>\n<li><script type=\"math/tex; mode=display\">\\Phi(0)= \\frac{1}{2} ， \\Phi(-x)=1- \\Phi(x);</script></li>\n<li>设<script type=\"math/tex\">X\\sim N(0，1)</script>,则<script type=\"math/tex\">P \\left\\{ |X|<x \\right\\} = \\Phi(x)- \\Phi(-x)=2 \\Phi(x)-1</script></li>\n</ol>\n</li>\n<li><p>正态分布的标准化</p>\n<p> 设<script type=\"math/tex\">X \\sim N(\\mu , \\sigma ^{2})</script>，分布函数为F(x)，则<script type=\"math/tex\">\\frac{X- \\mu}{\\sigma}\\sim N(0,1)</script>，故</p>\n<script type=\"math/tex; mode=display\">F(x)= \\Phi(\\frac{x- \\mu}{\\sigma}),P \\left\\{ a<X \\leq b \\right\\} = \\Phi(\\frac{b- \\mu}{\\sigma})- \\Phi(\\frac{a- \\mu}{\\sigma})</script></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-5-一维随机变量函数的分布\"><a href=\"#2-5-一维随机变量函数的分布\" class=\"headerlink\" title=\"2.5 一维随机变量函数的分布\"></a>2.5 一维随机变量函数的分布</h2><h3 id=\"离散型的概率分布中计算其随机变量函数的分布函数\"><a href=\"#离散型的概率分布中计算其随机变量函数的分布函数\" class=\"headerlink\" title=\"离散型的概率分布中计算其随机变量函数的分布函数\"></a>离散型的概率分布中计算其随机变量函数的分布函数</h3><h3 id=\"连续型随机变量函数的分布\"><a href=\"#连续型随机变量函数的分布\" class=\"headerlink\" title=\"连续型随机变量函数的分布\"></a>连续型随机变量函数的分布</h3><p>设随机变量X的概率密度为 <script type=\"math/tex\">f_{x}(x)</script>，求<script type=\"math/tex\">Y=g(X)</script>的分布.</p>\n<h4 id=\"法一：分布函数法\"><a href=\"#法一：分布函数法\" class=\"headerlink\" title=\"法一：分布函数法\"></a>法一：分布函数法</h4><ul>\n<li><p>写分布函数： 设Y的分布函数为 <script type=\"math/tex\">F_{Y}(y)</script>),则<script type=\"math/tex\">F_{Y}(y)=P \\left\\{ Y \\leq y \\right\\} =P \\left\\{ g(X)\\leq y\\right\\}</script></p>\n</li>\n<li><p>讨论小y：图像法讨论： 求<script type=\"math/tex\">Y=g(X)</script>在X的==正概率密度==区间的值域<script type=\"math/tex\">[\\alpha，\\beta]</script>,讨论y</p>\n<p>当<script type=\"math/tex\">y<\\alpha</script>时，<script type=\"math/tex\">F_{y}(y)=0</script><br>当<script type=\"math/tex\">\\alpha \\leq y<\\beta</script>时，<script type=\"math/tex\">F_{Y}(y)= \\int_{g(x)\\le y } f_{x}(x)dx;</script><br>当<script type=\"math/tex\">y \\geq \\beta</script>时，<script type=\"math/tex\">F_{Y}(y)=1</script></p>\n</li>\n<li><p>求导</p>\n</li>\n</ul>\n<h4 id=\"法二：公式法\"><a href=\"#法二：公式法\" class=\"headerlink\" title=\"法二：公式法\"></a>法二：公式法</h4><p>设<script type=\"math/tex\">y=g(x)</script>在X的正概率密度区间单调，值域为[α，β],反函数为<script type=\"math/tex\">x=h(y)</script>，则Y的概率密度为</p>\n<script type=\"math/tex; mode=display\">\nf_{Y}(y)= \n\n\\begin{cases} \nf_{x}(h(y))|h^{\\prime}(y)|&, a \\leq y \\leq \\beta \\\\ \n0  &, 其他 \\\\ \\end{cases}</script><p>若<script type=\"math/tex\">y=g(x)</script>在X的正概率密度区间[a，b]==分段严格单调==，则分段运用公式法，然后将概率密度相加.  注意公式法里面的绝对值</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-15</p>\n</div></div><div class=\"timeline-item-content\"><p>第二章：一维随机变量，第一遍学习框架。</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-19</p>\n</div></div><div class=\"timeline-item-content\"><p>第二章：一维随机变量，第一遍学习框架。</p>\n<p>补充内容！</p>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"第二章-一维随机变量\"><a href=\"#第二章-一维随机变量\" class=\"headerlink\" title=\"第二章 一维随机变量\"></a>第二章 一维随机变量</h1><h2 id=\"章节设置\"><a href=\"#章节设置\" class=\"headerlink\" title=\"章节设置\"></a>章节设置</h2><ul>\n<li>分布函数<ul>\n<li>随机变量的定义</li>\n<li>分布函数的定义</li>\n<li>分布函数的性质</li>\n<li>如何判断一个函数是否为分布函数（分布函数的充要条件）</li>\n</ul>\n</li>\n<li>离散型随机变量<ul>\n<li>概率分布</li>\n</ul>\n</li>\n<li>连续型随机变量<ul>\n<li>概率密度</li>\n</ul>\n</li>\n<li>八大分布函数</li>\n<li>随机变量函数</li>\n</ul>\n<h2 id=\"2-1-分布函数\"><a href=\"#2-1-分布函数\" class=\"headerlink\" title=\"2.1 分布函数\"></a>2.1 分布函数</h2><h3 id=\"2-1-1-随机变量的定义\"><a href=\"#2-1-1-随机变量的定义\" class=\"headerlink\" title=\"2.1.1 随机变量的定义\"></a>2.1.1 随机变量的定义</h3><p>设试验样本空间为<script type=\"math/tex\">\\Omega</script>，称实值函数<script type=\"math/tex\">X = X(\\omega),\\omega \\in \\Omega</script> 为随机变量，简记为<script type=\"math/tex\">X</script>。样本点的函数。</p>\n<h3 id=\"2-1-2-分布函数的定义\"><a href=\"#2-1-2-分布函数的定义\" class=\"headerlink\" title=\"2.1.2 分布函数的定义\"></a>2.1.2 分布函数的定义</h3><p>设<script type=\"math/tex\">X</script>为随机变量，对任意实数<script type=\"math/tex\">x</script>，称<script type=\"math/tex\">F(x)=P\\{X\\le x \\}</script> 为<script type=\"math/tex\">X</script>的分布函数。</p>\n<h3 id=\"2-1-3-分布函数的性质\"><a href=\"#2-1-3-分布函数的性质\" class=\"headerlink\" title=\"2.1.3 分布函数的性质\"></a>2.1.3 分布函数的性质</h3><ol>\n<li>非负性</li>\n<li>规范性</li>\n<li>右连续 <script type=\"math/tex\">F(x_0+0) = F(x_0)</script></li>\n<li>单调不减 当<script type=\"math/tex\">x_1 \\le x_2</script> 时 <script type=\"math/tex\">F(x_1)\\le F(x_2)</script></li>\n<li>计算单点 <script type=\"math/tex\">P\\left\\{X=x_0\\right\\}=F\\left(x_0\\right)-F\\left(x_0-0\\right)</script></li>\n<li>计算区间 <script type=\"math/tex\">P\\{a<X \\leq b\\}=F(b)-F(a)</script></li>\n</ol>\n<p>前四个性质是分布函数的==充要条件== 后两个是==计算==某一个区间的概率的公式</p>\n<blockquote>\n<p>TIPS: 需要弄清楚<script type=\"math/tex\">F(x) 与 f(x)</script> 之间的关系</p>\n</blockquote>\n<h2 id=\"2-2-一维离散随机变量\"><a href=\"#2-2-一维离散随机变量\" class=\"headerlink\" title=\"2.2 一维离散随机变量\"></a>2.2 一维离散随机变量</h2><h3 id=\"2-2-1-概率分布的定义\"><a href=\"#2-2-1-概率分布的定义\" class=\"headerlink\" title=\"2.2.1 概率分布的定义\"></a>2.2.1 概率分布的定义</h3><ul>\n<li><p>概率分布的定义</p>\n<p>概率分布的定义 设随机变量  <script type=\"math/tex\">X</script> 的取值为有限个或可列个, 称 <script type=\"math/tex\">X</script>  为离散型随机变量.</p>\n<script type=\"math/tex; mode=display\">\n设  X  的取值为  x_{1}, x_{2}, \\cdots,  称  P\\left\\{X=x_{i}\\right\\}=p_{i}, i=1,2, \\cdots  为  X  的概率分布或分布律, 也可用列表法表示\\\\\nF(x)=P\\{X \\leq x\\}=\\sum_{x_{i} \\leq x} p_{i}</script></li>\n<li><p>什么是离散型随机变量</p>\n</li>\n</ul>\n<h3 id=\"2-2-2-概率分布的性质\"><a href=\"#2-2-2-概率分布的性质\" class=\"headerlink\" title=\"2.2.2 概率分布的性质\"></a>2.2.2 概率分布的性质</h3><ul>\n<li><p>非负性</p>\n</li>\n<li><p>规范性</p>\n<p>前两条构成概率分布的充要条件。</p>\n</li>\n<li><p>计算</p>\n</li>\n</ul>\n<h2 id=\"2-3-一维连续随机变量\"><a href=\"#2-3-一维连续随机变量\" class=\"headerlink\" title=\"2.3 一维连续随机变量\"></a>2.3 一维连续随机变量</h2><h3 id=\"2-3-1-概率密度的定义\"><a href=\"#2-3-1-概率密度的定义\" class=\"headerlink\" title=\"2.3.1 概率密度的定义\"></a>2.3.1 概率密度的定义</h3><ul>\n<li><p>什么是连续型随机变量</p>\n</li>\n<li><p>概率密度的定义</p>\n<p>概率密度的定义 设随机变量X的分布函数为F(x),若存在非负可积函数f(x),对任意实数x,有<script type=\"math/tex\">F(x)= \\int _{- \\infty}^{x}f(t)dt</script>,则称X为连续型随机变量,f(x)称为X的概率密度或密度函数.</p>\n</li>\n</ul>\n<p>概率密度并不是单点的概率，而是概率在该处的变化率，连续型随机变量的单点的概率始终=0，所以研究单点的概率是无意义的</p>\n<h3 id=\"2-3-2-概率密度的性质\"><a href=\"#2-3-2-概率密度的性质\" class=\"headerlink\" title=\"2.3.2 概率密度的性质\"></a>2.3.2 概率密度的性质</h3><ol>\n<li><p>非负性 <script type=\"math/tex\">f(x)\\geq 0,- \\infty <x<+\\infty</script></p>\n</li>\n<li><p>规范性 <script type=\"math/tex\">\\int _{- \\infty}^{+ \\infty}f(x)dx=1;</script></p>\n<p>上述两个性质也是概率密度的充要条件。</p>\n</li>\n<li><p>计算<script type=\"math/tex\">P \\left\\{ a<X \\leq b \\right\\} = \\int _{a}^{b}f(x)dx.</script></p>\n</li>\n</ol>\n<p>【评注】性质(1)，(2)构成概率密度的充要条件，用于判定概率密度或已知概率密度反求参数;性<br>质(3)用于计算随机变量取值的概率，可以推广为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ a<X \\leq b \\right\\} =P \\left\\{ a \\leq X<b \\right\\} =P \\left\\{ a \\leq X \\leq b \\right\\} =P \\left\\{ a<X<b \\right\\} = \\int _{a}^{b}f(x)dx</script><p>例题：</p>\n<div class=\"tabs\" id=\"有关概率密度定义&性质的题目\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#有关概率密度定义&性质的题目-1\">例题</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#有关概率密度定义&性质的题目-2\">总结</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"有关概率密度定义&性质的题目-1\"><p>【例2.4】(2002，数一)设 <script type=\"math/tex\">X_{1}</script>和 <script type=\"math/tex\">X_{2}</script>是任意两个相互独立的连续型随机变量，它们的概率密度分别为</p>\n<p><script type=\"math/tex\">f_{1}</script>(x)与 <script type=\"math/tex\">f_{2}</script>(x),分布函数分别为 <script type=\"math/tex\">F_{1}</script>(x)与 <script type=\"math/tex\">F_{2}(x)</script>，则【 】<br>(A)<script type=\"math/tex\">f_{1}(x)+f_{2}(x)</script>必为某一随机变量的概率密度<br>(B) <script type=\"math/tex\">f_{1}(x)f_{2}</script>(x)必为某一随机变量的概率密度.<br>(C)<script type=\"math/tex\">F_{1}(x)+F_{2}(x)</script>必为某一随机变量的分布函数.<br>(D) <script type=\"math/tex\">F_{1}(x)F_{2}(x)</script>)必为某一随机变量的分布函数.</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"有关概率密度定义&性质的题目-2\"><ul>\n<li><script type=\"math/tex; mode=display\">aF_1 +bF_2 \\ \\ (a,b \\gt 0) \\ 为一个分布函数 \\Leftrightarrow   a+b = 1</script></li>\n<li><p><script type=\"math/tex\">F_1 F_2</script> 一定是一个分布函数</p>\n</li>\n<li><script type=\"math/tex; mode=display\">af_1 + bf_2 \\ \\ \\ (a,b \\gt 0)为概率密度 \\Leftrightarrow a+b=1</script></li>\n<li><script type=\"math/tex\">f_1f_2</script> 不一定是概率密度</li>\n</ul><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"2-4-八大概率分布（一定要关注定义）\"><a href=\"#2-4-八大概率分布（一定要关注定义）\" class=\"headerlink\" title=\"2.4 八大概率分布（一定要关注定义）\"></a>2.4 八大概率分布（一定要关注定义）</h2><h3 id=\"离散随机变量：\"><a href=\"#离散随机变量：\" class=\"headerlink\" title=\"离散随机变量：\"></a>离散随机变量：</h3><ul>\n<li><p>01分布  一次伯努利</p>\n</li>\n<li><p>Bernuolli分布</p>\n<p>设X为n重伯努利试验中事件A发生的次数，称X服从二项分布，记作<script type=\"math/tex\">X \\sim B(n,p)</script>，其概率分布<br>为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X=k \\right\\} =C_{n}^{k}p^{k}(1-p)^{n-k},k=0,1, \\cdots ,n</script><p>当<script type=\"math/tex\">n=1</script>时，<script type=\"math/tex\">X \\sim B(1,p)</script>，所以0-1分布为二项分布的特例</p>\n<ul>\n<li><p>二项分布的性质</p>\n<p>设<script type=\"math/tex\">X\\sim B(n，p)</script>,则<script type=\"math/tex\">Y=n-X \\sim B(n,1-p)</script></p>\n</li>\n</ul>\n</li>\n<li><p>几何分布</p>\n<p>无穷次伯努利</p>\n<p>设X为伯努利试验中事件A首次发生的试验次数，称X服从参数为p的几何分布，记作<script type=\"math/tex\">X \\sim G(p)</script><br>其概率分布为<script type=\"math/tex\">P \\left\\{ X=k \\right\\} =p(1-p)^{k-1},k=1,2,</script>…</p>\n<p>几何分布的性质(无记忆性)设<script type=\"math/tex\">X \\sim G(p)</script>，则对任意正整数m，n,有</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X>m+n|X>m \\right\\} =P \\left\\{ X>n\\right\\}</script><script type=\"math/tex; mode=display\">P \\left\\{ X=m+n|X>m \\right\\} =P \\left\\{ X=n\\right\\}</script></li>\n<li><p>超几何分布</p>\n<p>设N件产品，M件次品，从中任取n件，有X件次品，称X服从参数为N，M,n的超几何分布，记<br>作<script type=\"math/tex\">X\\sim H(N，M,n)</script>,其概率分布为</p>\n<script type=\"math/tex; mode=display\">P \\left\\{ X=k \\right\\} = \\frac{C_{M}^{k}C_{N-M}^{n-k}}{C_{N}^{n}},k=0,1, \\cdots , \\min(n,M) ...,\\min(n,M)</script></li>\n<li><p>Poisson分布</p>\n<p>设随机变量 <script type=\"math/tex\">X</script> 的概率分布为</p>\n<script type=\"math/tex; mode=display\">\nP\\{X=k\\}=\\frac{\\lambda^k}{k !} e^{-\\lambda}, k=0,1, \\cdots(\\lambda>0)</script><p>称 <script type=\"math/tex\">X</script> 服从参数为 <script type=\"math/tex\">\\lambda</script>的泊松分布, 记作 <script type=\"math/tex\">X \\sim P(\\lambda)</script>.</p>\n<ul>\n<li>Poisson 定理：</li>\n</ul>\n<p>泊松定理 设 <script type=\"math/tex\">\\lim _{n \\rightarrow \\infty} n p_n=\\lambda(\\lambda>0)</script>, 则对任意非负整数 <script type=\"math/tex\">k</script>, 有</p>\n<script type=\"math/tex; mode=display\">\n\\lim _{n \\rightarrow \\infty} C_n^k p_n^k\\left(1-p_n\\right)^{n-k}=\\frac{\\lambda^k}{k !} e^{-\\lambda}</script><p>在实际应用中可以得到二项分布的近似计算, 即当 <script type=\"math/tex\">n</script> 很大, <script type=\"math/tex\">p</script> 很小时, 有</p>\n<script type=\"math/tex; mode=display\">\nC_n^k p^k(1-p)^{n-k} \\approx \\frac{\\lambda^k}{k !} e^{-\\lambda} \\text {, 其中 } \\lambda=n p</script></li>\n</ul>\n<h3 id=\"连续随机变量：\"><a href=\"#连续随机变量：\" class=\"headerlink\" title=\"连续随机变量：\"></a>连续随机变量：</h3><ul>\n<li><p>均匀分布</p>\n<p>设随机变量X的概率密度为</p>\n<script type=\"math/tex; mode=display\">\nf(x)= \\left\\{ \n\\begin{matrix}\n\\frac{1}{b-a},&a \\leq x \\leq b \\\\ \n0, &其他 \\\\ \n\\end{matrix} \\right.</script></li>\n</ul>\n<p>  称X服从[a，b]上的均匀分布，记作<script type=\"math/tex\">X\\sim U(a，b)</script>,其分布函数为 (U—uniform)</p>\n<script type=\"math/tex; mode=display\">\n  F(x) = \n  \\begin{cases}\n  0, &\\ x \\lt a  \\\\\n  \\frac{x-a}{b-a}, &a\\le x \\lt b  \\\\\n  1, &x\\ge b  \\\\\n\n  \\end{cases}</script><ul>\n<li><p>指数分布</p>\n<p>设随机变量X的概率密度为</p>\n<script type=\"math/tex; mode=display\">f(x)= \\begin{cases}   \\lambda e^{- \\lambda x} , \\ & x>0  \\\\ 0, & x \\leq 0  \\end{cases} (\\lambda >0)</script><p>称X服从参数为λ的指数分布，记作X~E(λ)，其分布函数为</p>\n<script type=\"math/tex; mode=display\">F(x)= \\begin{cases}  1-e^{- \\lambda x},x>0  \\\\ 0, x \\leq 0  \\end{cases}</script></li>\n<li><p>正态分布 :exclamation:</p>\n<p>设随机变量X的概率密度为</p>\n<script type=\"math/tex; mode=display\">\nf(x)= \\frac{1}{\\sqrt{2 \\pi}\\sigma}e^{\\frac{(x- \\mu)^{2}}{2 \\sigma ^{2}}}  - \\infty</script><p>其中μ，σ为常数且<script type=\"math/tex\">\\sigma >0</script>，称X服从参数为μ，σ的正态分布，记作<script type=\"math/tex\">X \\sim N(\\mu , \\sigma ^{2})</script>，其分布函数为</p>\n<script type=\"math/tex; mode=display\">\nF(x)= \\int _{- \\infty}^{x}\\frac{1}{\\sqrt{2 \\pi}\\sigma}e^{\\frac{(t- \\mu)^{2}}{2 \\sigma ^{2}}} dt, - \\infty</script><ul>\n<li><p>标准正态分布</p>\n<p>当<script type=\"math/tex\">\\mu =0, \\sigma ^{2}=1</script> 时，X~N(0,1),称X服从标准正态分布，其概率密度为</p>\n<script type=\"math/tex; mode=display\">\n\\varphi(x)= \\frac{1}{\\sqrt{2 \\pi}}e^{- \\frac{x^{2}}{2}}  - \\infty  \\\\\n分布函数:\\\\\n\\Phi(x)= \\int _{- \\infty}^{x}\\frac{1}{\\sqrt{2 \\pi}}e^{- \\frac{t^{2}}{2}}dt,- \\infty</script></li>\n<li><p>正态分布的性质（其实是标准正态分布的性质）</p>\n<ol>\n<li><script type=\"math/tex; mode=display\">\\Phi(0)= \\frac{1}{2} ， \\Phi(-x)=1- \\Phi(x);</script></li>\n<li>设<script type=\"math/tex\">X\\sim N(0，1)</script>,则<script type=\"math/tex\">P \\left\\{ |X|<x \\right\\} = \\Phi(x)- \\Phi(-x)=2 \\Phi(x)-1</script></li>\n</ol>\n</li>\n<li><p>正态分布的标准化</p>\n<p> 设<script type=\"math/tex\">X \\sim N(\\mu , \\sigma ^{2})</script>，分布函数为F(x)，则<script type=\"math/tex\">\\frac{X- \\mu}{\\sigma}\\sim N(0,1)</script>，故</p>\n<script type=\"math/tex; mode=display\">F(x)= \\Phi(\\frac{x- \\mu}{\\sigma}),P \\left\\{ a<X \\leq b \\right\\} = \\Phi(\\frac{b- \\mu}{\\sigma})- \\Phi(\\frac{a- \\mu}{\\sigma})</script></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-5-一维随机变量函数的分布\"><a href=\"#2-5-一维随机变量函数的分布\" class=\"headerlink\" title=\"2.5 一维随机变量函数的分布\"></a>2.5 一维随机变量函数的分布</h2><h3 id=\"离散型的概率分布中计算其随机变量函数的分布函数\"><a href=\"#离散型的概率分布中计算其随机变量函数的分布函数\" class=\"headerlink\" title=\"离散型的概率分布中计算其随机变量函数的分布函数\"></a>离散型的概率分布中计算其随机变量函数的分布函数</h3><h3 id=\"连续型随机变量函数的分布\"><a href=\"#连续型随机变量函数的分布\" class=\"headerlink\" title=\"连续型随机变量函数的分布\"></a>连续型随机变量函数的分布</h3><p>设随机变量X的概率密度为 <script type=\"math/tex\">f_{x}(x)</script>，求<script type=\"math/tex\">Y=g(X)</script>的分布.</p>\n<h4 id=\"法一：分布函数法\"><a href=\"#法一：分布函数法\" class=\"headerlink\" title=\"法一：分布函数法\"></a>法一：分布函数法</h4><ul>\n<li><p>写分布函数： 设Y的分布函数为 <script type=\"math/tex\">F_{Y}(y)</script>),则<script type=\"math/tex\">F_{Y}(y)=P \\left\\{ Y \\leq y \\right\\} =P \\left\\{ g(X)\\leq y\\right\\}</script></p>\n</li>\n<li><p>讨论小y：图像法讨论： 求<script type=\"math/tex\">Y=g(X)</script>在X的==正概率密度==区间的值域<script type=\"math/tex\">[\\alpha，\\beta]</script>,讨论y</p>\n<p>当<script type=\"math/tex\">y<\\alpha</script>时，<script type=\"math/tex\">F_{y}(y)=0</script><br>当<script type=\"math/tex\">\\alpha \\leq y<\\beta</script>时，<script type=\"math/tex\">F_{Y}(y)= \\int_{g(x)\\le y } f_{x}(x)dx;</script><br>当<script type=\"math/tex\">y \\geq \\beta</script>时，<script type=\"math/tex\">F_{Y}(y)=1</script></p>\n</li>\n<li><p>求导</p>\n</li>\n</ul>\n<h4 id=\"法二：公式法\"><a href=\"#法二：公式法\" class=\"headerlink\" title=\"法二：公式法\"></a>法二：公式法</h4><p>设<script type=\"math/tex\">y=g(x)</script>在X的正概率密度区间单调，值域为[α，β],反函数为<script type=\"math/tex\">x=h(y)</script>，则Y的概率密度为</p>\n<script type=\"math/tex; mode=display\">\nf_{Y}(y)= \n\n\\begin{cases} \nf_{x}(h(y))|h^{\\prime}(y)|&, a \\leq y \\leq \\beta \\\\ \n0  &, 其他 \\\\ \\end{cases}</script><p>若<script type=\"math/tex\">y=g(x)</script>在X的正概率密度区间[a，b]==分段严格单调==，则分段运用公式法，然后将概率密度相加.  注意公式法里面的绝对值</p>\n"},{"title":"考研数学（概率论部分，第四章）学习","mathjax":true,"copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-22T05:42:33.000Z","updated":"2023-04-22T05:42:33.000Z","keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg","_content":"\n\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-22 -->\n\n第四章：数字特征\n\n- 期望\n- 方差\n- 协方差\n- 相关系数\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n\n\n- 期望 \n- 方差\n- 协方差\n\n# 期望与方差\n\n## 期望定义\n\n### 一维离散\n\n设随机变量X的概率分布为$$ P \\left\\{ X=x_{i}\\right\\} =p_{i},i=1,2 $$，...,则$$ EX= \\sum x_{i}p_{i} $$ \n\n推广： 若$$ Y=g(X) $$，则$$ EY= \\sum g(x_{i})p_{i}. $$\n\n### 一维连续\n\n设随机变量X的概率密度为f(x)，则$$ EX= \\int _{- \\infty}^{+ \\infty}xf(x)dx; $$\n\n推广 若$$ Y=g(X) $$，则$$ EY= \\int _{- \\infty}^{+ \\infty}g(x)f(x)dx; $$\n\n### 二维离散\n\n设二维随机变量(X，Y)的联合概率分布为$$ P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2,\\cdots $$\n$$ Z=g(X,Y) $$，则$$ EZ= \\sum \\sum g(x_{i},y_{j})p_{ij}; $$\n\n### 二维连续\n\n设二维随机变量(X，Y)的联合概率密度为f(x，y)$$ Z=g(X,Y) $$，则$$ EZ= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}g(x,y)f(x,y)dxdy. $$+0\n特别地，$$ EX= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}xf(x,y)dxdy,EY= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}yf(x,y)dxdy $$\n\n## 期望性质\n\n- $$ E(aX+bY+c)=aEX+bEY+c; $$ \n\n- $$ E(XY)=EX \\cdot EY \\Leftrightarrow X $$与Y不相关; \n\n  特别地，若X与Y相互独立，则$$\\Rightarrow  E(XY)=EX \\cdot EY $$.\n\n## 方差的定义\n\n$$\nDX=E(X-EX)^{2}=EX^{2}-(EX)^{2} \\ \\ \\ Deviation  ：平方的期望减去期望的平方\n$$\n\n==方差性质的逆用==: 前提 方差DX 可以被很容易地求出。 \n\n主要求$$EX^2 = DX+(EX)^2$$\n\n## 方差的性质\n\n- $$ D(aX+c)=a^{2}DX $$;  系数平方 常数忽略。\n\n- $$ D(X \\pm Y)=DX+DY \\pm 2Cov(X,Y); $$\n\n  推论$$ D(X \\pm Y)=DX+DY \\Rightarrow X $$ 与$$Y$$不相关;\n  特别地，若X与Y相互独立，则$$ D(X+Y)=DX+DY $$\n\n- 若X与Y相互独立，则$$ D(XY)=DX \\cdot DY+(EX)^{2}DY+(EY)^{2}DX $$\n\n这里与第三章的随机变量的独立性的充要条件相互联系\n\n## 八大分布的期望与方差\n\n| 分布                  | 记号                       | 期望                     | 方差                                                 |\n| --------------------- | -------------------------- | ------------------------ | ---------------------------------------------------- |\n| 0-1 分布              | $$B(1,p)$$                 | $$p$$                    | $$ p(1-p) $$                                         |\n| 二项分布              | $$B(n,p)$$                 | $$np$$                   | $$ np(1-p) $$                                        |\n| Poisson分布           | $$P(\\lambda)$$             | $$\\lambda$$              | $$\\lambda$$                                          |\n| 几何分布              | $$G(p)$$                   | $$  \\frac{1}{p} $$       | $$  \\frac{1-p}{p^{2}} $$                             |\n| 超几何分布            | $$H(N,M,n)$$               | $$  \\frac{nM}{N} $$      | $$  \\frac{nM}{N}(1- \\frac{M}{N})(\\frac{N-n}{N-1}) $$ |\n| 均匀分布              | $$U(a,b)$$                 | $$  \\frac{a+b}{2} $$     | $$  \\frac{(b-a)^{2}}{12} $$                          |\n| 指数分布              | $$E(\\lambda)$$             | $$  \\frac{1}{\\lambda} $$ | $$  \\frac{1}{\\lambda ^{2}} $$                        |\n| Gauss分布（正态分布） | $$N(\\mu,   \\sigma ^{2} )$$ | $$\\mu$$                  | $$\\sigma ^{2}$$                                      |\n\n\n\n# 协方差与相关系数\n\n## 协方差定义\n\n$$\nCov(X,Y)=E \\left[(X-EX)(Y-EY)\\right] =E(XY)-EX \\cdot EY\n$$\n\n  乘积的期望减去期望的乘积\n\n## 协方差的性质\n\n$$\nCov(X,Y)=Cov(Y,X),Cov(X,X)=DX \\\\\n\n Cov(aX+bY+c,Z)=aCov(X,Z)+bCov(Y,Z)\n$$\n\n推广：\n$$\n已知 U = aX+b , V = cY+d \\ \\ 则 \\ \\ Cov(U,V) = Cov(aX+b,V) = aCov(X,V) =  aCov(X,cY+d) = acCov(X,Y)\n$$\n\n\n{% tabs 例题%}\n<!-- tab 例题 -->\n\n[例4.6](2004，数一)设随机变量 $$ X_{1} ， X_{2} ，..., X_{n} $$ 相互独立同分布，方差$$  \\sigma ^{2}>0 $$.若$$ Y= \\frac{1}{n}\\sum _{i=1}^{n}X_{i} $$\n则【】\n(A)$$ Cov(X_{1},Y)= \\frac{\\sigma ^{2}}{n} $$ (B)$$ Cov(X_{1},Y)= \\sigma ^{2} $$\n(C)$$ D(X_{1}+Y)= \\frac{n+2}{n}\\sigma ^{2} $$ (D)$$ D(X_{1}-Y)= \\frac{n+1}{n}\\sigma ^{2} $$\n\n<!-- endtab -->\n\n<!-- tab 法一-->\n\n对A B选项使用协方差的性质二，进行计算，对CD使用方差的性质一和性质二，进行计算\n\n<!-- endtab -->\n\n<!-- tab 法二（对于cd选项的另一种计算）-->\n$$\n由于Y= \\frac{1}{n}\\sum _{i=1}^{n}X_{i}  \\ \\  故 \\\\\nX+Y =  \\frac{1+n}{n} X_1 +  \\frac{1}{n}\\sum _{i=2}^{n}X_{i} \\\\\nX-Y =  \\frac{n-1}{n} X_1 +  \\frac{1}{n}\\sum _{i=2}^{n}X_{i} \\\\\n又X_{1} ， X_{2} ，..., X_{n}相互独立同分布 ，所以对应的方差就可以使用方差性质二（对相互独立事件的方差的计算方法）来计算。\n$$\n<!-- endtab -->\n{% endtabs %}\n\n## 相关系数的定义\n\n$$  \\rho _{XY}= \\frac{Cov(X,Y)}{\\sqrt{DX}\\sqrt{DY}}= \\frac{E(XY)-EX \\cdot EY}{\\sqrt{DX}\\sqrt{DY}} $$\n\n## 相关系数的性质\n\n- $$ | \\rho _{XY}| \\leq 1; $$ \n- $$ \\rho_{XY}=0 \\Leftrightarrow Cov(X,Y)=O \\Leftrightarrow E(XY)=EX \\cdot EY \\Leftrightarrow D(X+Y)=DX+DY $$;\n- $$ \\rho_{XY}=1 \\Leftrightarrow P \\left\\{ Y=aX+b \\right\\} =1(a>0); \\rho _{XY}=-1 \\Leftrightarrow P \\left\\{ Y=aX+b \\right\\} =1(a<0) $$\n\n推广：\n$$\n\n$$\n\n\n对于相关系数的含义的理解[^1]\n\n明确不相关和相互独立的关系：独立一定不相关\n\n一些联想和小结\n\n- 方差的性质中 有涉及到两个随机变量的相关性的性质，\n\n\n\n\n\n\n\n[^1]: [(16 封私信 / 25 条消息) 相关系数有什么意义，为什么说不能体现相关的程度？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/21445638)\n","source":"_posts/考研数学（概率论部分，第四章）学习.md","raw":"---\ntitle: 考研数学（概率论部分，第四章）学习\nmathjax: true\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-22 13:42:33\nupdated: 2023-04-22 13:42:33\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg\n---\n\n\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-22 -->\n\n第四章：数字特征\n\n- 期望\n- 方差\n- 协方差\n- 相关系数\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n\n\n- 期望 \n- 方差\n- 协方差\n\n# 期望与方差\n\n## 期望定义\n\n### 一维离散\n\n设随机变量X的概率分布为$$ P \\left\\{ X=x_{i}\\right\\} =p_{i},i=1,2 $$，...,则$$ EX= \\sum x_{i}p_{i} $$ \n\n推广： 若$$ Y=g(X) $$，则$$ EY= \\sum g(x_{i})p_{i}. $$\n\n### 一维连续\n\n设随机变量X的概率密度为f(x)，则$$ EX= \\int _{- \\infty}^{+ \\infty}xf(x)dx; $$\n\n推广 若$$ Y=g(X) $$，则$$ EY= \\int _{- \\infty}^{+ \\infty}g(x)f(x)dx; $$\n\n### 二维离散\n\n设二维随机变量(X，Y)的联合概率分布为$$ P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2,\\cdots $$\n$$ Z=g(X,Y) $$，则$$ EZ= \\sum \\sum g(x_{i},y_{j})p_{ij}; $$\n\n### 二维连续\n\n设二维随机变量(X，Y)的联合概率密度为f(x，y)$$ Z=g(X,Y) $$，则$$ EZ= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}g(x,y)f(x,y)dxdy. $$+0\n特别地，$$ EX= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}xf(x,y)dxdy,EY= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}yf(x,y)dxdy $$\n\n## 期望性质\n\n- $$ E(aX+bY+c)=aEX+bEY+c; $$ \n\n- $$ E(XY)=EX \\cdot EY \\Leftrightarrow X $$与Y不相关; \n\n  特别地，若X与Y相互独立，则$$\\Rightarrow  E(XY)=EX \\cdot EY $$.\n\n## 方差的定义\n\n$$\nDX=E(X-EX)^{2}=EX^{2}-(EX)^{2} \\ \\ \\ Deviation  ：平方的期望减去期望的平方\n$$\n\n==方差性质的逆用==: 前提 方差DX 可以被很容易地求出。 \n\n主要求$$EX^2 = DX+(EX)^2$$\n\n## 方差的性质\n\n- $$ D(aX+c)=a^{2}DX $$;  系数平方 常数忽略。\n\n- $$ D(X \\pm Y)=DX+DY \\pm 2Cov(X,Y); $$\n\n  推论$$ D(X \\pm Y)=DX+DY \\Rightarrow X $$ 与$$Y$$不相关;\n  特别地，若X与Y相互独立，则$$ D(X+Y)=DX+DY $$\n\n- 若X与Y相互独立，则$$ D(XY)=DX \\cdot DY+(EX)^{2}DY+(EY)^{2}DX $$\n\n这里与第三章的随机变量的独立性的充要条件相互联系\n\n## 八大分布的期望与方差\n\n| 分布                  | 记号                       | 期望                     | 方差                                                 |\n| --------------------- | -------------------------- | ------------------------ | ---------------------------------------------------- |\n| 0-1 分布              | $$B(1,p)$$                 | $$p$$                    | $$ p(1-p) $$                                         |\n| 二项分布              | $$B(n,p)$$                 | $$np$$                   | $$ np(1-p) $$                                        |\n| Poisson分布           | $$P(\\lambda)$$             | $$\\lambda$$              | $$\\lambda$$                                          |\n| 几何分布              | $$G(p)$$                   | $$  \\frac{1}{p} $$       | $$  \\frac{1-p}{p^{2}} $$                             |\n| 超几何分布            | $$H(N,M,n)$$               | $$  \\frac{nM}{N} $$      | $$  \\frac{nM}{N}(1- \\frac{M}{N})(\\frac{N-n}{N-1}) $$ |\n| 均匀分布              | $$U(a,b)$$                 | $$  \\frac{a+b}{2} $$     | $$  \\frac{(b-a)^{2}}{12} $$                          |\n| 指数分布              | $$E(\\lambda)$$             | $$  \\frac{1}{\\lambda} $$ | $$  \\frac{1}{\\lambda ^{2}} $$                        |\n| Gauss分布（正态分布） | $$N(\\mu,   \\sigma ^{2} )$$ | $$\\mu$$                  | $$\\sigma ^{2}$$                                      |\n\n\n\n# 协方差与相关系数\n\n## 协方差定义\n\n$$\nCov(X,Y)=E \\left[(X-EX)(Y-EY)\\right] =E(XY)-EX \\cdot EY\n$$\n\n  乘积的期望减去期望的乘积\n\n## 协方差的性质\n\n$$\nCov(X,Y)=Cov(Y,X),Cov(X,X)=DX \\\\\n\n Cov(aX+bY+c,Z)=aCov(X,Z)+bCov(Y,Z)\n$$\n\n推广：\n$$\n已知 U = aX+b , V = cY+d \\ \\ 则 \\ \\ Cov(U,V) = Cov(aX+b,V) = aCov(X,V) =  aCov(X,cY+d) = acCov(X,Y)\n$$\n\n\n{% tabs 例题%}\n<!-- tab 例题 -->\n\n[例4.6](2004，数一)设随机变量 $$ X_{1} ， X_{2} ，..., X_{n} $$ 相互独立同分布，方差$$  \\sigma ^{2}>0 $$.若$$ Y= \\frac{1}{n}\\sum _{i=1}^{n}X_{i} $$\n则【】\n(A)$$ Cov(X_{1},Y)= \\frac{\\sigma ^{2}}{n} $$ (B)$$ Cov(X_{1},Y)= \\sigma ^{2} $$\n(C)$$ D(X_{1}+Y)= \\frac{n+2}{n}\\sigma ^{2} $$ (D)$$ D(X_{1}-Y)= \\frac{n+1}{n}\\sigma ^{2} $$\n\n<!-- endtab -->\n\n<!-- tab 法一-->\n\n对A B选项使用协方差的性质二，进行计算，对CD使用方差的性质一和性质二，进行计算\n\n<!-- endtab -->\n\n<!-- tab 法二（对于cd选项的另一种计算）-->\n$$\n由于Y= \\frac{1}{n}\\sum _{i=1}^{n}X_{i}  \\ \\  故 \\\\\nX+Y =  \\frac{1+n}{n} X_1 +  \\frac{1}{n}\\sum _{i=2}^{n}X_{i} \\\\\nX-Y =  \\frac{n-1}{n} X_1 +  \\frac{1}{n}\\sum _{i=2}^{n}X_{i} \\\\\n又X_{1} ， X_{2} ，..., X_{n}相互独立同分布 ，所以对应的方差就可以使用方差性质二（对相互独立事件的方差的计算方法）来计算。\n$$\n<!-- endtab -->\n{% endtabs %}\n\n## 相关系数的定义\n\n$$  \\rho _{XY}= \\frac{Cov(X,Y)}{\\sqrt{DX}\\sqrt{DY}}= \\frac{E(XY)-EX \\cdot EY}{\\sqrt{DX}\\sqrt{DY}} $$\n\n## 相关系数的性质\n\n- $$ | \\rho _{XY}| \\leq 1; $$ \n- $$ \\rho_{XY}=0 \\Leftrightarrow Cov(X,Y)=O \\Leftrightarrow E(XY)=EX \\cdot EY \\Leftrightarrow D(X+Y)=DX+DY $$;\n- $$ \\rho_{XY}=1 \\Leftrightarrow P \\left\\{ Y=aX+b \\right\\} =1(a>0); \\rho _{XY}=-1 \\Leftrightarrow P \\left\\{ Y=aX+b \\right\\} =1(a<0) $$\n\n推广：\n$$\n\n$$\n\n\n对于相关系数的含义的理解[^1]\n\n明确不相关和相互独立的关系：独立一定不相关\n\n一些联想和小结\n\n- 方差的性质中 有涉及到两个随机变量的相关性的性质，\n\n\n\n\n\n\n\n[^1]: [(16 封私信 / 25 条消息) 相关系数有什么意义，为什么说不能体现相关的程度？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/21445638)\n","slug":"考研数学（概率论部分，第四章）学习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwme000rbsuocdhpglh1","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-22</p>\n</div></div><div class=\"timeline-item-content\"><p>第四章：数字特征</p>\n<ul>\n<li>期望</li>\n<li>方差</li>\n<li>协方差</li>\n<li>相关系数</li>\n</ul>\n</div></div></div>\n<ul>\n<li>期望 </li>\n<li>方差</li>\n<li>协方差</li>\n</ul>\n<h1 id=\"期望与方差\"><a href=\"#期望与方差\" class=\"headerlink\" title=\"期望与方差\"></a>期望与方差</h1><h2 id=\"期望定义\"><a href=\"#期望定义\" class=\"headerlink\" title=\"期望定义\"></a>期望定义</h2><h3 id=\"一维离散\"><a href=\"#一维离散\" class=\"headerlink\" title=\"一维离散\"></a>一维离散</h3><p>设随机变量X的概率分布为<script type=\"math/tex\">P \\left\\{ X=x_{i}\\right\\} =p_{i},i=1,2</script>，…,则<script type=\"math/tex\">EX= \\sum x_{i}p_{i}</script> </p>\n<p>推广： 若<script type=\"math/tex\">Y=g(X)</script>，则<script type=\"math/tex\">EY= \\sum g(x_{i})p_{i}.</script></p>\n<h3 id=\"一维连续\"><a href=\"#一维连续\" class=\"headerlink\" title=\"一维连续\"></a>一维连续</h3><p>设随机变量X的概率密度为f(x)，则<script type=\"math/tex\">EX= \\int _{- \\infty}^{+ \\infty}xf(x)dx;</script></p>\n<p>推广 若<script type=\"math/tex\">Y=g(X)</script>，则<script type=\"math/tex\">EY= \\int _{- \\infty}^{+ \\infty}g(x)f(x)dx;</script></p>\n<h3 id=\"二维离散\"><a href=\"#二维离散\" class=\"headerlink\" title=\"二维离散\"></a>二维离散</h3><p>设二维随机变量(X，Y)的联合概率分布为<script type=\"math/tex\">P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2,\\cdots</script></p>\n<script type=\"math/tex; mode=display\">Z=g(X,Y) $$，则$$ EZ= \\sum \\sum g(x_{i},y_{j})p_{ij};</script><h3 id=\"二维连续\"><a href=\"#二维连续\" class=\"headerlink\" title=\"二维连续\"></a>二维连续</h3><p>设二维随机变量(X，Y)的联合概率密度为f(x，y)<script type=\"math/tex\">Z=g(X,Y)</script>，则<script type=\"math/tex\">EZ= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}g(x,y)f(x,y)dxdy.</script>+0<br>特别地，<script type=\"math/tex\">EX= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}xf(x,y)dxdy,EY= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}yf(x,y)dxdy</script></p>\n<h2 id=\"期望性质\"><a href=\"#期望性质\" class=\"headerlink\" title=\"期望性质\"></a>期望性质</h2><ul>\n<li><script type=\"math/tex; mode=display\">E(aX+bY+c)=aEX+bEY+c;</script></li>\n<li><p><script type=\"math/tex\">E(XY)=EX \\cdot EY \\Leftrightarrow X</script>与Y不相关; </p>\n<p>特别地，若X与Y相互独立，则<script type=\"math/tex\">\\Rightarrow  E(XY)=EX \\cdot EY</script>.</p>\n</li>\n</ul>\n<h2 id=\"方差的定义\"><a href=\"#方差的定义\" class=\"headerlink\" title=\"方差的定义\"></a>方差的定义</h2><script type=\"math/tex; mode=display\">\nDX=E(X-EX)^{2}=EX^{2}-(EX)^{2} \\ \\ \\ Deviation  ：平方的期望减去期望的平方</script><p>==方差性质的逆用==: 前提 方差DX 可以被很容易地求出。 </p>\n<p>主要求<script type=\"math/tex\">EX^2 = DX+(EX)^2</script></p>\n<h2 id=\"方差的性质\"><a href=\"#方差的性质\" class=\"headerlink\" title=\"方差的性质\"></a>方差的性质</h2><ul>\n<li><p><script type=\"math/tex\">D(aX+c)=a^{2}DX</script>;  系数平方 常数忽略。</p>\n</li>\n<li><script type=\"math/tex; mode=display\">D(X \\pm Y)=DX+DY \\pm 2Cov(X,Y);</script><p>推论<script type=\"math/tex\">D(X \\pm Y)=DX+DY \\Rightarrow X</script> 与<script type=\"math/tex\">Y</script>不相关;<br>特别地，若X与Y相互独立，则<script type=\"math/tex\">D(X+Y)=DX+DY</script></p>\n</li>\n<li><p>若X与Y相互独立，则<script type=\"math/tex\">D(XY)=DX \\cdot DY+(EX)^{2}DY+(EY)^{2}DX</script></p>\n</li>\n</ul>\n<p>这里与第三章的随机变量的独立性的充要条件相互联系</p>\n<h2 id=\"八大分布的期望与方差\"><a href=\"#八大分布的期望与方差\" class=\"headerlink\" title=\"八大分布的期望与方差\"></a>八大分布的期望与方差</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>分布</th>\n<th>记号</th>\n<th>期望</th>\n<th>方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0-1 分布</td>\n<td><script type=\"math/tex\">B(1,p)</script></td>\n<td><script type=\"math/tex\">p</script></td>\n<td><script type=\"math/tex\">p(1-p)</script></td>\n</tr>\n<tr>\n<td>二项分布</td>\n<td><script type=\"math/tex\">B(n,p)</script></td>\n<td><script type=\"math/tex\">np</script></td>\n<td><script type=\"math/tex\">np(1-p)</script></td>\n</tr>\n<tr>\n<td>Poisson分布</td>\n<td><script type=\"math/tex\">P(\\lambda)</script></td>\n<td><script type=\"math/tex\">\\lambda</script></td>\n<td><script type=\"math/tex\">\\lambda</script></td>\n</tr>\n<tr>\n<td>几何分布</td>\n<td><script type=\"math/tex\">G(p)</script></td>\n<td><script type=\"math/tex\">\\frac{1}{p}</script></td>\n<td><script type=\"math/tex\">\\frac{1-p}{p^{2}}</script></td>\n</tr>\n<tr>\n<td>超几何分布</td>\n<td><script type=\"math/tex\">H(N,M,n)</script></td>\n<td><script type=\"math/tex\">\\frac{nM}{N}</script></td>\n<td><script type=\"math/tex\">\\frac{nM}{N}(1- \\frac{M}{N})(\\frac{N-n}{N-1})</script></td>\n</tr>\n<tr>\n<td>均匀分布</td>\n<td><script type=\"math/tex\">U(a,b)</script></td>\n<td><script type=\"math/tex\">\\frac{a+b}{2}</script></td>\n<td><script type=\"math/tex\">\\frac{(b-a)^{2}}{12}</script></td>\n</tr>\n<tr>\n<td>指数分布</td>\n<td><script type=\"math/tex\">E(\\lambda)</script></td>\n<td><script type=\"math/tex\">\\frac{1}{\\lambda}</script></td>\n<td><script type=\"math/tex\">\\frac{1}{\\lambda ^{2}}</script></td>\n</tr>\n<tr>\n<td>Gauss分布（正态分布）</td>\n<td><script type=\"math/tex\">N(\\mu,   \\sigma ^{2} )</script></td>\n<td><script type=\"math/tex\">\\mu</script></td>\n<td><script type=\"math/tex\">\\sigma ^{2}</script></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"协方差与相关系数\"><a href=\"#协方差与相关系数\" class=\"headerlink\" title=\"协方差与相关系数\"></a>协方差与相关系数</h1><h2 id=\"协方差定义\"><a href=\"#协方差定义\" class=\"headerlink\" title=\"协方差定义\"></a>协方差定义</h2><script type=\"math/tex; mode=display\">\nCov(X,Y)=E \\left[(X-EX)(Y-EY)\\right] =E(XY)-EX \\cdot EY</script><p>  乘积的期望减去期望的乘积</p>\n<h2 id=\"协方差的性质\"><a href=\"#协方差的性质\" class=\"headerlink\" title=\"协方差的性质\"></a>协方差的性质</h2><script type=\"math/tex; mode=display\">\nCov(X,Y)=Cov(Y,X),Cov(X,X)=DX \\\\\n\n Cov(aX+bY+c,Z)=aCov(X,Z)+bCov(Y,Z)</script><p>推广：</p>\n<script type=\"math/tex; mode=display\">\n已知 U = aX+b , V = cY+d \\ \\ 则 \\ \\ Cov(U,V) = Cov(aX+b,V) = aCov(X,V) =  aCov(X,cY+d) = acCov(X,Y)</script><div class=\"tabs\" id=\"例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#例题-1\">例题</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-2\">法一</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-3\">法二（对于cd选项的另一种计算）</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"例题-1\"><p><a href=\"2004，数一\">例4.6</a>设随机变量 <script type=\"math/tex\">X_{1} ， X_{2} ，..., X_{n}</script> 相互独立同分布，方差<script type=\"math/tex\">\\sigma ^{2}>0</script>.若<script type=\"math/tex\">Y= \\frac{1}{n}\\sum _{i=1}^{n}X_{i}</script><br>则【】<br>(A)<script type=\"math/tex\">Cov(X_{1},Y)= \\frac{\\sigma ^{2}}{n}</script> (B)<script type=\"math/tex\">Cov(X_{1},Y)= \\sigma ^{2}</script><br>(C)<script type=\"math/tex\">D(X_{1}+Y)= \\frac{n+2}{n}\\sigma ^{2}</script> (D)<script type=\"math/tex\">D(X_{1}-Y)= \\frac{n+1}{n}\\sigma ^{2}</script></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-2\"><p>对A B选项使用协方差的性质二，进行计算，对CD使用方差的性质一和性质二，进行计算</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-3\"><script type=\"math/tex; mode=display\">\n由于Y= \\frac{1}{n}\\sum _{i=1}^{n}X_{i}  \\ \\  故 \\\\\nX+Y =  \\frac{1+n}{n} X_1 +  \\frac{1}{n}\\sum _{i=2}^{n}X_{i} \\\\\nX-Y =  \\frac{n-1}{n} X_1 +  \\frac{1}{n}\\sum _{i=2}^{n}X_{i} \\\\\n又X_{1} ， X_{2} ，..., X_{n}相互独立同分布 ，所以对应的方差就可以使用方差性质二（对相互独立事件的方差的计算方法）来计算。</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"相关系数的定义\"><a href=\"#相关系数的定义\" class=\"headerlink\" title=\"相关系数的定义\"></a>相关系数的定义</h2><script type=\"math/tex; mode=display\">\\rho _{XY}= \\frac{Cov(X,Y)}{\\sqrt{DX}\\sqrt{DY}}= \\frac{E(XY)-EX \\cdot EY}{\\sqrt{DX}\\sqrt{DY}}</script><h2 id=\"相关系数的性质\"><a href=\"#相关系数的性质\" class=\"headerlink\" title=\"相关系数的性质\"></a>相关系数的性质</h2><ul>\n<li><script type=\"math/tex; mode=display\">| \\rho _{XY}| \\leq 1;</script></li>\n<li><script type=\"math/tex\">\\rho_{XY}=0 \\Leftrightarrow Cov(X,Y)=O \\Leftrightarrow E(XY)=EX \\cdot EY \\Leftrightarrow D(X+Y)=DX+DY</script>;</li>\n<li><script type=\"math/tex; mode=display\">\\rho_{XY}=1 \\Leftrightarrow P \\left\\{ Y=aX+b \\right\\} =1(a>0); \\rho _{XY}=-1 \\Leftrightarrow P \\left\\{ Y=aX+b \\right\\} =1(a<0)</script></li>\n</ul>\n<p>推广：</p>\n<script type=\"math/tex; mode=display\">\n</script><p>对于相关系数的含义的理解<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></p>\n<p>明确不相关和相互独立的关系：独立一定不相关</p>\n<p>一些联想和小结</p>\n<ul>\n<li>方差的性质中 有涉及到两个随机变量的相关性的性质，</li>\n</ul>\n<blockquote id=\"fn_1\">\n<sup>1</sup>. <a href=\"https://www.zhihu.com/question/21445638\">(16 封私信 / 25 条消息) 相关系数有什么意义，为什么说不能体现相关的程度？ - 知乎 (zhihu.com)</a><a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> ↩</a>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-22</p>\n</div></div><div class=\"timeline-item-content\"><p>第四章：数字特征</p>\n<ul>\n<li>期望</li>\n<li>方差</li>\n<li>协方差</li>\n<li>相关系数</li>\n</ul>\n</div></div></div>\n<ul>\n<li>期望 </li>\n<li>方差</li>\n<li>协方差</li>\n</ul>\n<h1 id=\"期望与方差\"><a href=\"#期望与方差\" class=\"headerlink\" title=\"期望与方差\"></a>期望与方差</h1><h2 id=\"期望定义\"><a href=\"#期望定义\" class=\"headerlink\" title=\"期望定义\"></a>期望定义</h2><h3 id=\"一维离散\"><a href=\"#一维离散\" class=\"headerlink\" title=\"一维离散\"></a>一维离散</h3><p>设随机变量X的概率分布为<script type=\"math/tex\">P \\left\\{ X=x_{i}\\right\\} =p_{i},i=1,2</script>，…,则<script type=\"math/tex\">EX= \\sum x_{i}p_{i}</script> </p>\n<p>推广： 若<script type=\"math/tex\">Y=g(X)</script>，则<script type=\"math/tex\">EY= \\sum g(x_{i})p_{i}.</script></p>\n<h3 id=\"一维连续\"><a href=\"#一维连续\" class=\"headerlink\" title=\"一维连续\"></a>一维连续</h3><p>设随机变量X的概率密度为f(x)，则<script type=\"math/tex\">EX= \\int _{- \\infty}^{+ \\infty}xf(x)dx;</script></p>\n<p>推广 若<script type=\"math/tex\">Y=g(X)</script>，则<script type=\"math/tex\">EY= \\int _{- \\infty}^{+ \\infty}g(x)f(x)dx;</script></p>\n<h3 id=\"二维离散\"><a href=\"#二维离散\" class=\"headerlink\" title=\"二维离散\"></a>二维离散</h3><p>设二维随机变量(X，Y)的联合概率分布为<script type=\"math/tex\">P \\left\\{ X=x_{i},Y=y_{j}\\right\\} =p_{ij},i,j=1,2,\\cdots</script></p>\n<script type=\"math/tex; mode=display\">Z=g(X,Y) $$，则$$ EZ= \\sum \\sum g(x_{i},y_{j})p_{ij};</script><h3 id=\"二维连续\"><a href=\"#二维连续\" class=\"headerlink\" title=\"二维连续\"></a>二维连续</h3><p>设二维随机变量(X，Y)的联合概率密度为f(x，y)<script type=\"math/tex\">Z=g(X,Y)</script>，则<script type=\"math/tex\">EZ= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}g(x,y)f(x,y)dxdy.</script>+0<br>特别地，<script type=\"math/tex\">EX= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}xf(x,y)dxdy,EY= \\int _{- \\infty}^{+ \\infty}\\int _{- \\infty}^{+ \\infty}yf(x,y)dxdy</script></p>\n<h2 id=\"期望性质\"><a href=\"#期望性质\" class=\"headerlink\" title=\"期望性质\"></a>期望性质</h2><ul>\n<li><script type=\"math/tex; mode=display\">E(aX+bY+c)=aEX+bEY+c;</script></li>\n<li><p><script type=\"math/tex\">E(XY)=EX \\cdot EY \\Leftrightarrow X</script>与Y不相关; </p>\n<p>特别地，若X与Y相互独立，则<script type=\"math/tex\">\\Rightarrow  E(XY)=EX \\cdot EY</script>.</p>\n</li>\n</ul>\n<h2 id=\"方差的定义\"><a href=\"#方差的定义\" class=\"headerlink\" title=\"方差的定义\"></a>方差的定义</h2><script type=\"math/tex; mode=display\">\nDX=E(X-EX)^{2}=EX^{2}-(EX)^{2} \\ \\ \\ Deviation  ：平方的期望减去期望的平方</script><p>==方差性质的逆用==: 前提 方差DX 可以被很容易地求出。 </p>\n<p>主要求<script type=\"math/tex\">EX^2 = DX+(EX)^2</script></p>\n<h2 id=\"方差的性质\"><a href=\"#方差的性质\" class=\"headerlink\" title=\"方差的性质\"></a>方差的性质</h2><ul>\n<li><p><script type=\"math/tex\">D(aX+c)=a^{2}DX</script>;  系数平方 常数忽略。</p>\n</li>\n<li><script type=\"math/tex; mode=display\">D(X \\pm Y)=DX+DY \\pm 2Cov(X,Y);</script><p>推论<script type=\"math/tex\">D(X \\pm Y)=DX+DY \\Rightarrow X</script> 与<script type=\"math/tex\">Y</script>不相关;<br>特别地，若X与Y相互独立，则<script type=\"math/tex\">D(X+Y)=DX+DY</script></p>\n</li>\n<li><p>若X与Y相互独立，则<script type=\"math/tex\">D(XY)=DX \\cdot DY+(EX)^{2}DY+(EY)^{2}DX</script></p>\n</li>\n</ul>\n<p>这里与第三章的随机变量的独立性的充要条件相互联系</p>\n<h2 id=\"八大分布的期望与方差\"><a href=\"#八大分布的期望与方差\" class=\"headerlink\" title=\"八大分布的期望与方差\"></a>八大分布的期望与方差</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>分布</th>\n<th>记号</th>\n<th>期望</th>\n<th>方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0-1 分布</td>\n<td><script type=\"math/tex\">B(1,p)</script></td>\n<td><script type=\"math/tex\">p</script></td>\n<td><script type=\"math/tex\">p(1-p)</script></td>\n</tr>\n<tr>\n<td>二项分布</td>\n<td><script type=\"math/tex\">B(n,p)</script></td>\n<td><script type=\"math/tex\">np</script></td>\n<td><script type=\"math/tex\">np(1-p)</script></td>\n</tr>\n<tr>\n<td>Poisson分布</td>\n<td><script type=\"math/tex\">P(\\lambda)</script></td>\n<td><script type=\"math/tex\">\\lambda</script></td>\n<td><script type=\"math/tex\">\\lambda</script></td>\n</tr>\n<tr>\n<td>几何分布</td>\n<td><script type=\"math/tex\">G(p)</script></td>\n<td><script type=\"math/tex\">\\frac{1}{p}</script></td>\n<td><script type=\"math/tex\">\\frac{1-p}{p^{2}}</script></td>\n</tr>\n<tr>\n<td>超几何分布</td>\n<td><script type=\"math/tex\">H(N,M,n)</script></td>\n<td><script type=\"math/tex\">\\frac{nM}{N}</script></td>\n<td><script type=\"math/tex\">\\frac{nM}{N}(1- \\frac{M}{N})(\\frac{N-n}{N-1})</script></td>\n</tr>\n<tr>\n<td>均匀分布</td>\n<td><script type=\"math/tex\">U(a,b)</script></td>\n<td><script type=\"math/tex\">\\frac{a+b}{2}</script></td>\n<td><script type=\"math/tex\">\\frac{(b-a)^{2}}{12}</script></td>\n</tr>\n<tr>\n<td>指数分布</td>\n<td><script type=\"math/tex\">E(\\lambda)</script></td>\n<td><script type=\"math/tex\">\\frac{1}{\\lambda}</script></td>\n<td><script type=\"math/tex\">\\frac{1}{\\lambda ^{2}}</script></td>\n</tr>\n<tr>\n<td>Gauss分布（正态分布）</td>\n<td><script type=\"math/tex\">N(\\mu,   \\sigma ^{2} )</script></td>\n<td><script type=\"math/tex\">\\mu</script></td>\n<td><script type=\"math/tex\">\\sigma ^{2}</script></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"协方差与相关系数\"><a href=\"#协方差与相关系数\" class=\"headerlink\" title=\"协方差与相关系数\"></a>协方差与相关系数</h1><h2 id=\"协方差定义\"><a href=\"#协方差定义\" class=\"headerlink\" title=\"协方差定义\"></a>协方差定义</h2><script type=\"math/tex; mode=display\">\nCov(X,Y)=E \\left[(X-EX)(Y-EY)\\right] =E(XY)-EX \\cdot EY</script><p>  乘积的期望减去期望的乘积</p>\n<h2 id=\"协方差的性质\"><a href=\"#协方差的性质\" class=\"headerlink\" title=\"协方差的性质\"></a>协方差的性质</h2><script type=\"math/tex; mode=display\">\nCov(X,Y)=Cov(Y,X),Cov(X,X)=DX \\\\\n\n Cov(aX+bY+c,Z)=aCov(X,Z)+bCov(Y,Z)</script><p>推广：</p>\n<script type=\"math/tex; mode=display\">\n已知 U = aX+b , V = cY+d \\ \\ 则 \\ \\ Cov(U,V) = Cov(aX+b,V) = aCov(X,V) =  aCov(X,cY+d) = acCov(X,Y)</script><div class=\"tabs\" id=\"例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#例题-1\">例题</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-2\">法一</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-3\">法二（对于cd选项的另一种计算）</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"例题-1\"><p><a href=\"2004，数一\">例4.6</a>设随机变量 <script type=\"math/tex\">X_{1} ， X_{2} ，..., X_{n}</script> 相互独立同分布，方差<script type=\"math/tex\">\\sigma ^{2}>0</script>.若<script type=\"math/tex\">Y= \\frac{1}{n}\\sum _{i=1}^{n}X_{i}</script><br>则【】<br>(A)<script type=\"math/tex\">Cov(X_{1},Y)= \\frac{\\sigma ^{2}}{n}</script> (B)<script type=\"math/tex\">Cov(X_{1},Y)= \\sigma ^{2}</script><br>(C)<script type=\"math/tex\">D(X_{1}+Y)= \\frac{n+2}{n}\\sigma ^{2}</script> (D)<script type=\"math/tex\">D(X_{1}-Y)= \\frac{n+1}{n}\\sigma ^{2}</script></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-2\"><p>对A B选项使用协方差的性质二，进行计算，对CD使用方差的性质一和性质二，进行计算</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-3\"><script type=\"math/tex; mode=display\">\n由于Y= \\frac{1}{n}\\sum _{i=1}^{n}X_{i}  \\ \\  故 \\\\\nX+Y =  \\frac{1+n}{n} X_1 +  \\frac{1}{n}\\sum _{i=2}^{n}X_{i} \\\\\nX-Y =  \\frac{n-1}{n} X_1 +  \\frac{1}{n}\\sum _{i=2}^{n}X_{i} \\\\\n又X_{1} ， X_{2} ，..., X_{n}相互独立同分布 ，所以对应的方差就可以使用方差性质二（对相互独立事件的方差的计算方法）来计算。</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"相关系数的定义\"><a href=\"#相关系数的定义\" class=\"headerlink\" title=\"相关系数的定义\"></a>相关系数的定义</h2><script type=\"math/tex; mode=display\">\\rho _{XY}= \\frac{Cov(X,Y)}{\\sqrt{DX}\\sqrt{DY}}= \\frac{E(XY)-EX \\cdot EY}{\\sqrt{DX}\\sqrt{DY}}</script><h2 id=\"相关系数的性质\"><a href=\"#相关系数的性质\" class=\"headerlink\" title=\"相关系数的性质\"></a>相关系数的性质</h2><ul>\n<li><script type=\"math/tex; mode=display\">| \\rho _{XY}| \\leq 1;</script></li>\n<li><script type=\"math/tex\">\\rho_{XY}=0 \\Leftrightarrow Cov(X,Y)=O \\Leftrightarrow E(XY)=EX \\cdot EY \\Leftrightarrow D(X+Y)=DX+DY</script>;</li>\n<li><script type=\"math/tex; mode=display\">\\rho_{XY}=1 \\Leftrightarrow P \\left\\{ Y=aX+b \\right\\} =1(a>0); \\rho _{XY}=-1 \\Leftrightarrow P \\left\\{ Y=aX+b \\right\\} =1(a<0)</script></li>\n</ul>\n<p>推广：</p>\n<script type=\"math/tex; mode=display\">\n</script><p>对于相关系数的含义的理解<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></p>\n<p>明确不相关和相互独立的关系：独立一定不相关</p>\n<p>一些联想和小结</p>\n<ul>\n<li>方差的性质中 有涉及到两个随机变量的相关性的性质，</li>\n</ul>\n<blockquote id=\"fn_1\">\n<sup>1</sup>. <a href=\"https://www.zhihu.com/question/21445638\">(16 封私信 / 25 条消息) 相关系数有什么意义，为什么说不能体现相关的程度？ - 知乎 (zhihu.com)</a><a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> ↩</a>\n</blockquote>\n"},{"title":"考研数学（高数部分，第七章）学习","mathjax":true,"copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-17T05:35:59.000Z","updated":"2023-04-17T05:35:59.000Z","keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg","_content":"\n\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-16 -->\n\n高等数学级数专题\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n\n\n\n\n[toc]\n\n\n\n\n\n# 级数\n\n一定要分清楚级数可以看作数列的前n项和，和数列极限区分开来，但是也有联系 \n\n## 级数的概念\n\n级数的收敛和发散\n\n## 级数的性质\n\n- 性质一：\n\n- 性质二：\n\n- 性质三：\n\n- 性质四：\n\n  \n\n## 正向级数\n\n### 正向级数的收敛判别法  \n\n- 四大判别法\n  - 比较\n  - 比值\n  - 根植\n  - 积分\n\n### 正向级数收敛的充要条件\n\n如果一个级数数列为正向级数且收敛，那么他的前n项和有界；反之如果一个正向数列其前n项和有界，那么这个正向级数收敛。\n\n### 比较判别法\n\n- 大收则小收\n- 小散则大散\n\n极限形式：\n\n- 同阶同敛散\n- 大收则小收\n- 小散则大散\n\n比较对象：\n\n- P级数\n- 等比数列\n\n### 比值判别法（达朗贝尔【Dalembert】判别法）\n\n- 达朗贝尔判别法的证明：\n\n### 根式判别法（Cauchy）\n\n### 积分判别法（P级数、对数P级数、广义P级数）\n\n\n\n","source":"_posts/考研数学（高数部分，第七章）学习.md","raw":"---\ntitle: 考研数学（高数部分，第七章）学习\nmathjax: true\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-17 13:35:59\nupdated: 2023-04-17 13:35:59\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg\n---\n\n\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-16 -->\n\n高等数学级数专题\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n\n\n\n\n[toc]\n\n\n\n\n\n# 级数\n\n一定要分清楚级数可以看作数列的前n项和，和数列极限区分开来，但是也有联系 \n\n## 级数的概念\n\n级数的收敛和发散\n\n## 级数的性质\n\n- 性质一：\n\n- 性质二：\n\n- 性质三：\n\n- 性质四：\n\n  \n\n## 正向级数\n\n### 正向级数的收敛判别法  \n\n- 四大判别法\n  - 比较\n  - 比值\n  - 根植\n  - 积分\n\n### 正向级数收敛的充要条件\n\n如果一个级数数列为正向级数且收敛，那么他的前n项和有界；反之如果一个正向数列其前n项和有界，那么这个正向级数收敛。\n\n### 比较判别法\n\n- 大收则小收\n- 小散则大散\n\n极限形式：\n\n- 同阶同敛散\n- 大收则小收\n- 小散则大散\n\n比较对象：\n\n- P级数\n- 等比数列\n\n### 比值判别法（达朗贝尔【Dalembert】判别法）\n\n- 达朗贝尔判别法的证明：\n\n### 根式判别法（Cauchy）\n\n### 积分判别法（P级数、对数P级数、广义P级数）\n\n\n\n","slug":"考研数学（高数部分，第七章）学习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmf000vbsuoe3i59frc","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-16</p>\n</div></div><div class=\"timeline-item-content\"><p>高等数学级数专题</p>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"级数\"><a href=\"#级数\" class=\"headerlink\" title=\"级数\"></a>级数</h1><p>一定要分清楚级数可以看作数列的前n项和，和数列极限区分开来，但是也有联系 </p>\n<h2 id=\"级数的概念\"><a href=\"#级数的概念\" class=\"headerlink\" title=\"级数的概念\"></a>级数的概念</h2><p>级数的收敛和发散</p>\n<h2 id=\"级数的性质\"><a href=\"#级数的性质\" class=\"headerlink\" title=\"级数的性质\"></a>级数的性质</h2><ul>\n<li><p>性质一：</p>\n</li>\n<li><p>性质二：</p>\n</li>\n<li><p>性质三：</p>\n</li>\n<li><p>性质四：</p>\n</li>\n</ul>\n<h2 id=\"正向级数\"><a href=\"#正向级数\" class=\"headerlink\" title=\"正向级数\"></a>正向级数</h2><h3 id=\"正向级数的收敛判别法\"><a href=\"#正向级数的收敛判别法\" class=\"headerlink\" title=\"正向级数的收敛判别法\"></a>正向级数的收敛判别法</h3><ul>\n<li>四大判别法<ul>\n<li>比较</li>\n<li>比值</li>\n<li>根植</li>\n<li>积分</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"正向级数收敛的充要条件\"><a href=\"#正向级数收敛的充要条件\" class=\"headerlink\" title=\"正向级数收敛的充要条件\"></a>正向级数收敛的充要条件</h3><p>如果一个级数数列为正向级数且收敛，那么他的前n项和有界；反之如果一个正向数列其前n项和有界，那么这个正向级数收敛。</p>\n<h3 id=\"比较判别法\"><a href=\"#比较判别法\" class=\"headerlink\" title=\"比较判别法\"></a>比较判别法</h3><ul>\n<li>大收则小收</li>\n<li>小散则大散</li>\n</ul>\n<p>极限形式：</p>\n<ul>\n<li>同阶同敛散</li>\n<li>大收则小收</li>\n<li>小散则大散</li>\n</ul>\n<p>比较对象：</p>\n<ul>\n<li>P级数</li>\n<li>等比数列</li>\n</ul>\n<h3 id=\"比值判别法（达朗贝尔【Dalembert】判别法）\"><a href=\"#比值判别法（达朗贝尔【Dalembert】判别法）\" class=\"headerlink\" title=\"比值判别法（达朗贝尔【Dalembert】判别法）\"></a>比值判别法（达朗贝尔【Dalembert】判别法）</h3><ul>\n<li>达朗贝尔判别法的证明：</li>\n</ul>\n<h3 id=\"根式判别法（Cauchy）\"><a href=\"#根式判别法（Cauchy）\" class=\"headerlink\" title=\"根式判别法（Cauchy）\"></a>根式判别法（Cauchy）</h3><h3 id=\"积分判别法（P级数、对数P级数、广义P级数）\"><a href=\"#积分判别法（P级数、对数P级数、广义P级数）\" class=\"headerlink\" title=\"积分判别法（P级数、对数P级数、广义P级数）\"></a>积分判别法（P级数、对数P级数、广义P级数）</h3>","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-16</p>\n</div></div><div class=\"timeline-item-content\"><p>高等数学级数专题</p>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"级数\"><a href=\"#级数\" class=\"headerlink\" title=\"级数\"></a>级数</h1><p>一定要分清楚级数可以看作数列的前n项和，和数列极限区分开来，但是也有联系 </p>\n<h2 id=\"级数的概念\"><a href=\"#级数的概念\" class=\"headerlink\" title=\"级数的概念\"></a>级数的概念</h2><p>级数的收敛和发散</p>\n<h2 id=\"级数的性质\"><a href=\"#级数的性质\" class=\"headerlink\" title=\"级数的性质\"></a>级数的性质</h2><ul>\n<li><p>性质一：</p>\n</li>\n<li><p>性质二：</p>\n</li>\n<li><p>性质三：</p>\n</li>\n<li><p>性质四：</p>\n</li>\n</ul>\n<h2 id=\"正向级数\"><a href=\"#正向级数\" class=\"headerlink\" title=\"正向级数\"></a>正向级数</h2><h3 id=\"正向级数的收敛判别法\"><a href=\"#正向级数的收敛判别法\" class=\"headerlink\" title=\"正向级数的收敛判别法\"></a>正向级数的收敛判别法</h3><ul>\n<li>四大判别法<ul>\n<li>比较</li>\n<li>比值</li>\n<li>根植</li>\n<li>积分</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"正向级数收敛的充要条件\"><a href=\"#正向级数收敛的充要条件\" class=\"headerlink\" title=\"正向级数收敛的充要条件\"></a>正向级数收敛的充要条件</h3><p>如果一个级数数列为正向级数且收敛，那么他的前n项和有界；反之如果一个正向数列其前n项和有界，那么这个正向级数收敛。</p>\n<h3 id=\"比较判别法\"><a href=\"#比较判别法\" class=\"headerlink\" title=\"比较判别法\"></a>比较判别法</h3><ul>\n<li>大收则小收</li>\n<li>小散则大散</li>\n</ul>\n<p>极限形式：</p>\n<ul>\n<li>同阶同敛散</li>\n<li>大收则小收</li>\n<li>小散则大散</li>\n</ul>\n<p>比较对象：</p>\n<ul>\n<li>P级数</li>\n<li>等比数列</li>\n</ul>\n<h3 id=\"比值判别法（达朗贝尔【Dalembert】判别法）\"><a href=\"#比值判别法（达朗贝尔【Dalembert】判别法）\" class=\"headerlink\" title=\"比值判别法（达朗贝尔【Dalembert】判别法）\"></a>比值判别法（达朗贝尔【Dalembert】判别法）</h3><ul>\n<li>达朗贝尔判别法的证明：</li>\n</ul>\n<h3 id=\"根式判别法（Cauchy）\"><a href=\"#根式判别法（Cauchy）\" class=\"headerlink\" title=\"根式判别法（Cauchy）\"></a>根式判别法（Cauchy）</h3><h3 id=\"积分判别法（P级数、对数P级数、广义P级数）\"><a href=\"#积分判别法（P级数、对数P级数、广义P级数）\" class=\"headerlink\" title=\"积分判别法（P级数、对数P级数、广义P级数）\"></a>积分判别法（P级数、对数P级数、广义P级数）</h3>"},{"title":"考研数学（高数部分，第一章）复习","copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-02T02:56:06.000Z","updated":"2023-04-10T16:00:00.000Z","mathjax":true,"keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg","_content":"\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-02 -->\n整理姜晓千数学第一讲 函数的极限连续\n<!-- endtimeline -->\n\n<!-- timeline 04-09 -->\n整理姜晓千数学第一讲 \n\n- 无穷大、无穷小\n- 洛必达法则\n- 等价代换\n- Taylor公式\n- 复习之前的概念\n\n<!-- endtimeline -->\n\n<!-- timeline 04-10 -->\n继续昨天的任务\n\n- 完善了几个常见的函数的taylor展开\n- 复习了求解函数极限中的七类未定式\n\n<!-- endtimeline -->\n\n<!-- timeline 04-11 -->\n\n- 数列极限的求解方法\n  - 单调有界定理\n  - 夹逼准则\n  - 定积分定义\n- 连续和间断\n- 导数\n  - 导数的定义\n  - 导数的性质\n\n<!-- endtimeline -->\n\n<!-- timeline 04-17 -->\n\n增添了几道例题。\n\n- [x] 刷660 前45题\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n[toc]\n\n\n\n# 函数极限连续\n\n微积分之前先==化简==\n\n- 拆、提、同除、同乘\n- 对数公式\n- 三角公式\n\n## 1.1函数\n\n- 重要内容：\n\n单调性\n\n有界性\n\n奇偶性  第三章积分  \n\n周期性  第三章积分\n\n### 极限 （大题、小题都有）\n\n八个方法：\n\n- 求解函数极限\n  - 洛必达 （简单函数适合洛必达）【简单函数：容易求导，越求导越简单的】\n  - ==导数定义== （牛顿最先提出 一阶 二阶  第二章会讲到）\n  - 等价代换 （3组）\n  - taylor公式 （8个常见的）\n  - 拉格朗日  （第二章内容  ）\n- 数列极限\n  - 单调有界\n  - 夹逼准则\n  - 定积分定义 （第三章 黎曼定积分定义）\n\n### 数列极限的概念\n\n数列极限的定义：'$ \\lim_{ n \\to \\infty} a_{n} = a  $'  Cauthy提出的 数列极限的定义。\n$$\n对于 \\forall \\epsilon \\gt 0 \\ \\   \\exists N \\gt 0 \\ \\ \\ 当 n \\gt N \\ 时 \\ |a_{n}-a| \\lt \\epsilon\n$$\n数列机芯啊描述了这个数列在趋向于无穷的时候函数的逼近值。\n\n> tips: \n>\n> 在柯西的定义中$$|a_{n}-a| \\le \\epsilon$$ 也是可以的。\n>\n> 同理：以下变形也是可以的：\n>\n> - $$|a_{n}-a| \\le 10\\epsilon$$\n> - $$|a_{n}-a| \\le \\frac{1}{10}\\epsilon$$\n>\n> 总结：只要在定义中保证数列的无穷处和目标值a要多近有多近就可以。\n\n### 数列极限的充要条件\n\n$$\n在Cauthy对数列极限的定义中 \\\\\n....(极限定义)... \\iff对于\\forall a_n 中的任意子列 b_n \\ \\ \\lim_{n\\rightarrow \\infty} b_n = a\n$$\n\n注意！要是后推前必须要说明所有的子列的极限都是相等的才能推导出 Cauthy极限的定义。\n\n（所有）子列极限都相等\n\n### 数列极限的性质\n\n- 唯一性：\n- 全局有界性：数列有极限必定有界，但是数列有界不一定有极限[^3]\n\n$$\n若数a_n的极限是a \\ 那么 必定\\forall \\epsilon \\gt 0 \\ \\   \\exists N \\gt 0 \\ \\ \\ 当 n \\gt N \\ 时 \\ |a_{n}-a| \\lt \\epsilon \\\\\n也是就是说在n大于一个比较大的数字之后 a_n 的所有的值都会在一个很小的范围内，而且N之前的取值也都是有界的，所以数列整体有界\n$$\n\n\n\n- 局部保号性  (极限不能等于0)；\n\n$$\n假设\\lim_{n \\to \\infty} a_n = a \\gt 0 \\ \\ \\  则 \\exists N 当n \\gt N \\ \\  时 a_n \\gt 0\n$$\n\n\n\n### 函数极限的概念\n\n函数极限的定义：两个大定义 和六个小定义 (x-x0不能等于0  因为函数可能在x0没有定义)\n$$\n当x\\to x_0时 \\\\\n(1) \\lim_{x \\to x_0} f(x) = A :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ 0\\lt |x-x_0| \\lt \\delta \\ 时  \\ \\ |f(x)-A| \\lt \\epsilon \\\\\n(2)\\lim_{x \\to x_0^+} f(x) = A  :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ 0\\lt x-x_0 \\lt \\delta \\ 时 \\ \\ \t|f(x)-A| \\lt \\epsilon \\\\\n(3) \\lim_{x \\to x_0^-} f(x) = A :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ -\\delta \\lt x-x_0 \\lt 0 \\ 时 \\ \\ |f(x)-A| \\lt \\epsilon\n$$\n上述的三个变形代表了不同的趋近情况 2、3分别时左趋近和右趋近时候的定义\n$$\n当x \\to \\infty时 \\\\\n(1)\\lim_{x \\to \\infty} f(x) = A  :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ |x| \\gt X \\ 时 \\ \\ \t|f(x)-A| \\lt \\epsilon \\\\\n(2)\\lim_{x \\to +\\infty} f(x) = A  : \\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ x \\gt X \\ 时 \\ \\ \t|f(x)-A| \\lt \\epsilon \\\\\n(3)\\lim_{x \\to -\\infty} f(x) = A  : \\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ x \\lt -X \\ 时 \\ \\ \t|f(x)-A| \\lt \\epsilon\n$$\n\n### 函数极限的充要条件 （感觉有点没有用）\n\n描述：函数的极限存在那么左趋近和右趋近都要相等\n\n函数的趋近无穷极限存在那么同理趋近正无穷和负无穷也都要相等\n$$\n\\lim_{x \\to x_0} f(x) = A \\ \\iff \\ \\lim_{x \\to x_0^+} f(x) = \\lim_{x \\to x_0^-}f(x) = A  \\\\\n\\lim_{x \\to \\infty} f(x) = A \\ \\iff \\ \\lim_{x \\to +\\infty} f(x) = \\lim_{x \\to -\\infty}f(x) = A\n$$\n\n\n### 函数极限的性质\n\n若函数存在极限则有如下的性质。\n\n- 唯一性  和数列极限的唯一性相似\n- 局部有界性\n\n$$\n设\\lim_{x \\to x_0} f(x) 存在，则 \\ \\ \\exists \\delta \\gt 0 \\ \\ \\exists M \\gt 0 \\ \\  使得当 \\ \\ 0 \\lt |x-x_0| \\lt \\delta \\ (局部) 时 \\ \\  |f(x)| \\le M \\ \\ (有界)\n$$\n\n> tips:\n>\n> 对于上述的有点不同的六个定义，局部有界性应该是修改相应的限制局部的区间。\n\n- 局部保号性  极限不能等于0\n- 推论\n\n$$\n设f(x) \\ge 0 \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge 0 \\\\\n设f(x) \\gt 0 \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge 0\n$$\n\n这个推论：极限和函数的上界\\下界之间的关系\n$$\n若f(x) \\ge k \\ \\ 是否有 \\lim_{x \\to x_0} f(x) =  A \\ge k \\ \\ ? \\ \\ (成立！) \\\\\n若f(x) \\ge k \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge k \\\\\n若f(x) \\gt k \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge k \n$$\n\n\n### 函数极限的四则运算\n\n$$\n\\lim_{x \\to [..]} f(x) = A \\ \\ \\ \\lim_{x \\to [..]} f(x) = B \\\\\nsum:\\lim_{x \\to [..]} [f(x)\\pm g(x)] = A\\pm B   \\\\\nmulti: \\lim_{x \\to [..]} f(x) \\times g(x) = A\\times B \\\\\ndiv: \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\frac{A}{B}\n$$\n\n推论：（提出非0因子）\n$$\n假设 \\lim_{x \\to [..]} f(x) = A \\neq 0, \\ \\ 则 \\lim_{x \\to [..]} f(x)g(x) = A\\lim_{x \\to [..]} g(x)\n$$\n注意 ：\n\nA一定是一个非0因子！每个极限都要存在，分母极限不为0。\n\n## 1.2无穷小和无穷大\n\n### 无穷小的定义\n\n极限为0 的函数\n$$\n\\lim_{x \\to [..]} f(x) = 0 \\ \\ 则称f(x)为x \\to [..] 时的无穷小。 \n$$\n\n\n### 无穷小的性质\n\n1. 有限个无穷小的和还是无穷小\n2. 有限个无穷小的积还是无穷小\n3. 无穷小乘有界量为无穷小\n\n### 无穷小阶的比较（缺少比较的方法论）\n\n- 怎么判断两个无穷小谁是谁的高阶无穷小\n  $$\n  if \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = 0 \\\\\n  则 f 为 g的高阶无穷小  \\ \\ 记为 f = o(g(x))\n  $$\n  \n- .....同阶无穷小\n  $$\n  if \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = C  \\ \\ \\ (c \\neq 0) \\\\\n  则 f 为 g的同阶无穷小\n  $$\n  \n- .....等价无穷小\n  $$\n  if \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = 1  \\\\\n  则 f 为 g的等价无穷小\n  $$\n  \n- .....k阶无穷小\n  $$\n  if \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)^k} = C  \\ \\ \\ (c \\neq 0) \\\\\n  则 f 为 g的k阶无穷小\n  $$\n  \n\n### 高阶无穷小的(运算)性质\n\n- 性质一：和式性质，无穷小的和的阶数等于和式中最小的阶，低阶吸收高阶。\n\n$$\no(x^m)\\pm o(x^n) = o(x^l) \\ \\ l = min(m,n);\n$$\n\n\n\n- 性质二：乘系数性质\n\n$$\nk \\ o(x^m) = o(x^m) \\ \\\n$$\n\n- 性质三：乘法性质\n  $$\n  o(x^m)\\times x^n = o(x^n)\\times x^m = o(x^n)\\times o(x^m)  = o(x^{m+n})\n  $$\n  \n- 性质四：除法性质\n  $$\n  \\frac{o(x^m)}{x^n} = o(x^{m-n}) \\ \\ (m \\gt n) \\\\\n  \\frac{x^m}{o(x^n)} = o(x^{m-n}) \\ \\ (m \\gt n) \\ \\ (不成立)\\\\\n  \\frac{o(x^m)}{o(x^n)} = o(x^{m-n}) \\ \\ (m \\gt n) \\ \\ (不成立)\\\\\n  上述两个式子都不成立，符号代表着其实是一种范围式的记法，\\\\ \n  如果出现在分母，那么必定能找到一个一个分母阶数大于分子阶数的项那么最后整个式子的结果就不确定。\n  $$\n  \n  \n  \n\n### 无穷小相关的题目\n\n给定两个无穷小的比值计算其中一个函数的极限\n\n千万不能想Taylor，题目中没有说明这个函数的可导性，Taylor需要知道该函数在该点n+1阶可导\n\n{% tabs 给定两个无穷小的比值计算其中一个函数的极限 %}\n<!-- tab -->\n$$\n\\lim _{x \\rightarrow 0} \\frac{\\ln \\left(1+x+\\frac{f(x)}{x}\\right)}{x}=3 \\text {, 则 } \\lim _{x \\rightarrow 0} \\frac{f(x)}{x^2}=\n$$\n<!-- endtab -->\n\n<!-- tab -->\n$$\n\\text { 设 } \\lim _{x \\rightarrow 0} \\frac{\\ln (1-x)+x f(x)}{x^2}=0 \\text {, 则 } \\lim _{x \\rightarrow 0} \\frac{f(x)-1}{x}=\n$$\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n\n\n\n### 无穷大的定义\n\n- 定义一：趋近一个确定的点的无穷大概念定义\n  $$\n  \\lim_{x \\to x_0} f(x) = \\infty \\\\\n  \\forall M \\gt 0 , \\ \\ \\exists \\delta \\gt 0, \\ \\ 使得0\\lt |x-x_0| \\lt \\delta \\ \\ \\  |f(x)| \\gt M\n  $$\n  \n- 定义二：趋近于无穷时候的无穷大\n  $$\n  \\lim_{x \\to \\infty} f(x) = \\infty \\\\\n  \\forall M \\gt 0 , \\ \\ \\exists X \\gt 0, \\ \\ 使得 |x| \\gt X \\ \\ \\  |f(x)| \\gt M\n  $$\n  \n\n### 无穷大的性质\n\n1. 无穷大的倒数是无穷小、==非0无穷小的倒数（该函数不能区到0）【个人感觉有点不太严谨 或者我听错了，之后再看看】==\n\n2. 无穷大一定是无界量  但是 无界量不一定是无穷大 。\n   $$\n   无穷大的概念是一个连续的概念，根据定义必定存在一个区间，在这个区间内的任意取值都可以要多大有多大 \\\\\n   无界量只要有一个点满足无穷条件就可以满足其定义 \\\\\n   f(x) = \n   \\begin{cases}\n   \\infty , \\ \\ \\ x = x_0 \\\\\n   0, \\ \\ \\ x \\neq x_0 \\\\\n   \\end{cases} \\\\\n   或者如下例子 \\\\\n   f(x) = x\\sin(x) \\ \\ \\\\\n   x = 2n\\pi + \\frac{\\pi}{2} \\\\\n   x = 2n\\pi\n   $$\n   \n\n### 无穷大阶的比较 （缺少比较的方法论）\n\n这个部分需要先去硬性记忆一下。\n\n- 函数无穷大\n\n$$\n常见函数的无穷大比较 x \\to +\\infty \\\\ \n\\ln(x)^{\\alpha} \\ll x^{\\beta} \\ll a^x \\ll x^x\n$$\n\n- 数列无穷大\n  $$\n  常见数列的无穷大比较 n\\to \\infty \\\\\n  \\ln(n)^{\\alpha} \\ll n^{\\beta} \\ll a^n \\ll n! \\ll x^x\n  $$\n  \n\n## 1.3洛必达法则（方法论、解题方法）\n\n### 洛必达法则的条件\n\n满足这三个条件说明可以洛必达，但是如果洛必达求不出来那也不能说明函数极限不存在。\n\n- 一\n  $$\n  \\lim_{x \\to [..]} [\\frac{f(x)}{g(x)}] \\ \\ 为 \\frac{0}{0} \\ \\ or \\ \\ \\frac{\\infty}{\\infty} \\ 类型的\n  $$\n\n- 二\n  $$\n  f(x) \\ \\  and \\ \\ g(x) \\ \\ 可导 \\ \\ \\ (涉及到可导性判断)\n  $$\n\n- 三\n  $$\n  \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\lim_{x \\to [..]} \\frac{f'(x)}{g'(x)} = 0 \\ \\ or \\ \\ \\infty 时才能说明原极限为0 或者\\infty; 如果不存在则不能说明原极限不存在。\n  $$\n\n则\n$$\n\\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\lim_{x \\to [..]} \\frac{f'(x)}{g'(x)} = \\lim_{x \\to [..]} \\frac{f''(x)}{g''(x)} = .......\n$$\n经典错误：\n\n\n$$\n\\lim_{x \\to \\infty} \\frac{x+\\sin(x)}{x} \\ \\ \n$$\n\n\n结论：洛必达求出来极限不存在不能说明当前极限不存在，得用其他方法求。\n\n## 1.4等价代换\n\n等价代换的实质是泰勒公式，是一个函数在0点的无穷次展开。\n\n- X 趋近 0 的时候\n\n$$\nx \\to 0 \\\\\n(1) \\ \\ \\ x \\sim \\sin(x) \\sim \\tan(x) \\sim \\arcsin(x) \\sim \\arctan(x) \\sim e^x-1 \\sim \\ln(x+1) \\\\\n(2)\\begin{cases}\n(1+x)^\\alpha -1 \\sim \\alpha x \\\\\n\\alpha ^x -1 \\sim x\\ln\\alpha\n\\end{cases} \\\\\n(3)\\begin{cases}\nx-\\sin(x) \\sim \\arcsin(x)-x \\sim \\frac{x^3}{6} \\\\\n\\tan(x)-x \\sim x-\\arctan(x) \\sim \\frac{x^3}{3} \\\\\n\\tan(x)-\\sin(x) \\sim \\arctan(x) - \\arcsin(x) \\sim \\frac{x^3}{2} \\\\\n\\end{cases}\n$$\n\n- 等价代换求极限 注意点：\n  - 乘除可以代换\n  - 加减不能随意代换，最简形式不抵消的时候可以代换 （个人建议直接使用taylor公式）\n\n推广：\n$$\nx \\to 0 \\ \\ 可以推广为 \\ \\ [..] \\to 0 \\\\\n例如：\\ln(1+[..]) \\sim [..] \\ \\ 当 \\ \\ [..] \\to 0 时\n$$\n\n\n\n\n\n## 1.5 Taylor公式\n\n### Taylor公式定义\n\n$$\nf(x) 在 x = x_0 的某一个邻域内 n+1 阶可导则有如下 \\\\\nf(x) = f(x_0) + f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + \\frac{1}{3!}f'''(x_0)(x-x_0)^3 + .....+ \\frac{1}{n!}f^{n}(x_0)(x-x_0)^n + \n\\begin{cases}\n\\frac{1}{(n+1)!}f^{n+1}(\\zeta)(x-x_0)^{n+1}  \\ \\ \\ largrange 余项 \\\\\no(x-x_0)^n \\ \\ \\ Peano余项\n\\end{cases}\n$$\n\n第n+1阶导数是一个余项形式\n\n### Maclaurin （麦克劳林）公式\n\n$$\nTaylor公式中当x_0 = 0时的取值。\\\\\nf(x) = f(0) + f'(0)(x-0) + \\frac{1}{2!}f''(0)(x-0)^2 + \\frac{1}{3!}f'''(0)(x-0)^3 + .....+ \\frac{1}{n!}f^{n}(0)(x-0)^n\n$$\n\n### 常见函数的一阶导数\n\n\n$$\n\\begin{align} \n&(1)   (C)^{\\prime}=0, \\\\\n&(2)   (x^\\mu)^{\\prime}=\\mu x^{\\mu-1}, \\\\\n&(3)   (\\sin x)^{\\prime}=\\cos x, \\\\\n&(4)   (\\cos x)^{\\prime}=-\\sin x, \\\\\n&(5)   (\\tan x)^{\\prime}=\\sec ^2 x, \\\\\n&(6)   (\\cot x)^{\\prime}=-\\csc ^2 x, \\\\\n&(7)   (\\sec x)^{\\prime}=\\sec x \\tan x, \\\\\n&(8)   (\\csc x)^{\\prime}=-\\csc x \\cot x, \\\\\n&(9)   (a^x)^{\\prime}=a^x \\ln a \\quad(a>0, a \\neq 1), \\\\\n&(10)  (\\mathrm{e}^x)^{\\prime}=\\mathrm{e}^x, \\\\ \n&(11)  (\\log _a )^{\\prime}=\\frac{1}{x \\ln a}(a>0, a \\neq 1), \\\\\n&(12)  (\\ln x)^{\\prime}=\\frac{1}{x}, \\\\\n&(13)  (\\arcsin x)^{\\prime}=\\frac{1}{\\sqrt{1-x^2}}, \\\\\n&(14)  (\\arccos x)^{\\prime}=-\\frac{1}{\\sqrt{1-x^2}}, \\\\\n&(15)  (\\arctan x)^{\\prime}=\\frac{1}{1+x^2}, \\\\\n&(16)  (\\operatorname{arccot} x)^{\\prime}=-\\frac{1}{1+x^2} \\\\\n\\end{align}\n$$\n\n\n\n### 常见函数的Taylor公式[^1]\n\n$$\n\\begin{align}\n& \\mathrm{e}^{\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{1}{\\mathrm{n} !} \\mathrm{x}^{\\mathrm{n}}=1+\\mathrm{x}+\\frac{1}{2 !} \\mathrm{x}^2+\\cdots \\in(-\\infty,+\\infty) \\\\\n& \\sin \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{(2 \\mathrm{n}+1) !} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}-\\frac{1}{3 !} \\mathrm{x}^3+\\frac{1}{5 !} \\mathrm{x}^5+\\cdots, \\mathrm{x} \\in(-\\infty,+\\infty) \\\\\n& \\alpha^{x}  = \\sum_{n = 0}^{\\infty}\\frac{(\\ln\\alpha)^n}{n!}x^n = 1+\\ln\\alpha x +\\frac{(\\ln\\alpha)^2}{2!}x^2+\\frac{(\\ln\\alpha)^3}{3!} + \\cdots\\\\\n& \\arcsin \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(2 \\mathrm{n}) !}{4^{\\mathrm{n}}(\\mathrm{n} !)^2(2 \\mathrm{n}+1)} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}+\\frac{1}{6} \\mathrm{x}^3+\\frac{3}{40} \\mathrm{x}^5+\\frac{5}{112} \\mathrm{x}^7+\\frac{35}{1152} \\mathrm{x}^9+\\cdots+, \\mathrm{x} \\in(-1,1) \\\\\n& \\cos \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{(2 \\mathrm{n}) !} \\mathrm{x}^{2 \\mathrm{n}}=1-\\frac{1}{2 !} \\mathrm{x}^2+\\frac{1}{4 !} \\mathrm{x}^4+\\cdots, \\mathrm{x} \\in(-\\infty,+\\infty) \\\\\n& 注意：\\arcsin+\\arccos = \\frac{\\pi}{2} : \\\\\n& \\arccos \\mathrm{x} =  \\frac{\\pi}{2} - (\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(2 \\mathrm{n}) !}{4^{\\mathrm{n}}(\\mathrm{n} !)^2(2 \\mathrm{n}+1)} \\mathrm{x}^{2 \\mathrm{n}+1}) =  \\frac{\\pi}{2} - ( \\mathrm{x}+\\frac{1}{6} \\mathrm{x}^3+\\frac{3}{40} \\mathrm{x}^5+\\frac{5}{112} \\mathrm{x}^7+\\frac{35}{1152} \\mathrm{x}^9+\\cdots+ ) \\\\\n& \\ln (1+x)=\\sum_{n=0}^{\\infty} \\frac{(-1)^n}{n+1} x^{n+1}=x-\\frac{1}{2} x^2+\\frac{1}{3} x^3+\\cdots, x \\in(-1,1] \\\\\n& \\frac{1}{1-\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty} \\mathrm{x}^{\\mathrm{n}}=1+\\mathrm{x}+\\mathrm{x}^2+\\mathrm{x}^3+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& \\frac{1}{1+\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty}(-1)^{\\mathrm{n}} \\mathrm{x}^{\\mathrm{n}}=1-\\mathrm{x}+\\mathrm{x}^2-\\mathrm{x}^3+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& (1+\\mathrm{x})^\\alpha=1+\\sum_{\\mathrm{n}=1}^{\\infty} \\frac{\\alpha(\\alpha-1) \\cdots(\\alpha-\\mathrm{n}+1)}{\\mathrm{n} !} \\mathrm{x}^{\\mathrm{n}}=1+\\alpha \\mathrm{x}+\\frac{\\alpha(\\alpha-1)}{2 !} \\mathrm{x}^2+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& \\arctan \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{2 \\mathrm{n}+1} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}-\\frac{1}{3} \\mathrm{x}^3+\\frac{1}{5} \\mathrm{x}^5+\\cdots+\\mathrm{x} \\in[-1,1] \\\\\n\n& \\tan \\mathrm{x}=\\sum_{\\mathrm{n}=1}^{\\infty} \\frac{\\mathrm{B}_{2 \\mathrm{n}}(-4)^{\\mathrm{n}}\\left(1-4^{\\mathrm{n}}\\right)}{(2 \\mathrm{n}) !} \\mathrm{x}^{2 \\mathrm{n}-1}=\\mathrm{x}+\\frac{1}{3} \\mathrm{x}^3+\\frac{2}{15} \\mathrm{x}^5+\\frac{17}{315} \\mathrm{x}^7+\\frac{62}{2835} \\mathrm{x}^9+\\frac{1382}{155925} \\mathrm{x}^{11}+\\frac{21844}{6081075} \\mathrm{x}^{13}+... \\mathrm{x} \\in(-\\frac{\\pi}{2},\\frac{\\pi}{2}) \\\\\n&\n\\end{align}\n$$\n\n推广：这里的taylor公式也可以推广为【..】=> 0；类似复合函数的形式,注意函数极限中的两个式子的加减是否产生了抵消。\n\n## 1.6 七类未定式\n\n$$\n七类未定式：\n\\ \\ \\ \\frac{0}{0} \n\\ \\ \\ \\frac{\\infty}{\\infty} \n\\ \\ \\ 0\\times\\infty\n\\ \\ \\ \\infty - \\infty \n\\ \\ \\ 0^{\\infty}\n\\ \\ \\ \\infty^{0}\n\\ \\ \\ 1^{\\infty}\n$$\n\n\n\n- $$\\infty^{0}$$\n\n{% tabs 无穷的0次方例题 %}\n<!-- tab -->\n$$\nI = \\lim_{x \\to \\infty}(e^{x^2}+x^3)^{\\frac{1}{x^2}}\\\\\n(1) \\ \\ I = \\lim_{x \\to \\infty} e^{\\frac{\\ln{(e^{x^2}+x^3})}{x^2}} \\Rightarrow 对于指数 \\frac{\\ln{(e^{x^2}+x^3)}}{x^2} 使用洛必达 \\\\\n(2) 观察到外层的指数和里面的某一项有可以相消的指数：化简\\Rightarrow \\lim_{x\\to \\infty} [e^{x^2}(1+\\frac{x^3}{e^{x^2}})]^{\\frac{1}{x^2}}\n$$\n将函数指数化、对数化，将其变为一个$$\\frac{\\infty}{\\infty}$$类型，然后研究指数，使用洛必达解出\n\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 2.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n\n### Lagrange方法\n\n$$\nf(a)-f(b) = f'(\\xi)(a-b)\n$$\n\n 拉格朗日求函数极限的方法一定要注意 构造的函数的两个区间一定 \n\n### 对数函数公式\n\n$$\n\\begin{cases}\n&恒等变形 \\ \\ \\ f(x) = e^{\\ln f(x)} = \\ln {e^{f(x)}} \\\\\n& 加法公式 \\ \\ \\ \\ln{a} + \\ln{b} = \\ln{ab} \\\\\n& 减法公式 \\ \\ \\ \\ln{a} - \\ln{b} = \\ln{\\frac{a}{b}} \\\\\n&换底公式 \\ \\ \\ \\log_a b = \\frac{\\ln{b}}{\\ln{a}} \\\\\n\\end{cases}\n$$\n\n\n\n### 三角函数公式[^2]\n\n#### 和差化积公式记忆口诀\n\n正加正，正在前，余减余，余并肩，正减正，余在前，余减余，负正弦。\n\n\n\n\n\n### 解决七类未定式的方法论：\n\n- 三种：等价、洛必达、泰勒\n\n- 三种：洛必达、同除最高次幂项（注意符号的问题）、抓大头\n\n-  两种：将其化为第一种或者第二种方法 来做\n\n- 三种：通分、有理化、倒代换\n\n- 第五和第六中未定式：使用对数的公式化简\n\n  > tips (注意): $ \\lim_{x\\to 0^+} x^{\\alpha} \\ln^{\\beta}{x} = 0, \\ \\ \\alpha,\\beta \\in(0,\\infty) $\n\n## 1.7 数列极限 （单调有界定理）\n\n### 重要不等式\n\n$$\n\\begin{align}\n& (1) \\sin(x) \\lt x \\lt \\tan(x) , x \\in(0,\\frac{\\pi}{2})   \\\\\n& (2) e^x \\lt 1+x, x \\neq 0 \\\\\n& (3) \\frac{x}{1+x} \\lt \\ln(1+x) \\lt x , x \\neq 0 \\ \\ and \\ \\ x \\in(-1,\\infty) \\\\\n\\end{align}\n$$\n\n### 单调有界定理的步骤\n\n- 放缩确定界（证明有界）\n\n- 证明单调\n  $$\n  \\begin{align}\n  & (1) 做差 \\ \\ x_{n+1}-x_{n}   \\\\\n  & (2) 做商 \\ \\ \\frac{x_{n+1}}{x_n} \\\\\n  & (3) 求解函数的单调性 \\ \\ y = f(x)\n  \\begin{cases}\n  f'(x) \\gt 0 \n  \\begin{cases}\n  x_1 \\gt x_2 \\rightarrow \\ x_2 = f(x_1)>f(x_2) = x_3,即 x_2 \\gt x_3 以此类推,x_{n-1} \\gt x_{n} \\\\\n  x_1 \\lt x_2 \\rightarrow \\ x_2 = f(x_1) \\lt f(x_2) = x_3,...., x_{n-1} \\lt x_{n}\n  \\end{cases} \\\\\n  f'(x) \\lt 0 \\ \\ 使用夹逼准则\n  \\end{cases}\n  \\\\\n  \\end{align}\n  $$\n\n- 两边做极限解方程求解最后的极限值\n\n  \n\n## 1.8 数列极限（夹逼准则）\n\n难点在于如何构造夹逼的两个函数。\n$$\nx_n \\le y_n \\le z_n \\  and \\ \\lim_{n \\to \\infty} x_n = \\lim_{n \\to \\infty} y_n = A \\rightarrow \\lim_{n \\to \\infty} y_n = A\n$$\n\n\n## 1.9 定积分定义 （这个比较简单）\n\n夹逼准则和定积分定义有时候会搞混。\n\n## 2.1 连续\n\n### 连续的定义\n\n连续、右连续、左连续\n$$\n\\begin{align}\n& (1) 连续 \\ \\ \\ \\lim_{x \\to x_0} f(x) = f(x_0) \\\\\n& (2) 右连续 \\ \\ \\ \\lim_{x \\to x_0^+} f(x) = f(x_0)  \\\\\n& (3) 左连续 \\ \\ \\ \\lim_{x \\to x_0^-} f(x) = f(x_0)  \\\\\n\\end{align}\n$$\n\n\n### 连续函数的性质\n\n基本初等函数：反、对、幂、指、三（反三角函数、对数函数、幂函数、指数函数、三角函数）\n\n初等函数：基本初等函数经过有限次四则运算或者复合 得到的函数\n$$\n\\begin{align}\n& (1) 基本初等函数在其定义域内都连续\\\\\n& (2) 连续函数经过有限次的四则运算以及复合任然是连续的 \\\\\n& (3) 初等函数都是连续函数\\\\\n\\end{align}\n$$\n\n\n### 闭区间连续函数的性质（定理，一定是闭区间的、连续的）\n\n$$\n\\begin{align}\n& (1) 最值定理: 闭区间连续函数一定存在最大值M 最小值m，即 m \\le f(x) \\le M  \\\\\n& (1.1) 最值定理推论：有界定理【闭区间连续函数必定有界】\\\\\n& (2) 介值定理: 若f(x) ， x \\in[a,b] 则一定有 \\exists \\xi \\in [a,b], 使得 f(\\xi) = \\frac{f(a)+f(b)}{2} \\\\\n& (2.1) 介值定理推论: \\ \\forall x_1,x_2,x_3 \\dots x_n \\in[a,b] ,则有\\exists \\xi \\in[a,b] \\ \\ f(\\xi) = \\frac{f(x_1)+f(x_2)+\\dots +f(x_n)}{n}   \\\\\n& (3) 零点定理: 若 f(a)f(b) \\lt 0, 则\\exists \\xi \\in(a,b), f(\\xi) = 0 \\\\\n\\end{align}\n$$\n\n\n\n{% tabs 例题 %}\n<!-- tab -->\n$$\n例：设 f(x) 在x \\in[a,b]上连续 and\\ \\ f(1) = f(0) \\ \\ \\ 证明: \\exists \\xi 使得 f(\\xi+\\frac{1}{4}) = f(\\xi)\n$$\n\n\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 2.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n\n## 2.2 间断点\n\n### 间断点的定义\n\n$$\nf(x)在某个（存在这样的去心邻域即可）\\mathring{U}(x_0)有定义,并且f(x)在x_0处不连续（连续的定义见上文）。\n$$\n\n### 间断点的分类\n\n- 左右极限均存在的\n  - 可去间断点，左极限=右极限，但是不等于点处的值。（或者该点处没有定义）\n  - 跳跃间断点\n- 左右极限至少有一个不存在的\n  - 无穷间断点\n  - 振荡间断点\n\n# reference\n\n[^1]:  [Taylor多项式/Taylor公式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/348178130) ↩[(10条消息) 常见函数泰勒公式展开（清晰）_常见的泰勒展开公式大全_陌雨’的博客-CSDN博客](https://blog.csdn.net/Infinity_07/article/details/113830088)\n[^2]: [考研数学的初等函数变换公式——三角相关 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/89073536)\n[^3]: [(18 封私信 / 4 条消息) 有极限的数列是有界的怎么理解? - 知乎 (zhihu.com)](https://www.zhihu.com/question/26383384)\n","source":"_posts/考研数学（高数部分，第一章）复习.md","raw":"---\ntitle: 考研数学（高数部分，第一章）复习\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-02 10:56:06\nupdated: 2023-04-11 \nmathjax: true\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/99945894_p0_master1200.jpg\n---\n\n\n\n{% timeline 2023,blue %}\n<!-- timeline 04-02 -->\n整理姜晓千数学第一讲 函数的极限连续\n<!-- endtimeline -->\n\n<!-- timeline 04-09 -->\n整理姜晓千数学第一讲 \n\n- 无穷大、无穷小\n- 洛必达法则\n- 等价代换\n- Taylor公式\n- 复习之前的概念\n\n<!-- endtimeline -->\n\n<!-- timeline 04-10 -->\n继续昨天的任务\n\n- 完善了几个常见的函数的taylor展开\n- 复习了求解函数极限中的七类未定式\n\n<!-- endtimeline -->\n\n<!-- timeline 04-11 -->\n\n- 数列极限的求解方法\n  - 单调有界定理\n  - 夹逼准则\n  - 定积分定义\n- 连续和间断\n- 导数\n  - 导数的定义\n  - 导数的性质\n\n<!-- endtimeline -->\n\n<!-- timeline 04-17 -->\n\n增添了几道例题。\n\n- [x] 刷660 前45题\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n[toc]\n\n\n\n# 函数极限连续\n\n微积分之前先==化简==\n\n- 拆、提、同除、同乘\n- 对数公式\n- 三角公式\n\n## 1.1函数\n\n- 重要内容：\n\n单调性\n\n有界性\n\n奇偶性  第三章积分  \n\n周期性  第三章积分\n\n### 极限 （大题、小题都有）\n\n八个方法：\n\n- 求解函数极限\n  - 洛必达 （简单函数适合洛必达）【简单函数：容易求导，越求导越简单的】\n  - ==导数定义== （牛顿最先提出 一阶 二阶  第二章会讲到）\n  - 等价代换 （3组）\n  - taylor公式 （8个常见的）\n  - 拉格朗日  （第二章内容  ）\n- 数列极限\n  - 单调有界\n  - 夹逼准则\n  - 定积分定义 （第三章 黎曼定积分定义）\n\n### 数列极限的概念\n\n数列极限的定义：'$ \\lim_{ n \\to \\infty} a_{n} = a  $'  Cauthy提出的 数列极限的定义。\n$$\n对于 \\forall \\epsilon \\gt 0 \\ \\   \\exists N \\gt 0 \\ \\ \\ 当 n \\gt N \\ 时 \\ |a_{n}-a| \\lt \\epsilon\n$$\n数列机芯啊描述了这个数列在趋向于无穷的时候函数的逼近值。\n\n> tips: \n>\n> 在柯西的定义中$$|a_{n}-a| \\le \\epsilon$$ 也是可以的。\n>\n> 同理：以下变形也是可以的：\n>\n> - $$|a_{n}-a| \\le 10\\epsilon$$\n> - $$|a_{n}-a| \\le \\frac{1}{10}\\epsilon$$\n>\n> 总结：只要在定义中保证数列的无穷处和目标值a要多近有多近就可以。\n\n### 数列极限的充要条件\n\n$$\n在Cauthy对数列极限的定义中 \\\\\n....(极限定义)... \\iff对于\\forall a_n 中的任意子列 b_n \\ \\ \\lim_{n\\rightarrow \\infty} b_n = a\n$$\n\n注意！要是后推前必须要说明所有的子列的极限都是相等的才能推导出 Cauthy极限的定义。\n\n（所有）子列极限都相等\n\n### 数列极限的性质\n\n- 唯一性：\n- 全局有界性：数列有极限必定有界，但是数列有界不一定有极限[^3]\n\n$$\n若数a_n的极限是a \\ 那么 必定\\forall \\epsilon \\gt 0 \\ \\   \\exists N \\gt 0 \\ \\ \\ 当 n \\gt N \\ 时 \\ |a_{n}-a| \\lt \\epsilon \\\\\n也是就是说在n大于一个比较大的数字之后 a_n 的所有的值都会在一个很小的范围内，而且N之前的取值也都是有界的，所以数列整体有界\n$$\n\n\n\n- 局部保号性  (极限不能等于0)；\n\n$$\n假设\\lim_{n \\to \\infty} a_n = a \\gt 0 \\ \\ \\  则 \\exists N 当n \\gt N \\ \\  时 a_n \\gt 0\n$$\n\n\n\n### 函数极限的概念\n\n函数极限的定义：两个大定义 和六个小定义 (x-x0不能等于0  因为函数可能在x0没有定义)\n$$\n当x\\to x_0时 \\\\\n(1) \\lim_{x \\to x_0} f(x) = A :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ 0\\lt |x-x_0| \\lt \\delta \\ 时  \\ \\ |f(x)-A| \\lt \\epsilon \\\\\n(2)\\lim_{x \\to x_0^+} f(x) = A  :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ 0\\lt x-x_0 \\lt \\delta \\ 时 \\ \\ \t|f(x)-A| \\lt \\epsilon \\\\\n(3) \\lim_{x \\to x_0^-} f(x) = A :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ -\\delta \\lt x-x_0 \\lt 0 \\ 时 \\ \\ |f(x)-A| \\lt \\epsilon\n$$\n上述的三个变形代表了不同的趋近情况 2、3分别时左趋近和右趋近时候的定义\n$$\n当x \\to \\infty时 \\\\\n(1)\\lim_{x \\to \\infty} f(x) = A  :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ |x| \\gt X \\ 时 \\ \\ \t|f(x)-A| \\lt \\epsilon \\\\\n(2)\\lim_{x \\to +\\infty} f(x) = A  : \\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ x \\gt X \\ 时 \\ \\ \t|f(x)-A| \\lt \\epsilon \\\\\n(3)\\lim_{x \\to -\\infty} f(x) = A  : \\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ x \\lt -X \\ 时 \\ \\ \t|f(x)-A| \\lt \\epsilon\n$$\n\n### 函数极限的充要条件 （感觉有点没有用）\n\n描述：函数的极限存在那么左趋近和右趋近都要相等\n\n函数的趋近无穷极限存在那么同理趋近正无穷和负无穷也都要相等\n$$\n\\lim_{x \\to x_0} f(x) = A \\ \\iff \\ \\lim_{x \\to x_0^+} f(x) = \\lim_{x \\to x_0^-}f(x) = A  \\\\\n\\lim_{x \\to \\infty} f(x) = A \\ \\iff \\ \\lim_{x \\to +\\infty} f(x) = \\lim_{x \\to -\\infty}f(x) = A\n$$\n\n\n### 函数极限的性质\n\n若函数存在极限则有如下的性质。\n\n- 唯一性  和数列极限的唯一性相似\n- 局部有界性\n\n$$\n设\\lim_{x \\to x_0} f(x) 存在，则 \\ \\ \\exists \\delta \\gt 0 \\ \\ \\exists M \\gt 0 \\ \\  使得当 \\ \\ 0 \\lt |x-x_0| \\lt \\delta \\ (局部) 时 \\ \\  |f(x)| \\le M \\ \\ (有界)\n$$\n\n> tips:\n>\n> 对于上述的有点不同的六个定义，局部有界性应该是修改相应的限制局部的区间。\n\n- 局部保号性  极限不能等于0\n- 推论\n\n$$\n设f(x) \\ge 0 \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge 0 \\\\\n设f(x) \\gt 0 \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge 0\n$$\n\n这个推论：极限和函数的上界\\下界之间的关系\n$$\n若f(x) \\ge k \\ \\ 是否有 \\lim_{x \\to x_0} f(x) =  A \\ge k \\ \\ ? \\ \\ (成立！) \\\\\n若f(x) \\ge k \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge k \\\\\n若f(x) \\gt k \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge k \n$$\n\n\n### 函数极限的四则运算\n\n$$\n\\lim_{x \\to [..]} f(x) = A \\ \\ \\ \\lim_{x \\to [..]} f(x) = B \\\\\nsum:\\lim_{x \\to [..]} [f(x)\\pm g(x)] = A\\pm B   \\\\\nmulti: \\lim_{x \\to [..]} f(x) \\times g(x) = A\\times B \\\\\ndiv: \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\frac{A}{B}\n$$\n\n推论：（提出非0因子）\n$$\n假设 \\lim_{x \\to [..]} f(x) = A \\neq 0, \\ \\ 则 \\lim_{x \\to [..]} f(x)g(x) = A\\lim_{x \\to [..]} g(x)\n$$\n注意 ：\n\nA一定是一个非0因子！每个极限都要存在，分母极限不为0。\n\n## 1.2无穷小和无穷大\n\n### 无穷小的定义\n\n极限为0 的函数\n$$\n\\lim_{x \\to [..]} f(x) = 0 \\ \\ 则称f(x)为x \\to [..] 时的无穷小。 \n$$\n\n\n### 无穷小的性质\n\n1. 有限个无穷小的和还是无穷小\n2. 有限个无穷小的积还是无穷小\n3. 无穷小乘有界量为无穷小\n\n### 无穷小阶的比较（缺少比较的方法论）\n\n- 怎么判断两个无穷小谁是谁的高阶无穷小\n  $$\n  if \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = 0 \\\\\n  则 f 为 g的高阶无穷小  \\ \\ 记为 f = o(g(x))\n  $$\n  \n- .....同阶无穷小\n  $$\n  if \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = C  \\ \\ \\ (c \\neq 0) \\\\\n  则 f 为 g的同阶无穷小\n  $$\n  \n- .....等价无穷小\n  $$\n  if \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = 1  \\\\\n  则 f 为 g的等价无穷小\n  $$\n  \n- .....k阶无穷小\n  $$\n  if \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)^k} = C  \\ \\ \\ (c \\neq 0) \\\\\n  则 f 为 g的k阶无穷小\n  $$\n  \n\n### 高阶无穷小的(运算)性质\n\n- 性质一：和式性质，无穷小的和的阶数等于和式中最小的阶，低阶吸收高阶。\n\n$$\no(x^m)\\pm o(x^n) = o(x^l) \\ \\ l = min(m,n);\n$$\n\n\n\n- 性质二：乘系数性质\n\n$$\nk \\ o(x^m) = o(x^m) \\ \\\n$$\n\n- 性质三：乘法性质\n  $$\n  o(x^m)\\times x^n = o(x^n)\\times x^m = o(x^n)\\times o(x^m)  = o(x^{m+n})\n  $$\n  \n- 性质四：除法性质\n  $$\n  \\frac{o(x^m)}{x^n} = o(x^{m-n}) \\ \\ (m \\gt n) \\\\\n  \\frac{x^m}{o(x^n)} = o(x^{m-n}) \\ \\ (m \\gt n) \\ \\ (不成立)\\\\\n  \\frac{o(x^m)}{o(x^n)} = o(x^{m-n}) \\ \\ (m \\gt n) \\ \\ (不成立)\\\\\n  上述两个式子都不成立，符号代表着其实是一种范围式的记法，\\\\ \n  如果出现在分母，那么必定能找到一个一个分母阶数大于分子阶数的项那么最后整个式子的结果就不确定。\n  $$\n  \n  \n  \n\n### 无穷小相关的题目\n\n给定两个无穷小的比值计算其中一个函数的极限\n\n千万不能想Taylor，题目中没有说明这个函数的可导性，Taylor需要知道该函数在该点n+1阶可导\n\n{% tabs 给定两个无穷小的比值计算其中一个函数的极限 %}\n<!-- tab -->\n$$\n\\lim _{x \\rightarrow 0} \\frac{\\ln \\left(1+x+\\frac{f(x)}{x}\\right)}{x}=3 \\text {, 则 } \\lim _{x \\rightarrow 0} \\frac{f(x)}{x^2}=\n$$\n<!-- endtab -->\n\n<!-- tab -->\n$$\n\\text { 设 } \\lim _{x \\rightarrow 0} \\frac{\\ln (1-x)+x f(x)}{x^2}=0 \\text {, 则 } \\lim _{x \\rightarrow 0} \\frac{f(x)-1}{x}=\n$$\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n\n\n\n### 无穷大的定义\n\n- 定义一：趋近一个确定的点的无穷大概念定义\n  $$\n  \\lim_{x \\to x_0} f(x) = \\infty \\\\\n  \\forall M \\gt 0 , \\ \\ \\exists \\delta \\gt 0, \\ \\ 使得0\\lt |x-x_0| \\lt \\delta \\ \\ \\  |f(x)| \\gt M\n  $$\n  \n- 定义二：趋近于无穷时候的无穷大\n  $$\n  \\lim_{x \\to \\infty} f(x) = \\infty \\\\\n  \\forall M \\gt 0 , \\ \\ \\exists X \\gt 0, \\ \\ 使得 |x| \\gt X \\ \\ \\  |f(x)| \\gt M\n  $$\n  \n\n### 无穷大的性质\n\n1. 无穷大的倒数是无穷小、==非0无穷小的倒数（该函数不能区到0）【个人感觉有点不太严谨 或者我听错了，之后再看看】==\n\n2. 无穷大一定是无界量  但是 无界量不一定是无穷大 。\n   $$\n   无穷大的概念是一个连续的概念，根据定义必定存在一个区间，在这个区间内的任意取值都可以要多大有多大 \\\\\n   无界量只要有一个点满足无穷条件就可以满足其定义 \\\\\n   f(x) = \n   \\begin{cases}\n   \\infty , \\ \\ \\ x = x_0 \\\\\n   0, \\ \\ \\ x \\neq x_0 \\\\\n   \\end{cases} \\\\\n   或者如下例子 \\\\\n   f(x) = x\\sin(x) \\ \\ \\\\\n   x = 2n\\pi + \\frac{\\pi}{2} \\\\\n   x = 2n\\pi\n   $$\n   \n\n### 无穷大阶的比较 （缺少比较的方法论）\n\n这个部分需要先去硬性记忆一下。\n\n- 函数无穷大\n\n$$\n常见函数的无穷大比较 x \\to +\\infty \\\\ \n\\ln(x)^{\\alpha} \\ll x^{\\beta} \\ll a^x \\ll x^x\n$$\n\n- 数列无穷大\n  $$\n  常见数列的无穷大比较 n\\to \\infty \\\\\n  \\ln(n)^{\\alpha} \\ll n^{\\beta} \\ll a^n \\ll n! \\ll x^x\n  $$\n  \n\n## 1.3洛必达法则（方法论、解题方法）\n\n### 洛必达法则的条件\n\n满足这三个条件说明可以洛必达，但是如果洛必达求不出来那也不能说明函数极限不存在。\n\n- 一\n  $$\n  \\lim_{x \\to [..]} [\\frac{f(x)}{g(x)}] \\ \\ 为 \\frac{0}{0} \\ \\ or \\ \\ \\frac{\\infty}{\\infty} \\ 类型的\n  $$\n\n- 二\n  $$\n  f(x) \\ \\  and \\ \\ g(x) \\ \\ 可导 \\ \\ \\ (涉及到可导性判断)\n  $$\n\n- 三\n  $$\n  \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\lim_{x \\to [..]} \\frac{f'(x)}{g'(x)} = 0 \\ \\ or \\ \\ \\infty 时才能说明原极限为0 或者\\infty; 如果不存在则不能说明原极限不存在。\n  $$\n\n则\n$$\n\\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\lim_{x \\to [..]} \\frac{f'(x)}{g'(x)} = \\lim_{x \\to [..]} \\frac{f''(x)}{g''(x)} = .......\n$$\n经典错误：\n\n\n$$\n\\lim_{x \\to \\infty} \\frac{x+\\sin(x)}{x} \\ \\ \n$$\n\n\n结论：洛必达求出来极限不存在不能说明当前极限不存在，得用其他方法求。\n\n## 1.4等价代换\n\n等价代换的实质是泰勒公式，是一个函数在0点的无穷次展开。\n\n- X 趋近 0 的时候\n\n$$\nx \\to 0 \\\\\n(1) \\ \\ \\ x \\sim \\sin(x) \\sim \\tan(x) \\sim \\arcsin(x) \\sim \\arctan(x) \\sim e^x-1 \\sim \\ln(x+1) \\\\\n(2)\\begin{cases}\n(1+x)^\\alpha -1 \\sim \\alpha x \\\\\n\\alpha ^x -1 \\sim x\\ln\\alpha\n\\end{cases} \\\\\n(3)\\begin{cases}\nx-\\sin(x) \\sim \\arcsin(x)-x \\sim \\frac{x^3}{6} \\\\\n\\tan(x)-x \\sim x-\\arctan(x) \\sim \\frac{x^3}{3} \\\\\n\\tan(x)-\\sin(x) \\sim \\arctan(x) - \\arcsin(x) \\sim \\frac{x^3}{2} \\\\\n\\end{cases}\n$$\n\n- 等价代换求极限 注意点：\n  - 乘除可以代换\n  - 加减不能随意代换，最简形式不抵消的时候可以代换 （个人建议直接使用taylor公式）\n\n推广：\n$$\nx \\to 0 \\ \\ 可以推广为 \\ \\ [..] \\to 0 \\\\\n例如：\\ln(1+[..]) \\sim [..] \\ \\ 当 \\ \\ [..] \\to 0 时\n$$\n\n\n\n\n\n## 1.5 Taylor公式\n\n### Taylor公式定义\n\n$$\nf(x) 在 x = x_0 的某一个邻域内 n+1 阶可导则有如下 \\\\\nf(x) = f(x_0) + f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + \\frac{1}{3!}f'''(x_0)(x-x_0)^3 + .....+ \\frac{1}{n!}f^{n}(x_0)(x-x_0)^n + \n\\begin{cases}\n\\frac{1}{(n+1)!}f^{n+1}(\\zeta)(x-x_0)^{n+1}  \\ \\ \\ largrange 余项 \\\\\no(x-x_0)^n \\ \\ \\ Peano余项\n\\end{cases}\n$$\n\n第n+1阶导数是一个余项形式\n\n### Maclaurin （麦克劳林）公式\n\n$$\nTaylor公式中当x_0 = 0时的取值。\\\\\nf(x) = f(0) + f'(0)(x-0) + \\frac{1}{2!}f''(0)(x-0)^2 + \\frac{1}{3!}f'''(0)(x-0)^3 + .....+ \\frac{1}{n!}f^{n}(0)(x-0)^n\n$$\n\n### 常见函数的一阶导数\n\n\n$$\n\\begin{align} \n&(1)   (C)^{\\prime}=0, \\\\\n&(2)   (x^\\mu)^{\\prime}=\\mu x^{\\mu-1}, \\\\\n&(3)   (\\sin x)^{\\prime}=\\cos x, \\\\\n&(4)   (\\cos x)^{\\prime}=-\\sin x, \\\\\n&(5)   (\\tan x)^{\\prime}=\\sec ^2 x, \\\\\n&(6)   (\\cot x)^{\\prime}=-\\csc ^2 x, \\\\\n&(7)   (\\sec x)^{\\prime}=\\sec x \\tan x, \\\\\n&(8)   (\\csc x)^{\\prime}=-\\csc x \\cot x, \\\\\n&(9)   (a^x)^{\\prime}=a^x \\ln a \\quad(a>0, a \\neq 1), \\\\\n&(10)  (\\mathrm{e}^x)^{\\prime}=\\mathrm{e}^x, \\\\ \n&(11)  (\\log _a )^{\\prime}=\\frac{1}{x \\ln a}(a>0, a \\neq 1), \\\\\n&(12)  (\\ln x)^{\\prime}=\\frac{1}{x}, \\\\\n&(13)  (\\arcsin x)^{\\prime}=\\frac{1}{\\sqrt{1-x^2}}, \\\\\n&(14)  (\\arccos x)^{\\prime}=-\\frac{1}{\\sqrt{1-x^2}}, \\\\\n&(15)  (\\arctan x)^{\\prime}=\\frac{1}{1+x^2}, \\\\\n&(16)  (\\operatorname{arccot} x)^{\\prime}=-\\frac{1}{1+x^2} \\\\\n\\end{align}\n$$\n\n\n\n### 常见函数的Taylor公式[^1]\n\n$$\n\\begin{align}\n& \\mathrm{e}^{\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{1}{\\mathrm{n} !} \\mathrm{x}^{\\mathrm{n}}=1+\\mathrm{x}+\\frac{1}{2 !} \\mathrm{x}^2+\\cdots \\in(-\\infty,+\\infty) \\\\\n& \\sin \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{(2 \\mathrm{n}+1) !} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}-\\frac{1}{3 !} \\mathrm{x}^3+\\frac{1}{5 !} \\mathrm{x}^5+\\cdots, \\mathrm{x} \\in(-\\infty,+\\infty) \\\\\n& \\alpha^{x}  = \\sum_{n = 0}^{\\infty}\\frac{(\\ln\\alpha)^n}{n!}x^n = 1+\\ln\\alpha x +\\frac{(\\ln\\alpha)^2}{2!}x^2+\\frac{(\\ln\\alpha)^3}{3!} + \\cdots\\\\\n& \\arcsin \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(2 \\mathrm{n}) !}{4^{\\mathrm{n}}(\\mathrm{n} !)^2(2 \\mathrm{n}+1)} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}+\\frac{1}{6} \\mathrm{x}^3+\\frac{3}{40} \\mathrm{x}^5+\\frac{5}{112} \\mathrm{x}^7+\\frac{35}{1152} \\mathrm{x}^9+\\cdots+, \\mathrm{x} \\in(-1,1) \\\\\n& \\cos \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{(2 \\mathrm{n}) !} \\mathrm{x}^{2 \\mathrm{n}}=1-\\frac{1}{2 !} \\mathrm{x}^2+\\frac{1}{4 !} \\mathrm{x}^4+\\cdots, \\mathrm{x} \\in(-\\infty,+\\infty) \\\\\n& 注意：\\arcsin+\\arccos = \\frac{\\pi}{2} : \\\\\n& \\arccos \\mathrm{x} =  \\frac{\\pi}{2} - (\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(2 \\mathrm{n}) !}{4^{\\mathrm{n}}(\\mathrm{n} !)^2(2 \\mathrm{n}+1)} \\mathrm{x}^{2 \\mathrm{n}+1}) =  \\frac{\\pi}{2} - ( \\mathrm{x}+\\frac{1}{6} \\mathrm{x}^3+\\frac{3}{40} \\mathrm{x}^5+\\frac{5}{112} \\mathrm{x}^7+\\frac{35}{1152} \\mathrm{x}^9+\\cdots+ ) \\\\\n& \\ln (1+x)=\\sum_{n=0}^{\\infty} \\frac{(-1)^n}{n+1} x^{n+1}=x-\\frac{1}{2} x^2+\\frac{1}{3} x^3+\\cdots, x \\in(-1,1] \\\\\n& \\frac{1}{1-\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty} \\mathrm{x}^{\\mathrm{n}}=1+\\mathrm{x}+\\mathrm{x}^2+\\mathrm{x}^3+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& \\frac{1}{1+\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty}(-1)^{\\mathrm{n}} \\mathrm{x}^{\\mathrm{n}}=1-\\mathrm{x}+\\mathrm{x}^2-\\mathrm{x}^3+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& (1+\\mathrm{x})^\\alpha=1+\\sum_{\\mathrm{n}=1}^{\\infty} \\frac{\\alpha(\\alpha-1) \\cdots(\\alpha-\\mathrm{n}+1)}{\\mathrm{n} !} \\mathrm{x}^{\\mathrm{n}}=1+\\alpha \\mathrm{x}+\\frac{\\alpha(\\alpha-1)}{2 !} \\mathrm{x}^2+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& \\arctan \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{2 \\mathrm{n}+1} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}-\\frac{1}{3} \\mathrm{x}^3+\\frac{1}{5} \\mathrm{x}^5+\\cdots+\\mathrm{x} \\in[-1,1] \\\\\n\n& \\tan \\mathrm{x}=\\sum_{\\mathrm{n}=1}^{\\infty} \\frac{\\mathrm{B}_{2 \\mathrm{n}}(-4)^{\\mathrm{n}}\\left(1-4^{\\mathrm{n}}\\right)}{(2 \\mathrm{n}) !} \\mathrm{x}^{2 \\mathrm{n}-1}=\\mathrm{x}+\\frac{1}{3} \\mathrm{x}^3+\\frac{2}{15} \\mathrm{x}^5+\\frac{17}{315} \\mathrm{x}^7+\\frac{62}{2835} \\mathrm{x}^9+\\frac{1382}{155925} \\mathrm{x}^{11}+\\frac{21844}{6081075} \\mathrm{x}^{13}+... \\mathrm{x} \\in(-\\frac{\\pi}{2},\\frac{\\pi}{2}) \\\\\n&\n\\end{align}\n$$\n\n推广：这里的taylor公式也可以推广为【..】=> 0；类似复合函数的形式,注意函数极限中的两个式子的加减是否产生了抵消。\n\n## 1.6 七类未定式\n\n$$\n七类未定式：\n\\ \\ \\ \\frac{0}{0} \n\\ \\ \\ \\frac{\\infty}{\\infty} \n\\ \\ \\ 0\\times\\infty\n\\ \\ \\ \\infty - \\infty \n\\ \\ \\ 0^{\\infty}\n\\ \\ \\ \\infty^{0}\n\\ \\ \\ 1^{\\infty}\n$$\n\n\n\n- $$\\infty^{0}$$\n\n{% tabs 无穷的0次方例题 %}\n<!-- tab -->\n$$\nI = \\lim_{x \\to \\infty}(e^{x^2}+x^3)^{\\frac{1}{x^2}}\\\\\n(1) \\ \\ I = \\lim_{x \\to \\infty} e^{\\frac{\\ln{(e^{x^2}+x^3})}{x^2}} \\Rightarrow 对于指数 \\frac{\\ln{(e^{x^2}+x^3)}}{x^2} 使用洛必达 \\\\\n(2) 观察到外层的指数和里面的某一项有可以相消的指数：化简\\Rightarrow \\lim_{x\\to \\infty} [e^{x^2}(1+\\frac{x^3}{e^{x^2}})]^{\\frac{1}{x^2}}\n$$\n将函数指数化、对数化，将其变为一个$$\\frac{\\infty}{\\infty}$$类型，然后研究指数，使用洛必达解出\n\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 2.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n\n### Lagrange方法\n\n$$\nf(a)-f(b) = f'(\\xi)(a-b)\n$$\n\n 拉格朗日求函数极限的方法一定要注意 构造的函数的两个区间一定 \n\n### 对数函数公式\n\n$$\n\\begin{cases}\n&恒等变形 \\ \\ \\ f(x) = e^{\\ln f(x)} = \\ln {e^{f(x)}} \\\\\n& 加法公式 \\ \\ \\ \\ln{a} + \\ln{b} = \\ln{ab} \\\\\n& 减法公式 \\ \\ \\ \\ln{a} - \\ln{b} = \\ln{\\frac{a}{b}} \\\\\n&换底公式 \\ \\ \\ \\log_a b = \\frac{\\ln{b}}{\\ln{a}} \\\\\n\\end{cases}\n$$\n\n\n\n### 三角函数公式[^2]\n\n#### 和差化积公式记忆口诀\n\n正加正，正在前，余减余，余并肩，正减正，余在前，余减余，负正弦。\n\n\n\n\n\n### 解决七类未定式的方法论：\n\n- 三种：等价、洛必达、泰勒\n\n- 三种：洛必达、同除最高次幂项（注意符号的问题）、抓大头\n\n-  两种：将其化为第一种或者第二种方法 来做\n\n- 三种：通分、有理化、倒代换\n\n- 第五和第六中未定式：使用对数的公式化简\n\n  > tips (注意): $ \\lim_{x\\to 0^+} x^{\\alpha} \\ln^{\\beta}{x} = 0, \\ \\ \\alpha,\\beta \\in(0,\\infty) $\n\n## 1.7 数列极限 （单调有界定理）\n\n### 重要不等式\n\n$$\n\\begin{align}\n& (1) \\sin(x) \\lt x \\lt \\tan(x) , x \\in(0,\\frac{\\pi}{2})   \\\\\n& (2) e^x \\lt 1+x, x \\neq 0 \\\\\n& (3) \\frac{x}{1+x} \\lt \\ln(1+x) \\lt x , x \\neq 0 \\ \\ and \\ \\ x \\in(-1,\\infty) \\\\\n\\end{align}\n$$\n\n### 单调有界定理的步骤\n\n- 放缩确定界（证明有界）\n\n- 证明单调\n  $$\n  \\begin{align}\n  & (1) 做差 \\ \\ x_{n+1}-x_{n}   \\\\\n  & (2) 做商 \\ \\ \\frac{x_{n+1}}{x_n} \\\\\n  & (3) 求解函数的单调性 \\ \\ y = f(x)\n  \\begin{cases}\n  f'(x) \\gt 0 \n  \\begin{cases}\n  x_1 \\gt x_2 \\rightarrow \\ x_2 = f(x_1)>f(x_2) = x_3,即 x_2 \\gt x_3 以此类推,x_{n-1} \\gt x_{n} \\\\\n  x_1 \\lt x_2 \\rightarrow \\ x_2 = f(x_1) \\lt f(x_2) = x_3,...., x_{n-1} \\lt x_{n}\n  \\end{cases} \\\\\n  f'(x) \\lt 0 \\ \\ 使用夹逼准则\n  \\end{cases}\n  \\\\\n  \\end{align}\n  $$\n\n- 两边做极限解方程求解最后的极限值\n\n  \n\n## 1.8 数列极限（夹逼准则）\n\n难点在于如何构造夹逼的两个函数。\n$$\nx_n \\le y_n \\le z_n \\  and \\ \\lim_{n \\to \\infty} x_n = \\lim_{n \\to \\infty} y_n = A \\rightarrow \\lim_{n \\to \\infty} y_n = A\n$$\n\n\n## 1.9 定积分定义 （这个比较简单）\n\n夹逼准则和定积分定义有时候会搞混。\n\n## 2.1 连续\n\n### 连续的定义\n\n连续、右连续、左连续\n$$\n\\begin{align}\n& (1) 连续 \\ \\ \\ \\lim_{x \\to x_0} f(x) = f(x_0) \\\\\n& (2) 右连续 \\ \\ \\ \\lim_{x \\to x_0^+} f(x) = f(x_0)  \\\\\n& (3) 左连续 \\ \\ \\ \\lim_{x \\to x_0^-} f(x) = f(x_0)  \\\\\n\\end{align}\n$$\n\n\n### 连续函数的性质\n\n基本初等函数：反、对、幂、指、三（反三角函数、对数函数、幂函数、指数函数、三角函数）\n\n初等函数：基本初等函数经过有限次四则运算或者复合 得到的函数\n$$\n\\begin{align}\n& (1) 基本初等函数在其定义域内都连续\\\\\n& (2) 连续函数经过有限次的四则运算以及复合任然是连续的 \\\\\n& (3) 初等函数都是连续函数\\\\\n\\end{align}\n$$\n\n\n### 闭区间连续函数的性质（定理，一定是闭区间的、连续的）\n\n$$\n\\begin{align}\n& (1) 最值定理: 闭区间连续函数一定存在最大值M 最小值m，即 m \\le f(x) \\le M  \\\\\n& (1.1) 最值定理推论：有界定理【闭区间连续函数必定有界】\\\\\n& (2) 介值定理: 若f(x) ， x \\in[a,b] 则一定有 \\exists \\xi \\in [a,b], 使得 f(\\xi) = \\frac{f(a)+f(b)}{2} \\\\\n& (2.1) 介值定理推论: \\ \\forall x_1,x_2,x_3 \\dots x_n \\in[a,b] ,则有\\exists \\xi \\in[a,b] \\ \\ f(\\xi) = \\frac{f(x_1)+f(x_2)+\\dots +f(x_n)}{n}   \\\\\n& (3) 零点定理: 若 f(a)f(b) \\lt 0, 则\\exists \\xi \\in(a,b), f(\\xi) = 0 \\\\\n\\end{align}\n$$\n\n\n\n{% tabs 例题 %}\n<!-- tab -->\n$$\n例：设 f(x) 在x \\in[a,b]上连续 and\\ \\ f(1) = f(0) \\ \\ \\ 证明: \\exists \\xi 使得 f(\\xi+\\frac{1}{4}) = f(\\xi)\n$$\n\n\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 2.**\n<!-- endtab -->\n\n<!-- tab -->\n**This is Tab 3.**\n<!-- endtab -->\n{% endtabs %}\n\n## 2.2 间断点\n\n### 间断点的定义\n\n$$\nf(x)在某个（存在这样的去心邻域即可）\\mathring{U}(x_0)有定义,并且f(x)在x_0处不连续（连续的定义见上文）。\n$$\n\n### 间断点的分类\n\n- 左右极限均存在的\n  - 可去间断点，左极限=右极限，但是不等于点处的值。（或者该点处没有定义）\n  - 跳跃间断点\n- 左右极限至少有一个不存在的\n  - 无穷间断点\n  - 振荡间断点\n\n# reference\n\n[^1]:  [Taylor多项式/Taylor公式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/348178130) ↩[(10条消息) 常见函数泰勒公式展开（清晰）_常见的泰勒展开公式大全_陌雨’的博客-CSDN博客](https://blog.csdn.net/Infinity_07/article/details/113830088)\n[^2]: [考研数学的初等函数变换公式——三角相关 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/89073536)\n[^3]: [(18 封私信 / 4 条消息) 有极限的数列是有界的怎么理解? - 知乎 (zhihu.com)](https://www.zhihu.com/question/26383384)\n","slug":"考研数学（高数部分，第一章）复习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmf000xbsuohbepgc1s","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-02</p>\n</div></div><div class=\"timeline-item-content\"><p>整理姜晓千数学第一讲 函数的极限连续</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-09</p>\n</div></div><div class=\"timeline-item-content\"><p>整理姜晓千数学第一讲 </p>\n<ul>\n<li>无穷大、无穷小</li>\n<li>洛必达法则</li>\n<li>等价代换</li>\n<li>Taylor公式</li>\n<li>复习之前的概念</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-10</p>\n</div></div><div class=\"timeline-item-content\"><p>继续昨天的任务</p>\n<ul>\n<li>完善了几个常见的函数的taylor展开</li>\n<li>复习了求解函数极限中的七类未定式</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-11</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>数列极限的求解方法<ul>\n<li>单调有界定理</li>\n<li>夹逼准则</li>\n<li>定积分定义</li>\n</ul>\n</li>\n<li>连续和间断</li>\n<li>导数<ul>\n<li>导数的定义</li>\n<li>导数的性质</li>\n</ul>\n</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-17</p>\n</div></div><div class=\"timeline-item-content\"><p>增添了几道例题。</p>\n<ul>\n<li>[x] 刷660 前45题</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"函数极限连续\"><a href=\"#函数极限连续\" class=\"headerlink\" title=\"函数极限连续\"></a>函数极限连续</h1><p>微积分之前先==化简==</p>\n<ul>\n<li>拆、提、同除、同乘</li>\n<li>对数公式</li>\n<li>三角公式</li>\n</ul>\n<h2 id=\"1-1函数\"><a href=\"#1-1函数\" class=\"headerlink\" title=\"1.1函数\"></a>1.1函数</h2><ul>\n<li>重要内容：</li>\n</ul>\n<p>单调性</p>\n<p>有界性</p>\n<p>奇偶性  第三章积分  </p>\n<p>周期性  第三章积分</p>\n<h3 id=\"极限-（大题、小题都有）\"><a href=\"#极限-（大题、小题都有）\" class=\"headerlink\" title=\"极限 （大题、小题都有）\"></a>极限 （大题、小题都有）</h3><p>八个方法：</p>\n<ul>\n<li>求解函数极限<ul>\n<li>洛必达 （简单函数适合洛必达）【简单函数：容易求导，越求导越简单的】</li>\n<li>==导数定义== （牛顿最先提出 一阶 二阶  第二章会讲到）</li>\n<li>等价代换 （3组）</li>\n<li>taylor公式 （8个常见的）</li>\n<li>拉格朗日  （第二章内容  ）</li>\n</ul>\n</li>\n<li>数列极限<ul>\n<li>单调有界</li>\n<li>夹逼准则</li>\n<li>定积分定义 （第三章 黎曼定积分定义）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数列极限的概念\"><a href=\"#数列极限的概念\" class=\"headerlink\" title=\"数列极限的概念\"></a>数列极限的概念</h3><p>数列极限的定义：’$ \\lim<em>{ n \\to \\infty} a</em>{n} = a  $’  Cauthy提出的 数列极限的定义。</p>\n<script type=\"math/tex; mode=display\">\n对于 \\forall \\epsilon \\gt 0 \\ \\   \\exists N \\gt 0 \\ \\ \\ 当 n \\gt N \\ 时 \\ |a_{n}-a| \\lt \\epsilon</script><p>数列机芯啊描述了这个数列在趋向于无穷的时候函数的逼近值。</p>\n<blockquote>\n<p>tips: </p>\n<p>在柯西的定义中<script type=\"math/tex\">|a_{n}-a| \\le \\epsilon</script> 也是可以的。</p>\n<p>同理：以下变形也是可以的：</p>\n<ul>\n<li><script type=\"math/tex; mode=display\">|a_{n}-a| \\le 10\\epsilon</script></li>\n<li><script type=\"math/tex; mode=display\">|a_{n}-a| \\le \\frac{1}{10}\\epsilon</script></li>\n</ul>\n<p>总结：只要在定义中保证数列的无穷处和目标值a要多近有多近就可以。</p>\n</blockquote>\n<h3 id=\"数列极限的充要条件\"><a href=\"#数列极限的充要条件\" class=\"headerlink\" title=\"数列极限的充要条件\"></a>数列极限的充要条件</h3><script type=\"math/tex; mode=display\">\n在Cauthy对数列极限的定义中 \\\\\n....(极限定义)... \\iff对于\\forall a_n 中的任意子列 b_n \\ \\ \\lim_{n\\rightarrow \\infty} b_n = a</script><p>注意！要是后推前必须要说明所有的子列的极限都是相等的才能推导出 Cauthy极限的定义。</p>\n<p>（所有）子列极限都相等</p>\n<h3 id=\"数列极限的性质\"><a href=\"#数列极限的性质\" class=\"headerlink\" title=\"数列极限的性质\"></a>数列极限的性质</h3><ul>\n<li>唯一性：</li>\n<li>全局有界性：数列有极限必定有界，但是数列有界不一定有极限<sup><a href=\"#fn_3\" id=\"reffn_3\">3</a></sup></li>\n</ul>\n<script type=\"math/tex; mode=display\">\n若数a_n的极限是a \\ 那么 必定\\forall \\epsilon \\gt 0 \\ \\   \\exists N \\gt 0 \\ \\ \\ 当 n \\gt N \\ 时 \\ |a_{n}-a| \\lt \\epsilon \\\\\n也是就是说在n大于一个比较大的数字之后 a_n 的所有的值都会在一个很小的范围内，而且N之前的取值也都是有界的，所以数列整体有界</script><ul>\n<li>局部保号性  (极限不能等于0)；</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n假设\\lim_{n \\to \\infty} a_n = a \\gt 0 \\ \\ \\  则 \\exists N 当n \\gt N \\ \\  时 a_n \\gt 0</script><h3 id=\"函数极限的概念\"><a href=\"#函数极限的概念\" class=\"headerlink\" title=\"函数极限的概念\"></a>函数极限的概念</h3><p>函数极限的定义：两个大定义 和六个小定义 (x-x0不能等于0  因为函数可能在x0没有定义)</p>\n<script type=\"math/tex; mode=display\">\n当x\\to x_0时 \\\\\n(1) \\lim_{x \\to x_0} f(x) = A :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ 0\\lt |x-x_0| \\lt \\delta \\ 时  \\ \\ |f(x)-A| \\lt \\epsilon \\\\\n(2)\\lim_{x \\to x_0^+} f(x) = A  :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ 0\\lt x-x_0 \\lt \\delta \\ 时 \\ \\     |f(x)-A| \\lt \\epsilon \\\\\n(3) \\lim_{x \\to x_0^-} f(x) = A :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ -\\delta \\lt x-x_0 \\lt 0 \\ 时 \\ \\ |f(x)-A| \\lt \\epsilon</script><p>上述的三个变形代表了不同的趋近情况 2、3分别时左趋近和右趋近时候的定义</p>\n<script type=\"math/tex; mode=display\">\n当x \\to \\infty时 \\\\\n(1)\\lim_{x \\to \\infty} f(x) = A  :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ |x| \\gt X \\ 时 \\ \\     |f(x)-A| \\lt \\epsilon \\\\\n(2)\\lim_{x \\to +\\infty} f(x) = A  : \\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ x \\gt X \\ 时 \\ \\     |f(x)-A| \\lt \\epsilon \\\\\n(3)\\lim_{x \\to -\\infty} f(x) = A  : \\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ x \\lt -X \\ 时 \\ \\     |f(x)-A| \\lt \\epsilon</script><h3 id=\"函数极限的充要条件-（感觉有点没有用）\"><a href=\"#函数极限的充要条件-（感觉有点没有用）\" class=\"headerlink\" title=\"函数极限的充要条件 （感觉有点没有用）\"></a>函数极限的充要条件 （感觉有点没有用）</h3><p>描述：函数的极限存在那么左趋近和右趋近都要相等</p>\n<p>函数的趋近无穷极限存在那么同理趋近正无穷和负无穷也都要相等</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to x_0} f(x) = A \\ \\iff \\ \\lim_{x \\to x_0^+} f(x) = \\lim_{x \\to x_0^-}f(x) = A  \\\\\n\\lim_{x \\to \\infty} f(x) = A \\ \\iff \\ \\lim_{x \\to +\\infty} f(x) = \\lim_{x \\to -\\infty}f(x) = A</script><h3 id=\"函数极限的性质\"><a href=\"#函数极限的性质\" class=\"headerlink\" title=\"函数极限的性质\"></a>函数极限的性质</h3><p>若函数存在极限则有如下的性质。</p>\n<ul>\n<li>唯一性  和数列极限的唯一性相似</li>\n<li>局部有界性</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n设\\lim_{x \\to x_0} f(x) 存在，则 \\ \\ \\exists \\delta \\gt 0 \\ \\ \\exists M \\gt 0 \\ \\  使得当 \\ \\ 0 \\lt |x-x_0| \\lt \\delta \\ (局部) 时 \\ \\  |f(x)| \\le M \\ \\ (有界)</script><blockquote>\n<p>tips:</p>\n<p>对于上述的有点不同的六个定义，局部有界性应该是修改相应的限制局部的区间。</p>\n</blockquote>\n<ul>\n<li>局部保号性  极限不能等于0</li>\n<li>推论</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n设f(x) \\ge 0 \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge 0 \\\\\n设f(x) \\gt 0 \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge 0</script><p>这个推论：极限和函数的上界\\下界之间的关系</p>\n<script type=\"math/tex; mode=display\">\n若f(x) \\ge k \\ \\ 是否有 \\lim_{x \\to x_0} f(x) =  A \\ge k \\ \\ ? \\ \\ (成立！) \\\\\n若f(x) \\ge k \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge k \\\\\n若f(x) \\gt k \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge k</script><h3 id=\"函数极限的四则运算\"><a href=\"#函数极限的四则运算\" class=\"headerlink\" title=\"函数极限的四则运算\"></a>函数极限的四则运算</h3><script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} f(x) = A \\ \\ \\ \\lim_{x \\to [..]} f(x) = B \\\\\nsum:\\lim_{x \\to [..]} [f(x)\\pm g(x)] = A\\pm B   \\\\\nmulti: \\lim_{x \\to [..]} f(x) \\times g(x) = A\\times B \\\\\ndiv: \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\frac{A}{B}</script><p>推论：（提出非0因子）</p>\n<script type=\"math/tex; mode=display\">\n假设 \\lim_{x \\to [..]} f(x) = A \\neq 0, \\ \\ 则 \\lim_{x \\to [..]} f(x)g(x) = A\\lim_{x \\to [..]} g(x)</script><p>注意 ：</p>\n<p>A一定是一个非0因子！每个极限都要存在，分母极限不为0。</p>\n<h2 id=\"1-2无穷小和无穷大\"><a href=\"#1-2无穷小和无穷大\" class=\"headerlink\" title=\"1.2无穷小和无穷大\"></a>1.2无穷小和无穷大</h2><h3 id=\"无穷小的定义\"><a href=\"#无穷小的定义\" class=\"headerlink\" title=\"无穷小的定义\"></a>无穷小的定义</h3><p>极限为0 的函数</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} f(x) = 0 \\ \\ 则称f(x)为x \\to [..] 时的无穷小。</script><h3 id=\"无穷小的性质\"><a href=\"#无穷小的性质\" class=\"headerlink\" title=\"无穷小的性质\"></a>无穷小的性质</h3><ol>\n<li>有限个无穷小的和还是无穷小</li>\n<li>有限个无穷小的积还是无穷小</li>\n<li>无穷小乘有界量为无穷小</li>\n</ol>\n<h3 id=\"无穷小阶的比较（缺少比较的方法论）\"><a href=\"#无穷小阶的比较（缺少比较的方法论）\" class=\"headerlink\" title=\"无穷小阶的比较（缺少比较的方法论）\"></a>无穷小阶的比较（缺少比较的方法论）</h3><ul>\n<li><p>怎么判断两个无穷小谁是谁的高阶无穷小</p>\n<script type=\"math/tex; mode=display\">\nif \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = 0 \\\\\n则 f 为 g的高阶无穷小  \\ \\ 记为 f = o(g(x))</script></li>\n<li><p>…..同阶无穷小</p>\n<script type=\"math/tex; mode=display\">\nif \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = C  \\ \\ \\ (c \\neq 0) \\\\\n则 f 为 g的同阶无穷小</script></li>\n<li><p>…..等价无穷小</p>\n<script type=\"math/tex; mode=display\">\nif \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = 1  \\\\\n则 f 为 g的等价无穷小</script></li>\n<li><p>…..k阶无穷小</p>\n<script type=\"math/tex; mode=display\">\nif \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)^k} = C  \\ \\ \\ (c \\neq 0) \\\\\n则 f 为 g的k阶无穷小</script></li>\n</ul>\n<h3 id=\"高阶无穷小的-运算-性质\"><a href=\"#高阶无穷小的-运算-性质\" class=\"headerlink\" title=\"高阶无穷小的(运算)性质\"></a>高阶无穷小的(运算)性质</h3><ul>\n<li>性质一：和式性质，无穷小的和的阶数等于和式中最小的阶，低阶吸收高阶。</li>\n</ul>\n<script type=\"math/tex; mode=display\">\no(x^m)\\pm o(x^n) = o(x^l) \\ \\ l = min(m,n);</script><ul>\n<li>性质二：乘系数性质</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nk \\ o(x^m) = o(x^m) \\ \\</script><ul>\n<li><p>性质三：乘法性质</p>\n<script type=\"math/tex; mode=display\">\no(x^m)\\times x^n = o(x^n)\\times x^m = o(x^n)\\times o(x^m)  = o(x^{m+n})</script></li>\n<li><p>性质四：除法性质</p>\n<script type=\"math/tex; mode=display\">\n\\frac{o(x^m)}{x^n} = o(x^{m-n}) \\ \\ (m \\gt n) \\\\\n\\frac{x^m}{o(x^n)} = o(x^{m-n}) \\ \\ (m \\gt n) \\ \\ (不成立)\\\\\n\\frac{o(x^m)}{o(x^n)} = o(x^{m-n}) \\ \\ (m \\gt n) \\ \\ (不成立)\\\\\n上述两个式子都不成立，符号代表着其实是一种范围式的记法，\\\\ \n如果出现在分母，那么必定能找到一个一个分母阶数大于分子阶数的项那么最后整个式子的结果就不确定。</script></li>\n</ul>\n<h3 id=\"无穷小相关的题目\"><a href=\"#无穷小相关的题目\" class=\"headerlink\" title=\"无穷小相关的题目\"></a>无穷小相关的题目</h3><p>给定两个无穷小的比值计算其中一个函数的极限</p>\n<p>千万不能想Taylor，题目中没有说明这个函数的可导性，Taylor需要知道该函数在该点n+1阶可导</p>\n<div class=\"tabs\" id=\"给定两个无穷小的比值计算其中一个函数的极限\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#给定两个无穷小的比值计算其中一个函数的极限-1\">给定两个无穷小的比值计算其中一个函数的极限 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#给定两个无穷小的比值计算其中一个函数的极限-2\">给定两个无穷小的比值计算其中一个函数的极限 2</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#给定两个无穷小的比值计算其中一个函数的极限-3\">给定两个无穷小的比值计算其中一个函数的极限 3</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"给定两个无穷小的比值计算其中一个函数的极限-1\"><script type=\"math/tex; mode=display\">\n\\lim _{x \\rightarrow 0} \\frac{\\ln \\left(1+x+\\frac{f(x)}{x}\\right)}{x}=3 \\text {, 则 } \\lim _{x \\rightarrow 0} \\frac{f(x)}{x^2}=</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"给定两个无穷小的比值计算其中一个函数的极限-2\"><script type=\"math/tex; mode=display\">\n\\text { 设 } \\lim _{x \\rightarrow 0} \\frac{\\ln (1-x)+x f(x)}{x^2}=0 \\text {, 则 } \\lim _{x \\rightarrow 0} \\frac{f(x)-1}{x}=</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"给定两个无穷小的比值计算其中一个函数的极限-3\"><p><strong>This is Tab 3.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"无穷大的定义\"><a href=\"#无穷大的定义\" class=\"headerlink\" title=\"无穷大的定义\"></a>无穷大的定义</h3><ul>\n<li><p>定义一：趋近一个确定的点的无穷大概念定义</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to x_0} f(x) = \\infty \\\\\n\\forall M \\gt 0 , \\ \\ \\exists \\delta \\gt 0, \\ \\ 使得0\\lt |x-x_0| \\lt \\delta \\ \\ \\  |f(x)| \\gt M</script></li>\n<li><p>定义二：趋近于无穷时候的无穷大</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to \\infty} f(x) = \\infty \\\\\n\\forall M \\gt 0 , \\ \\ \\exists X \\gt 0, \\ \\ 使得 |x| \\gt X \\ \\ \\  |f(x)| \\gt M</script></li>\n</ul>\n<h3 id=\"无穷大的性质\"><a href=\"#无穷大的性质\" class=\"headerlink\" title=\"无穷大的性质\"></a>无穷大的性质</h3><ol>\n<li><p>无穷大的倒数是无穷小、==非0无穷小的倒数（该函数不能区到0）【个人感觉有点不太严谨 或者我听错了，之后再看看】==</p>\n</li>\n<li><p>无穷大一定是无界量  但是 无界量不一定是无穷大 。</p>\n<script type=\"math/tex; mode=display\">\n无穷大的概念是一个连续的概念，根据定义必定存在一个区间，在这个区间内的任意取值都可以要多大有多大 \\\\\n无界量只要有一个点满足无穷条件就可以满足其定义 \\\\\nf(x) = \n\\begin{cases}\n\\infty , \\ \\ \\ x = x_0 \\\\\n0, \\ \\ \\ x \\neq x_0 \\\\\n\\end{cases} \\\\\n或者如下例子 \\\\\nf(x) = x\\sin(x) \\ \\ \\\\\nx = 2n\\pi + \\frac{\\pi}{2} \\\\\nx = 2n\\pi</script></li>\n</ol>\n<h3 id=\"无穷大阶的比较-（缺少比较的方法论）\"><a href=\"#无穷大阶的比较-（缺少比较的方法论）\" class=\"headerlink\" title=\"无穷大阶的比较 （缺少比较的方法论）\"></a>无穷大阶的比较 （缺少比较的方法论）</h3><p>这个部分需要先去硬性记忆一下。</p>\n<ul>\n<li>函数无穷大</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n常见函数的无穷大比较 x \\to +\\infty \\\\ \n\\ln(x)^{\\alpha} \\ll x^{\\beta} \\ll a^x \\ll x^x</script><ul>\n<li>数列无穷大<script type=\"math/tex; mode=display\">\n常见数列的无穷大比较 n\\to \\infty \\\\\n\\ln(n)^{\\alpha} \\ll n^{\\beta} \\ll a^n \\ll n! \\ll x^x</script></li>\n</ul>\n<h2 id=\"1-3洛必达法则（方法论、解题方法）\"><a href=\"#1-3洛必达法则（方法论、解题方法）\" class=\"headerlink\" title=\"1.3洛必达法则（方法论、解题方法）\"></a>1.3洛必达法则（方法论、解题方法）</h2><h3 id=\"洛必达法则的条件\"><a href=\"#洛必达法则的条件\" class=\"headerlink\" title=\"洛必达法则的条件\"></a>洛必达法则的条件</h3><p>满足这三个条件说明可以洛必达，但是如果洛必达求不出来那也不能说明函数极限不存在。</p>\n<ul>\n<li><p>一</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} [\\frac{f(x)}{g(x)}] \\ \\ 为 \\frac{0}{0} \\ \\ or \\ \\ \\frac{\\infty}{\\infty} \\ 类型的</script></li>\n<li><p>二</p>\n<script type=\"math/tex; mode=display\">\nf(x) \\ \\  and \\ \\ g(x) \\ \\ 可导 \\ \\ \\ (涉及到可导性判断)</script></li>\n<li><p>三</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\lim_{x \\to [..]} \\frac{f'(x)}{g'(x)} = 0 \\ \\ or \\ \\ \\infty 时才能说明原极限为0 或者\\infty; 如果不存在则不能说明原极限不存在。</script></li>\n</ul>\n<p>则</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\lim_{x \\to [..]} \\frac{f'(x)}{g'(x)} = \\lim_{x \\to [..]} \\frac{f''(x)}{g''(x)} = .......</script><p>经典错误：</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to \\infty} \\frac{x+\\sin(x)}{x} \\ \\</script><p>结论：洛必达求出来极限不存在不能说明当前极限不存在，得用其他方法求。</p>\n<h2 id=\"1-4等价代换\"><a href=\"#1-4等价代换\" class=\"headerlink\" title=\"1.4等价代换\"></a>1.4等价代换</h2><p>等价代换的实质是泰勒公式，是一个函数在0点的无穷次展开。</p>\n<ul>\n<li>X 趋近 0 的时候</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nx \\to 0 \\\\\n(1) \\ \\ \\ x \\sim \\sin(x) \\sim \\tan(x) \\sim \\arcsin(x) \\sim \\arctan(x) \\sim e^x-1 \\sim \\ln(x+1) \\\\\n(2)\\begin{cases}\n(1+x)^\\alpha -1 \\sim \\alpha x \\\\\n\\alpha ^x -1 \\sim x\\ln\\alpha\n\\end{cases} \\\\\n(3)\\begin{cases}\nx-\\sin(x) \\sim \\arcsin(x)-x \\sim \\frac{x^3}{6} \\\\\n\\tan(x)-x \\sim x-\\arctan(x) \\sim \\frac{x^3}{3} \\\\\n\\tan(x)-\\sin(x) \\sim \\arctan(x) - \\arcsin(x) \\sim \\frac{x^3}{2} \\\\\n\\end{cases}</script><ul>\n<li>等价代换求极限 注意点：<ul>\n<li>乘除可以代换</li>\n<li>加减不能随意代换，最简形式不抵消的时候可以代换 （个人建议直接使用taylor公式）</li>\n</ul>\n</li>\n</ul>\n<p>推广：</p>\n<script type=\"math/tex; mode=display\">\nx \\to 0 \\ \\ 可以推广为 \\ \\ [..] \\to 0 \\\\\n例如：\\ln(1+[..]) \\sim [..] \\ \\ 当 \\ \\ [..] \\to 0 时</script><h2 id=\"1-5-Taylor公式\"><a href=\"#1-5-Taylor公式\" class=\"headerlink\" title=\"1.5 Taylor公式\"></a>1.5 Taylor公式</h2><h3 id=\"Taylor公式定义\"><a href=\"#Taylor公式定义\" class=\"headerlink\" title=\"Taylor公式定义\"></a>Taylor公式定义</h3><script type=\"math/tex; mode=display\">\nf(x) 在 x = x_0 的某一个邻域内 n+1 阶可导则有如下 \\\\\nf(x) = f(x_0) + f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + \\frac{1}{3!}f'''(x_0)(x-x_0)^3 + .....+ \\frac{1}{n!}f^{n}(x_0)(x-x_0)^n + \n\\begin{cases}\n\\frac{1}{(n+1)!}f^{n+1}(\\zeta)(x-x_0)^{n+1}  \\ \\ \\ largrange 余项 \\\\\no(x-x_0)^n \\ \\ \\ Peano余项\n\\end{cases}</script><p>第n+1阶导数是一个余项形式</p>\n<h3 id=\"Maclaurin-（麦克劳林）公式\"><a href=\"#Maclaurin-（麦克劳林）公式\" class=\"headerlink\" title=\"Maclaurin （麦克劳林）公式\"></a>Maclaurin （麦克劳林）公式</h3><script type=\"math/tex; mode=display\">\nTaylor公式中当x_0 = 0时的取值。\\\\\nf(x) = f(0) + f'(0)(x-0) + \\frac{1}{2!}f''(0)(x-0)^2 + \\frac{1}{3!}f'''(0)(x-0)^3 + .....+ \\frac{1}{n!}f^{n}(0)(x-0)^n</script><h3 id=\"常见函数的一阶导数\"><a href=\"#常见函数的一阶导数\" class=\"headerlink\" title=\"常见函数的一阶导数\"></a>常见函数的一阶导数</h3><script type=\"math/tex; mode=display\">\n\\begin{align} \n&(1)   (C)^{\\prime}=0, \\\\\n&(2)   (x^\\mu)^{\\prime}=\\mu x^{\\mu-1}, \\\\\n&(3)   (\\sin x)^{\\prime}=\\cos x, \\\\\n&(4)   (\\cos x)^{\\prime}=-\\sin x, \\\\\n&(5)   (\\tan x)^{\\prime}=\\sec ^2 x, \\\\\n&(6)   (\\cot x)^{\\prime}=-\\csc ^2 x, \\\\\n&(7)   (\\sec x)^{\\prime}=\\sec x \\tan x, \\\\\n&(8)   (\\csc x)^{\\prime}=-\\csc x \\cot x, \\\\\n&(9)   (a^x)^{\\prime}=a^x \\ln a \\quad(a>0, a \\neq 1), \\\\\n&(10)  (\\mathrm{e}^x)^{\\prime}=\\mathrm{e}^x, \\\\ \n&(11)  (\\log _a )^{\\prime}=\\frac{1}{x \\ln a}(a>0, a \\neq 1), \\\\\n&(12)  (\\ln x)^{\\prime}=\\frac{1}{x}, \\\\\n&(13)  (\\arcsin x)^{\\prime}=\\frac{1}{\\sqrt{1-x^2}}, \\\\\n&(14)  (\\arccos x)^{\\prime}=-\\frac{1}{\\sqrt{1-x^2}}, \\\\\n&(15)  (\\arctan x)^{\\prime}=\\frac{1}{1+x^2}, \\\\\n&(16)  (\\operatorname{arccot} x)^{\\prime}=-\\frac{1}{1+x^2} \\\\\n\\end{align}</script><h3 id=\"常见函数的Taylor公式1\"><a href=\"#常见函数的Taylor公式1\" class=\"headerlink\" title=\"常见函数的Taylor公式1\"></a>常见函数的Taylor公式<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& \\mathrm{e}^{\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{1}{\\mathrm{n} !} \\mathrm{x}^{\\mathrm{n}}=1+\\mathrm{x}+\\frac{1}{2 !} \\mathrm{x}^2+\\cdots \\in(-\\infty,+\\infty) \\\\\n& \\sin \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{(2 \\mathrm{n}+1) !} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}-\\frac{1}{3 !} \\mathrm{x}^3+\\frac{1}{5 !} \\mathrm{x}^5+\\cdots, \\mathrm{x} \\in(-\\infty,+\\infty) \\\\\n& \\alpha^{x}  = \\sum_{n = 0}^{\\infty}\\frac{(\\ln\\alpha)^n}{n!}x^n = 1+\\ln\\alpha x +\\frac{(\\ln\\alpha)^2}{2!}x^2+\\frac{(\\ln\\alpha)^3}{3!} + \\cdots\\\\\n& \\arcsin \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(2 \\mathrm{n}) !}{4^{\\mathrm{n}}(\\mathrm{n} !)^2(2 \\mathrm{n}+1)} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}+\\frac{1}{6} \\mathrm{x}^3+\\frac{3}{40} \\mathrm{x}^5+\\frac{5}{112} \\mathrm{x}^7+\\frac{35}{1152} \\mathrm{x}^9+\\cdots+, \\mathrm{x} \\in(-1,1) \\\\\n& \\cos \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{(2 \\mathrm{n}) !} \\mathrm{x}^{2 \\mathrm{n}}=1-\\frac{1}{2 !} \\mathrm{x}^2+\\frac{1}{4 !} \\mathrm{x}^4+\\cdots, \\mathrm{x} \\in(-\\infty,+\\infty) \\\\\n& 注意：\\arcsin+\\arccos = \\frac{\\pi}{2} : \\\\\n& \\arccos \\mathrm{x} =  \\frac{\\pi}{2} - (\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(2 \\mathrm{n}) !}{4^{\\mathrm{n}}(\\mathrm{n} !)^2(2 \\mathrm{n}+1)} \\mathrm{x}^{2 \\mathrm{n}+1}) =  \\frac{\\pi}{2} - ( \\mathrm{x}+\\frac{1}{6} \\mathrm{x}^3+\\frac{3}{40} \\mathrm{x}^5+\\frac{5}{112} \\mathrm{x}^7+\\frac{35}{1152} \\mathrm{x}^9+\\cdots+ ) \\\\\n& \\ln (1+x)=\\sum_{n=0}^{\\infty} \\frac{(-1)^n}{n+1} x^{n+1}=x-\\frac{1}{2} x^2+\\frac{1}{3} x^3+\\cdots, x \\in(-1,1] \\\\\n& \\frac{1}{1-\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty} \\mathrm{x}^{\\mathrm{n}}=1+\\mathrm{x}+\\mathrm{x}^2+\\mathrm{x}^3+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& \\frac{1}{1+\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty}(-1)^{\\mathrm{n}} \\mathrm{x}^{\\mathrm{n}}=1-\\mathrm{x}+\\mathrm{x}^2-\\mathrm{x}^3+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& (1+\\mathrm{x})^\\alpha=1+\\sum_{\\mathrm{n}=1}^{\\infty} \\frac{\\alpha(\\alpha-1) \\cdots(\\alpha-\\mathrm{n}+1)}{\\mathrm{n} !} \\mathrm{x}^{\\mathrm{n}}=1+\\alpha \\mathrm{x}+\\frac{\\alpha(\\alpha-1)}{2 !} \\mathrm{x}^2+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& \\arctan \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{2 \\mathrm{n}+1} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}-\\frac{1}{3} \\mathrm{x}^3+\\frac{1}{5} \\mathrm{x}^5+\\cdots+\\mathrm{x} \\in[-1,1] \\\\\n\n& \\tan \\mathrm{x}=\\sum_{\\mathrm{n}=1}^{\\infty} \\frac{\\mathrm{B}_{2 \\mathrm{n}}(-4)^{\\mathrm{n}}\\left(1-4^{\\mathrm{n}}\\right)}{(2 \\mathrm{n}) !} \\mathrm{x}^{2 \\mathrm{n}-1}=\\mathrm{x}+\\frac{1}{3} \\mathrm{x}^3+\\frac{2}{15} \\mathrm{x}^5+\\frac{17}{315} \\mathrm{x}^7+\\frac{62}{2835} \\mathrm{x}^9+\\frac{1382}{155925} \\mathrm{x}^{11}+\\frac{21844}{6081075} \\mathrm{x}^{13}+... \\mathrm{x} \\in(-\\frac{\\pi}{2},\\frac{\\pi}{2}) \\\\\n&\n\\end{align}</script><p>推广：这里的taylor公式也可以推广为【..】=&gt; 0；类似复合函数的形式,注意函数极限中的两个式子的加减是否产生了抵消。</p>\n<h2 id=\"1-6-七类未定式\"><a href=\"#1-6-七类未定式\" class=\"headerlink\" title=\"1.6 七类未定式\"></a>1.6 七类未定式</h2><script type=\"math/tex; mode=display\">\n七类未定式：\n\\ \\ \\ \\frac{0}{0} \n\\ \\ \\ \\frac{\\infty}{\\infty} \n\\ \\ \\ 0\\times\\infty\n\\ \\ \\ \\infty - \\infty \n\\ \\ \\ 0^{\\infty}\n\\ \\ \\ \\infty^{0}\n\\ \\ \\ 1^{\\infty}</script><ul>\n<li><script type=\"math/tex; mode=display\">\\infty^{0}</script></li>\n</ul>\n<div class=\"tabs\" id=\"无穷的0次方例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#无穷的0次方例题-1\">无穷的0次方例题 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#无穷的0次方例题-2\">无穷的0次方例题 2</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#无穷的0次方例题-3\">无穷的0次方例题 3</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"无穷的0次方例题-1\"><script type=\"math/tex; mode=display\">\nI = \\lim_{x \\to \\infty}(e^{x^2}+x^3)^{\\frac{1}{x^2}}\\\\\n(1) \\ \\ I = \\lim_{x \\to \\infty} e^{\\frac{\\ln{(e^{x^2}+x^3})}{x^2}} \\Rightarrow 对于指数 \\frac{\\ln{(e^{x^2}+x^3)}}{x^2} 使用洛必达 \\\\\n(2) 观察到外层的指数和里面的某一项有可以相消的指数：化简\\Rightarrow \\lim_{x\\to \\infty} [e^{x^2}(1+\\frac{x^3}{e^{x^2}})]^{\\frac{1}{x^2}}</script><p>将函数指数化、对数化，将其变为一个<script type=\"math/tex\">\\frac{\\infty}{\\infty}</script>类型，然后研究指数，使用洛必达解出</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"无穷的0次方例题-2\"><p><strong>This is Tab 2.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"无穷的0次方例题-3\"><p><strong>This is Tab 3.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"Lagrange方法\"><a href=\"#Lagrange方法\" class=\"headerlink\" title=\"Lagrange方法\"></a>Lagrange方法</h3><script type=\"math/tex; mode=display\">\nf(a)-f(b) = f'(\\xi)(a-b)</script><p> 拉格朗日求函数极限的方法一定要注意 构造的函数的两个区间一定 </p>\n<h3 id=\"对数函数公式\"><a href=\"#对数函数公式\" class=\"headerlink\" title=\"对数函数公式\"></a>对数函数公式</h3><script type=\"math/tex; mode=display\">\n\\begin{cases}\n&恒等变形 \\ \\ \\ f(x) = e^{\\ln f(x)} = \\ln {e^{f(x)}} \\\\\n& 加法公式 \\ \\ \\ \\ln{a} + \\ln{b} = \\ln{ab} \\\\\n& 减法公式 \\ \\ \\ \\ln{a} - \\ln{b} = \\ln{\\frac{a}{b}} \\\\\n&换底公式 \\ \\ \\ \\log_a b = \\frac{\\ln{b}}{\\ln{a}} \\\\\n\\end{cases}</script><h3 id=\"三角函数公式2\"><a href=\"#三角函数公式2\" class=\"headerlink\" title=\"三角函数公式2\"></a>三角函数公式<sup><a href=\"#fn_2\" id=\"reffn_2\">2</a></sup></h3><h4 id=\"和差化积公式记忆口诀\"><a href=\"#和差化积公式记忆口诀\" class=\"headerlink\" title=\"和差化积公式记忆口诀\"></a>和差化积公式记忆口诀</h4><p>正加正，正在前，余减余，余并肩，正减正，余在前，余减余，负正弦。</p>\n<h3 id=\"解决七类未定式的方法论：\"><a href=\"#解决七类未定式的方法论：\" class=\"headerlink\" title=\"解决七类未定式的方法论：\"></a>解决七类未定式的方法论：</h3><ul>\n<li><p>三种：等价、洛必达、泰勒</p>\n</li>\n<li><p>三种：洛必达、同除最高次幂项（注意符号的问题）、抓大头</p>\n</li>\n<li><p>两种：将其化为第一种或者第二种方法 来做</p>\n</li>\n<li><p>三种：通分、有理化、倒代换</p>\n</li>\n<li><p>第五和第六中未定式：使用对数的公式化简</p>\n<blockquote>\n<p>tips (注意): <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"34.515ex\" height=\"2.646ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -919.6 15255.7 1169.6\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mo\"><path data-c=\"6C\" d=\"M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z\"></path><path data-c=\"69\" d=\"M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z\" transform=\"translate(278,0)\"></path><path data-c=\"6D\" d=\"M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z\" transform=\"translate(556,0)\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(1422,-150) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(572,0)\"><path data-c=\"2192\" d=\"M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1572,0)\"><g data-mml-node=\"mn\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(533,289) scale(0.707)\"><path data-c=\"2B\" d=\"M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z\"></path></g></g></g></g><g data-mml-node=\"msup\" transform=\"translate(3551.5,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(605,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D6FC\" d=\"M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z\"></path></g></g></g><g data-mml-node=\"msup\" transform=\"translate(4825.7,0)\"><g data-mml-node=\"mi\"><path data-c=\"6C\" d=\"M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z\"></path><path data-c=\"6E\" d=\"M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z\" transform=\"translate(278,0)\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(867,421.1) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D6FD\" d=\"M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z\"></path></g></g></g><g data-mml-node=\"mo\" transform=\"translate(6142.9,0)\"><path data-c=\"2061\" d=\"\"></path></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(6309.6,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(7159.4,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(8215.1,0)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(8715.1,0)\"><path data-c=\"2C\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(9159.8,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(9409.8,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mi\" transform=\"translate(9659.8,0)\"><path data-c=\"1D6FC\" d=\"M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(10299.8,0)\"><path data-c=\"2C\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(10744.5,0)\"><path data-c=\"1D6FD\" d=\"M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(11588.3,0)\"><path data-c=\"2208\" d=\"M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(12533,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(12922,0)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(13422,0)\"><path data-c=\"2C\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(13866.7,0)\"><path data-c=\"221E\" d=\"M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(14866.7,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"1-7-数列极限-（单调有界定理）\"><a href=\"#1-7-数列极限-（单调有界定理）\" class=\"headerlink\" title=\"1.7 数列极限 （单调有界定理）\"></a>1.7 数列极限 （单调有界定理）</h2><h3 id=\"重要不等式\"><a href=\"#重要不等式\" class=\"headerlink\" title=\"重要不等式\"></a>重要不等式</h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) \\sin(x) \\lt x \\lt \\tan(x) , x \\in(0,\\frac{\\pi}{2})   \\\\\n& (2) e^x \\lt 1+x, x \\neq 0 \\\\\n& (3) \\frac{x}{1+x} \\lt \\ln(1+x) \\lt x , x \\neq 0 \\ \\ and \\ \\ x \\in(-1,\\infty) \\\\\n\\end{align}</script><h3 id=\"单调有界定理的步骤\"><a href=\"#单调有界定理的步骤\" class=\"headerlink\" title=\"单调有界定理的步骤\"></a>单调有界定理的步骤</h3><ul>\n<li><p>放缩确定界（证明有界）</p>\n</li>\n<li><p>证明单调</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 做差 \\ \\ x_{n+1}-x_{n}   \\\\\n& (2) 做商 \\ \\ \\frac{x_{n+1}}{x_n} \\\\\n& (3) 求解函数的单调性 \\ \\ y = f(x)\n\\begin{cases}\nf'(x) \\gt 0 \n\\begin{cases}\nx_1 \\gt x_2 \\rightarrow \\ x_2 = f(x_1)>f(x_2) = x_3,即 x_2 \\gt x_3 以此类推,x_{n-1} \\gt x_{n} \\\\\nx_1 \\lt x_2 \\rightarrow \\ x_2 = f(x_1) \\lt f(x_2) = x_3,...., x_{n-1} \\lt x_{n}\n\\end{cases} \\\\\nf'(x) \\lt 0 \\ \\ 使用夹逼准则\n\\end{cases}\n\\\\\n\\end{align}</script></li>\n<li><p>两边做极限解方程求解最后的极限值</p>\n</li>\n</ul>\n<h2 id=\"1-8-数列极限（夹逼准则）\"><a href=\"#1-8-数列极限（夹逼准则）\" class=\"headerlink\" title=\"1.8 数列极限（夹逼准则）\"></a>1.8 数列极限（夹逼准则）</h2><p>难点在于如何构造夹逼的两个函数。</p>\n<script type=\"math/tex; mode=display\">\nx_n \\le y_n \\le z_n \\  and \\ \\lim_{n \\to \\infty} x_n = \\lim_{n \\to \\infty} y_n = A \\rightarrow \\lim_{n \\to \\infty} y_n = A</script><h2 id=\"1-9-定积分定义-（这个比较简单）\"><a href=\"#1-9-定积分定义-（这个比较简单）\" class=\"headerlink\" title=\"1.9 定积分定义 （这个比较简单）\"></a>1.9 定积分定义 （这个比较简单）</h2><p>夹逼准则和定积分定义有时候会搞混。</p>\n<h2 id=\"2-1-连续\"><a href=\"#2-1-连续\" class=\"headerlink\" title=\"2.1 连续\"></a>2.1 连续</h2><h3 id=\"连续的定义\"><a href=\"#连续的定义\" class=\"headerlink\" title=\"连续的定义\"></a>连续的定义</h3><p>连续、右连续、左连续</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 连续 \\ \\ \\ \\lim_{x \\to x_0} f(x) = f(x_0) \\\\\n& (2) 右连续 \\ \\ \\ \\lim_{x \\to x_0^+} f(x) = f(x_0)  \\\\\n& (3) 左连续 \\ \\ \\ \\lim_{x \\to x_0^-} f(x) = f(x_0)  \\\\\n\\end{align}</script><h3 id=\"连续函数的性质\"><a href=\"#连续函数的性质\" class=\"headerlink\" title=\"连续函数的性质\"></a>连续函数的性质</h3><p>基本初等函数：反、对、幂、指、三（反三角函数、对数函数、幂函数、指数函数、三角函数）</p>\n<p>初等函数：基本初等函数经过有限次四则运算或者复合 得到的函数</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 基本初等函数在其定义域内都连续\\\\\n& (2) 连续函数经过有限次的四则运算以及复合任然是连续的 \\\\\n& (3) 初等函数都是连续函数\\\\\n\\end{align}</script><h3 id=\"闭区间连续函数的性质（定理，一定是闭区间的、连续的）\"><a href=\"#闭区间连续函数的性质（定理，一定是闭区间的、连续的）\" class=\"headerlink\" title=\"闭区间连续函数的性质（定理，一定是闭区间的、连续的）\"></a>闭区间连续函数的性质（定理，一定是闭区间的、连续的）</h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 最值定理: 闭区间连续函数一定存在最大值M 最小值m，即 m \\le f(x) \\le M  \\\\\n& (1.1) 最值定理推论：有界定理【闭区间连续函数必定有界】\\\\\n& (2) 介值定理: 若f(x) ， x \\in[a,b] 则一定有 \\exists \\xi \\in [a,b], 使得 f(\\xi) = \\frac{f(a)+f(b)}{2} \\\\\n& (2.1) 介值定理推论: \\ \\forall x_1,x_2,x_3 \\dots x_n \\in[a,b] ,则有\\exists \\xi \\in[a,b] \\ \\ f(\\xi) = \\frac{f(x_1)+f(x_2)+\\dots +f(x_n)}{n}   \\\\\n& (3) 零点定理: 若 f(a)f(b) \\lt 0, 则\\exists \\xi \\in(a,b), f(\\xi) = 0 \\\\\n\\end{align}</script><div class=\"tabs\" id=\"例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#例题-1\">例题 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-2\">例题 2</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-3\">例题 3</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"例题-1\"><script type=\"math/tex; mode=display\">\n例：设 f(x) 在x \\in[a,b]上连续 and\\ \\ f(1) = f(0) \\ \\ \\ 证明: \\exists \\xi 使得 f(\\xi+\\frac{1}{4}) = f(\\xi)</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-2\"><p><strong>This is Tab 2.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-3\"><p><strong>This is Tab 3.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"2-2-间断点\"><a href=\"#2-2-间断点\" class=\"headerlink\" title=\"2.2 间断点\"></a>2.2 间断点</h2><h3 id=\"间断点的定义\"><a href=\"#间断点的定义\" class=\"headerlink\" title=\"间断点的定义\"></a>间断点的定义</h3><script type=\"math/tex; mode=display\">\nf(x)在某个（存在这样的去心邻域即可）\\mathring{U}(x_0)有定义,并且f(x)在x_0处不连续（连续的定义见上文）。</script><h3 id=\"间断点的分类\"><a href=\"#间断点的分类\" class=\"headerlink\" title=\"间断点的分类\"></a>间断点的分类</h3><ul>\n<li>左右极限均存在的<ul>\n<li>可去间断点，左极限=右极限，但是不等于点处的值。（或者该点处没有定义）</li>\n<li>跳跃间断点</li>\n</ul>\n</li>\n<li>左右极限至少有一个不存在的<ul>\n<li>无穷间断点</li>\n<li>振荡间断点</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h1><blockquote id=\"fn_1\">\n<sup>1</sup>.  <a href=\"https://zhuanlan.zhihu.com/p/348178130\">Taylor多项式/Taylor公式 - 知乎 (zhihu.com)</a> ↩<a href=\"https://blog.csdn.net/Infinity_07/article/details/113830088\">(10条消息) 常见函数泰勒公式展开（清晰）<em>常见的泰勒展开公式大全</em>陌雨’的博客-CSDN博客</a><a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> ↩</a>\n</blockquote>\n<blockquote id=\"fn_2\">\n<sup>2</sup>. <a href=\"https://zhuanlan.zhihu.com/p/89073536\">考研数学的初等函数变换公式——三角相关 - 知乎 (zhihu.com)</a><a href=\"#reffn_2\" title=\"Jump back to footnote [2] in the text.\"> ↩</a>\n</blockquote>\n<blockquote id=\"fn_3\">\n<sup>3</sup>. <a href=\"https://www.zhihu.com/question/26383384\">(18 封私信 / 4 条消息) 有极限的数列是有界的怎么理解? - 知乎 (zhihu.com)</a><a href=\"#reffn_3\" title=\"Jump back to footnote [3] in the text.\"> ↩</a>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-02</p>\n</div></div><div class=\"timeline-item-content\"><p>整理姜晓千数学第一讲 函数的极限连续</p>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-09</p>\n</div></div><div class=\"timeline-item-content\"><p>整理姜晓千数学第一讲 </p>\n<ul>\n<li>无穷大、无穷小</li>\n<li>洛必达法则</li>\n<li>等价代换</li>\n<li>Taylor公式</li>\n<li>复习之前的概念</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-10</p>\n</div></div><div class=\"timeline-item-content\"><p>继续昨天的任务</p>\n<ul>\n<li>完善了几个常见的函数的taylor展开</li>\n<li>复习了求解函数极限中的七类未定式</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-11</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>数列极限的求解方法<ul>\n<li>单调有界定理</li>\n<li>夹逼准则</li>\n<li>定积分定义</li>\n</ul>\n</li>\n<li>连续和间断</li>\n<li>导数<ul>\n<li>导数的定义</li>\n<li>导数的性质</li>\n</ul>\n</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-17</p>\n</div></div><div class=\"timeline-item-content\"><p>增添了几道例题。</p>\n<ul>\n<li>[x] 刷660 前45题</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"函数极限连续\"><a href=\"#函数极限连续\" class=\"headerlink\" title=\"函数极限连续\"></a>函数极限连续</h1><p>微积分之前先==化简==</p>\n<ul>\n<li>拆、提、同除、同乘</li>\n<li>对数公式</li>\n<li>三角公式</li>\n</ul>\n<h2 id=\"1-1函数\"><a href=\"#1-1函数\" class=\"headerlink\" title=\"1.1函数\"></a>1.1函数</h2><ul>\n<li>重要内容：</li>\n</ul>\n<p>单调性</p>\n<p>有界性</p>\n<p>奇偶性  第三章积分  </p>\n<p>周期性  第三章积分</p>\n<h3 id=\"极限-（大题、小题都有）\"><a href=\"#极限-（大题、小题都有）\" class=\"headerlink\" title=\"极限 （大题、小题都有）\"></a>极限 （大题、小题都有）</h3><p>八个方法：</p>\n<ul>\n<li>求解函数极限<ul>\n<li>洛必达 （简单函数适合洛必达）【简单函数：容易求导，越求导越简单的】</li>\n<li>==导数定义== （牛顿最先提出 一阶 二阶  第二章会讲到）</li>\n<li>等价代换 （3组）</li>\n<li>taylor公式 （8个常见的）</li>\n<li>拉格朗日  （第二章内容  ）</li>\n</ul>\n</li>\n<li>数列极限<ul>\n<li>单调有界</li>\n<li>夹逼准则</li>\n<li>定积分定义 （第三章 黎曼定积分定义）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数列极限的概念\"><a href=\"#数列极限的概念\" class=\"headerlink\" title=\"数列极限的概念\"></a>数列极限的概念</h3><p>数列极限的定义：’$ \\lim<em>{ n \\to \\infty} a</em>{n} = a  $’  Cauthy提出的 数列极限的定义。</p>\n<script type=\"math/tex; mode=display\">\n对于 \\forall \\epsilon \\gt 0 \\ \\   \\exists N \\gt 0 \\ \\ \\ 当 n \\gt N \\ 时 \\ |a_{n}-a| \\lt \\epsilon</script><p>数列机芯啊描述了这个数列在趋向于无穷的时候函数的逼近值。</p>\n<blockquote>\n<p>tips: </p>\n<p>在柯西的定义中<script type=\"math/tex\">|a_{n}-a| \\le \\epsilon</script> 也是可以的。</p>\n<p>同理：以下变形也是可以的：</p>\n<ul>\n<li><script type=\"math/tex; mode=display\">|a_{n}-a| \\le 10\\epsilon</script></li>\n<li><script type=\"math/tex; mode=display\">|a_{n}-a| \\le \\frac{1}{10}\\epsilon</script></li>\n</ul>\n<p>总结：只要在定义中保证数列的无穷处和目标值a要多近有多近就可以。</p>\n</blockquote>\n<h3 id=\"数列极限的充要条件\"><a href=\"#数列极限的充要条件\" class=\"headerlink\" title=\"数列极限的充要条件\"></a>数列极限的充要条件</h3><script type=\"math/tex; mode=display\">\n在Cauthy对数列极限的定义中 \\\\\n....(极限定义)... \\iff对于\\forall a_n 中的任意子列 b_n \\ \\ \\lim_{n\\rightarrow \\infty} b_n = a</script><p>注意！要是后推前必须要说明所有的子列的极限都是相等的才能推导出 Cauthy极限的定义。</p>\n<p>（所有）子列极限都相等</p>\n<h3 id=\"数列极限的性质\"><a href=\"#数列极限的性质\" class=\"headerlink\" title=\"数列极限的性质\"></a>数列极限的性质</h3><ul>\n<li>唯一性：</li>\n<li>全局有界性：数列有极限必定有界，但是数列有界不一定有极限<sup><a href=\"#fn_3\" id=\"reffn_3\">3</a></sup></li>\n</ul>\n<script type=\"math/tex; mode=display\">\n若数a_n的极限是a \\ 那么 必定\\forall \\epsilon \\gt 0 \\ \\   \\exists N \\gt 0 \\ \\ \\ 当 n \\gt N \\ 时 \\ |a_{n}-a| \\lt \\epsilon \\\\\n也是就是说在n大于一个比较大的数字之后 a_n 的所有的值都会在一个很小的范围内，而且N之前的取值也都是有界的，所以数列整体有界</script><ul>\n<li>局部保号性  (极限不能等于0)；</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n假设\\lim_{n \\to \\infty} a_n = a \\gt 0 \\ \\ \\  则 \\exists N 当n \\gt N \\ \\  时 a_n \\gt 0</script><h3 id=\"函数极限的概念\"><a href=\"#函数极限的概念\" class=\"headerlink\" title=\"函数极限的概念\"></a>函数极限的概念</h3><p>函数极限的定义：两个大定义 和六个小定义 (x-x0不能等于0  因为函数可能在x0没有定义)</p>\n<script type=\"math/tex; mode=display\">\n当x\\to x_0时 \\\\\n(1) \\lim_{x \\to x_0} f(x) = A :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ 0\\lt |x-x_0| \\lt \\delta \\ 时  \\ \\ |f(x)-A| \\lt \\epsilon \\\\\n(2)\\lim_{x \\to x_0^+} f(x) = A  :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ 0\\lt x-x_0 \\lt \\delta \\ 时 \\ \\     |f(x)-A| \\lt \\epsilon \\\\\n(3) \\lim_{x \\to x_0^-} f(x) = A :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists \\delta \\gt 0 \\ 使得当x \\ \\ \\ -\\delta \\lt x-x_0 \\lt 0 \\ 时 \\ \\ |f(x)-A| \\lt \\epsilon</script><p>上述的三个变形代表了不同的趋近情况 2、3分别时左趋近和右趋近时候的定义</p>\n<script type=\"math/tex; mode=display\">\n当x \\to \\infty时 \\\\\n(1)\\lim_{x \\to \\infty} f(x) = A  :\\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ |x| \\gt X \\ 时 \\ \\     |f(x)-A| \\lt \\epsilon \\\\\n(2)\\lim_{x \\to +\\infty} f(x) = A  : \\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ x \\gt X \\ 时 \\ \\     |f(x)-A| \\lt \\epsilon \\\\\n(3)\\lim_{x \\to -\\infty} f(x) = A  : \\ \\ \\ \\ for \\ \\forall \\epsilon \\gt0 \\ \\ \\exists X \\gt 0 \\ 使得当x \\ \\ \\ x \\lt -X \\ 时 \\ \\     |f(x)-A| \\lt \\epsilon</script><h3 id=\"函数极限的充要条件-（感觉有点没有用）\"><a href=\"#函数极限的充要条件-（感觉有点没有用）\" class=\"headerlink\" title=\"函数极限的充要条件 （感觉有点没有用）\"></a>函数极限的充要条件 （感觉有点没有用）</h3><p>描述：函数的极限存在那么左趋近和右趋近都要相等</p>\n<p>函数的趋近无穷极限存在那么同理趋近正无穷和负无穷也都要相等</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to x_0} f(x) = A \\ \\iff \\ \\lim_{x \\to x_0^+} f(x) = \\lim_{x \\to x_0^-}f(x) = A  \\\\\n\\lim_{x \\to \\infty} f(x) = A \\ \\iff \\ \\lim_{x \\to +\\infty} f(x) = \\lim_{x \\to -\\infty}f(x) = A</script><h3 id=\"函数极限的性质\"><a href=\"#函数极限的性质\" class=\"headerlink\" title=\"函数极限的性质\"></a>函数极限的性质</h3><p>若函数存在极限则有如下的性质。</p>\n<ul>\n<li>唯一性  和数列极限的唯一性相似</li>\n<li>局部有界性</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n设\\lim_{x \\to x_0} f(x) 存在，则 \\ \\ \\exists \\delta \\gt 0 \\ \\ \\exists M \\gt 0 \\ \\  使得当 \\ \\ 0 \\lt |x-x_0| \\lt \\delta \\ (局部) 时 \\ \\  |f(x)| \\le M \\ \\ (有界)</script><blockquote>\n<p>tips:</p>\n<p>对于上述的有点不同的六个定义，局部有界性应该是修改相应的限制局部的区间。</p>\n</blockquote>\n<ul>\n<li>局部保号性  极限不能等于0</li>\n<li>推论</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n设f(x) \\ge 0 \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge 0 \\\\\n设f(x) \\gt 0 \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge 0</script><p>这个推论：极限和函数的上界\\下界之间的关系</p>\n<script type=\"math/tex; mode=display\">\n若f(x) \\ge k \\ \\ 是否有 \\lim_{x \\to x_0} f(x) =  A \\ge k \\ \\ ? \\ \\ (成立！) \\\\\n若f(x) \\ge k \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge k \\\\\n若f(x) \\gt k \\ \\ 则 \\lim_{x \\to x_0} f(x) =  A \\ge k</script><h3 id=\"函数极限的四则运算\"><a href=\"#函数极限的四则运算\" class=\"headerlink\" title=\"函数极限的四则运算\"></a>函数极限的四则运算</h3><script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} f(x) = A \\ \\ \\ \\lim_{x \\to [..]} f(x) = B \\\\\nsum:\\lim_{x \\to [..]} [f(x)\\pm g(x)] = A\\pm B   \\\\\nmulti: \\lim_{x \\to [..]} f(x) \\times g(x) = A\\times B \\\\\ndiv: \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\frac{A}{B}</script><p>推论：（提出非0因子）</p>\n<script type=\"math/tex; mode=display\">\n假设 \\lim_{x \\to [..]} f(x) = A \\neq 0, \\ \\ 则 \\lim_{x \\to [..]} f(x)g(x) = A\\lim_{x \\to [..]} g(x)</script><p>注意 ：</p>\n<p>A一定是一个非0因子！每个极限都要存在，分母极限不为0。</p>\n<h2 id=\"1-2无穷小和无穷大\"><a href=\"#1-2无穷小和无穷大\" class=\"headerlink\" title=\"1.2无穷小和无穷大\"></a>1.2无穷小和无穷大</h2><h3 id=\"无穷小的定义\"><a href=\"#无穷小的定义\" class=\"headerlink\" title=\"无穷小的定义\"></a>无穷小的定义</h3><p>极限为0 的函数</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} f(x) = 0 \\ \\ 则称f(x)为x \\to [..] 时的无穷小。</script><h3 id=\"无穷小的性质\"><a href=\"#无穷小的性质\" class=\"headerlink\" title=\"无穷小的性质\"></a>无穷小的性质</h3><ol>\n<li>有限个无穷小的和还是无穷小</li>\n<li>有限个无穷小的积还是无穷小</li>\n<li>无穷小乘有界量为无穷小</li>\n</ol>\n<h3 id=\"无穷小阶的比较（缺少比较的方法论）\"><a href=\"#无穷小阶的比较（缺少比较的方法论）\" class=\"headerlink\" title=\"无穷小阶的比较（缺少比较的方法论）\"></a>无穷小阶的比较（缺少比较的方法论）</h3><ul>\n<li><p>怎么判断两个无穷小谁是谁的高阶无穷小</p>\n<script type=\"math/tex; mode=display\">\nif \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = 0 \\\\\n则 f 为 g的高阶无穷小  \\ \\ 记为 f = o(g(x))</script></li>\n<li><p>…..同阶无穷小</p>\n<script type=\"math/tex; mode=display\">\nif \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = C  \\ \\ \\ (c \\neq 0) \\\\\n则 f 为 g的同阶无穷小</script></li>\n<li><p>…..等价无穷小</p>\n<script type=\"math/tex; mode=display\">\nif \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = 1  \\\\\n则 f 为 g的等价无穷小</script></li>\n<li><p>…..k阶无穷小</p>\n<script type=\"math/tex; mode=display\">\nif \\ \\ \\lim_{x \\to [..]} \\frac{f(x)}{g(x)^k} = C  \\ \\ \\ (c \\neq 0) \\\\\n则 f 为 g的k阶无穷小</script></li>\n</ul>\n<h3 id=\"高阶无穷小的-运算-性质\"><a href=\"#高阶无穷小的-运算-性质\" class=\"headerlink\" title=\"高阶无穷小的(运算)性质\"></a>高阶无穷小的(运算)性质</h3><ul>\n<li>性质一：和式性质，无穷小的和的阶数等于和式中最小的阶，低阶吸收高阶。</li>\n</ul>\n<script type=\"math/tex; mode=display\">\no(x^m)\\pm o(x^n) = o(x^l) \\ \\ l = min(m,n);</script><ul>\n<li>性质二：乘系数性质</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nk \\ o(x^m) = o(x^m) \\ \\</script><ul>\n<li><p>性质三：乘法性质</p>\n<script type=\"math/tex; mode=display\">\no(x^m)\\times x^n = o(x^n)\\times x^m = o(x^n)\\times o(x^m)  = o(x^{m+n})</script></li>\n<li><p>性质四：除法性质</p>\n<script type=\"math/tex; mode=display\">\n\\frac{o(x^m)}{x^n} = o(x^{m-n}) \\ \\ (m \\gt n) \\\\\n\\frac{x^m}{o(x^n)} = o(x^{m-n}) \\ \\ (m \\gt n) \\ \\ (不成立)\\\\\n\\frac{o(x^m)}{o(x^n)} = o(x^{m-n}) \\ \\ (m \\gt n) \\ \\ (不成立)\\\\\n上述两个式子都不成立，符号代表着其实是一种范围式的记法，\\\\ \n如果出现在分母，那么必定能找到一个一个分母阶数大于分子阶数的项那么最后整个式子的结果就不确定。</script></li>\n</ul>\n<h3 id=\"无穷小相关的题目\"><a href=\"#无穷小相关的题目\" class=\"headerlink\" title=\"无穷小相关的题目\"></a>无穷小相关的题目</h3><p>给定两个无穷小的比值计算其中一个函数的极限</p>\n<p>千万不能想Taylor，题目中没有说明这个函数的可导性，Taylor需要知道该函数在该点n+1阶可导</p>\n<div class=\"tabs\" id=\"给定两个无穷小的比值计算其中一个函数的极限\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#给定两个无穷小的比值计算其中一个函数的极限-1\">给定两个无穷小的比值计算其中一个函数的极限 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#给定两个无穷小的比值计算其中一个函数的极限-2\">给定两个无穷小的比值计算其中一个函数的极限 2</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#给定两个无穷小的比值计算其中一个函数的极限-3\">给定两个无穷小的比值计算其中一个函数的极限 3</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"给定两个无穷小的比值计算其中一个函数的极限-1\"><script type=\"math/tex; mode=display\">\n\\lim _{x \\rightarrow 0} \\frac{\\ln \\left(1+x+\\frac{f(x)}{x}\\right)}{x}=3 \\text {, 则 } \\lim _{x \\rightarrow 0} \\frac{f(x)}{x^2}=</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"给定两个无穷小的比值计算其中一个函数的极限-2\"><script type=\"math/tex; mode=display\">\n\\text { 设 } \\lim _{x \\rightarrow 0} \\frac{\\ln (1-x)+x f(x)}{x^2}=0 \\text {, 则 } \\lim _{x \\rightarrow 0} \\frac{f(x)-1}{x}=</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"给定两个无穷小的比值计算其中一个函数的极限-3\"><p><strong>This is Tab 3.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"无穷大的定义\"><a href=\"#无穷大的定义\" class=\"headerlink\" title=\"无穷大的定义\"></a>无穷大的定义</h3><ul>\n<li><p>定义一：趋近一个确定的点的无穷大概念定义</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to x_0} f(x) = \\infty \\\\\n\\forall M \\gt 0 , \\ \\ \\exists \\delta \\gt 0, \\ \\ 使得0\\lt |x-x_0| \\lt \\delta \\ \\ \\  |f(x)| \\gt M</script></li>\n<li><p>定义二：趋近于无穷时候的无穷大</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to \\infty} f(x) = \\infty \\\\\n\\forall M \\gt 0 , \\ \\ \\exists X \\gt 0, \\ \\ 使得 |x| \\gt X \\ \\ \\  |f(x)| \\gt M</script></li>\n</ul>\n<h3 id=\"无穷大的性质\"><a href=\"#无穷大的性质\" class=\"headerlink\" title=\"无穷大的性质\"></a>无穷大的性质</h3><ol>\n<li><p>无穷大的倒数是无穷小、==非0无穷小的倒数（该函数不能区到0）【个人感觉有点不太严谨 或者我听错了，之后再看看】==</p>\n</li>\n<li><p>无穷大一定是无界量  但是 无界量不一定是无穷大 。</p>\n<script type=\"math/tex; mode=display\">\n无穷大的概念是一个连续的概念，根据定义必定存在一个区间，在这个区间内的任意取值都可以要多大有多大 \\\\\n无界量只要有一个点满足无穷条件就可以满足其定义 \\\\\nf(x) = \n\\begin{cases}\n\\infty , \\ \\ \\ x = x_0 \\\\\n0, \\ \\ \\ x \\neq x_0 \\\\\n\\end{cases} \\\\\n或者如下例子 \\\\\nf(x) = x\\sin(x) \\ \\ \\\\\nx = 2n\\pi + \\frac{\\pi}{2} \\\\\nx = 2n\\pi</script></li>\n</ol>\n<h3 id=\"无穷大阶的比较-（缺少比较的方法论）\"><a href=\"#无穷大阶的比较-（缺少比较的方法论）\" class=\"headerlink\" title=\"无穷大阶的比较 （缺少比较的方法论）\"></a>无穷大阶的比较 （缺少比较的方法论）</h3><p>这个部分需要先去硬性记忆一下。</p>\n<ul>\n<li>函数无穷大</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n常见函数的无穷大比较 x \\to +\\infty \\\\ \n\\ln(x)^{\\alpha} \\ll x^{\\beta} \\ll a^x \\ll x^x</script><ul>\n<li>数列无穷大<script type=\"math/tex; mode=display\">\n常见数列的无穷大比较 n\\to \\infty \\\\\n\\ln(n)^{\\alpha} \\ll n^{\\beta} \\ll a^n \\ll n! \\ll x^x</script></li>\n</ul>\n<h2 id=\"1-3洛必达法则（方法论、解题方法）\"><a href=\"#1-3洛必达法则（方法论、解题方法）\" class=\"headerlink\" title=\"1.3洛必达法则（方法论、解题方法）\"></a>1.3洛必达法则（方法论、解题方法）</h2><h3 id=\"洛必达法则的条件\"><a href=\"#洛必达法则的条件\" class=\"headerlink\" title=\"洛必达法则的条件\"></a>洛必达法则的条件</h3><p>满足这三个条件说明可以洛必达，但是如果洛必达求不出来那也不能说明函数极限不存在。</p>\n<ul>\n<li><p>一</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} [\\frac{f(x)}{g(x)}] \\ \\ 为 \\frac{0}{0} \\ \\ or \\ \\ \\frac{\\infty}{\\infty} \\ 类型的</script></li>\n<li><p>二</p>\n<script type=\"math/tex; mode=display\">\nf(x) \\ \\  and \\ \\ g(x) \\ \\ 可导 \\ \\ \\ (涉及到可导性判断)</script></li>\n<li><p>三</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\lim_{x \\to [..]} \\frac{f'(x)}{g'(x)} = 0 \\ \\ or \\ \\ \\infty 时才能说明原极限为0 或者\\infty; 如果不存在则不能说明原极限不存在。</script></li>\n</ul>\n<p>则</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to [..]} \\frac{f(x)}{g(x)} = \\lim_{x \\to [..]} \\frac{f'(x)}{g'(x)} = \\lim_{x \\to [..]} \\frac{f''(x)}{g''(x)} = .......</script><p>经典错误：</p>\n<script type=\"math/tex; mode=display\">\n\\lim_{x \\to \\infty} \\frac{x+\\sin(x)}{x} \\ \\</script><p>结论：洛必达求出来极限不存在不能说明当前极限不存在，得用其他方法求。</p>\n<h2 id=\"1-4等价代换\"><a href=\"#1-4等价代换\" class=\"headerlink\" title=\"1.4等价代换\"></a>1.4等价代换</h2><p>等价代换的实质是泰勒公式，是一个函数在0点的无穷次展开。</p>\n<ul>\n<li>X 趋近 0 的时候</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nx \\to 0 \\\\\n(1) \\ \\ \\ x \\sim \\sin(x) \\sim \\tan(x) \\sim \\arcsin(x) \\sim \\arctan(x) \\sim e^x-1 \\sim \\ln(x+1) \\\\\n(2)\\begin{cases}\n(1+x)^\\alpha -1 \\sim \\alpha x \\\\\n\\alpha ^x -1 \\sim x\\ln\\alpha\n\\end{cases} \\\\\n(3)\\begin{cases}\nx-\\sin(x) \\sim \\arcsin(x)-x \\sim \\frac{x^3}{6} \\\\\n\\tan(x)-x \\sim x-\\arctan(x) \\sim \\frac{x^3}{3} \\\\\n\\tan(x)-\\sin(x) \\sim \\arctan(x) - \\arcsin(x) \\sim \\frac{x^3}{2} \\\\\n\\end{cases}</script><ul>\n<li>等价代换求极限 注意点：<ul>\n<li>乘除可以代换</li>\n<li>加减不能随意代换，最简形式不抵消的时候可以代换 （个人建议直接使用taylor公式）</li>\n</ul>\n</li>\n</ul>\n<p>推广：</p>\n<script type=\"math/tex; mode=display\">\nx \\to 0 \\ \\ 可以推广为 \\ \\ [..] \\to 0 \\\\\n例如：\\ln(1+[..]) \\sim [..] \\ \\ 当 \\ \\ [..] \\to 0 时</script><h2 id=\"1-5-Taylor公式\"><a href=\"#1-5-Taylor公式\" class=\"headerlink\" title=\"1.5 Taylor公式\"></a>1.5 Taylor公式</h2><h3 id=\"Taylor公式定义\"><a href=\"#Taylor公式定义\" class=\"headerlink\" title=\"Taylor公式定义\"></a>Taylor公式定义</h3><script type=\"math/tex; mode=display\">\nf(x) 在 x = x_0 的某一个邻域内 n+1 阶可导则有如下 \\\\\nf(x) = f(x_0) + f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + \\frac{1}{3!}f'''(x_0)(x-x_0)^3 + .....+ \\frac{1}{n!}f^{n}(x_0)(x-x_0)^n + \n\\begin{cases}\n\\frac{1}{(n+1)!}f^{n+1}(\\zeta)(x-x_0)^{n+1}  \\ \\ \\ largrange 余项 \\\\\no(x-x_0)^n \\ \\ \\ Peano余项\n\\end{cases}</script><p>第n+1阶导数是一个余项形式</p>\n<h3 id=\"Maclaurin-（麦克劳林）公式\"><a href=\"#Maclaurin-（麦克劳林）公式\" class=\"headerlink\" title=\"Maclaurin （麦克劳林）公式\"></a>Maclaurin （麦克劳林）公式</h3><script type=\"math/tex; mode=display\">\nTaylor公式中当x_0 = 0时的取值。\\\\\nf(x) = f(0) + f'(0)(x-0) + \\frac{1}{2!}f''(0)(x-0)^2 + \\frac{1}{3!}f'''(0)(x-0)^3 + .....+ \\frac{1}{n!}f^{n}(0)(x-0)^n</script><h3 id=\"常见函数的一阶导数\"><a href=\"#常见函数的一阶导数\" class=\"headerlink\" title=\"常见函数的一阶导数\"></a>常见函数的一阶导数</h3><script type=\"math/tex; mode=display\">\n\\begin{align} \n&(1)   (C)^{\\prime}=0, \\\\\n&(2)   (x^\\mu)^{\\prime}=\\mu x^{\\mu-1}, \\\\\n&(3)   (\\sin x)^{\\prime}=\\cos x, \\\\\n&(4)   (\\cos x)^{\\prime}=-\\sin x, \\\\\n&(5)   (\\tan x)^{\\prime}=\\sec ^2 x, \\\\\n&(6)   (\\cot x)^{\\prime}=-\\csc ^2 x, \\\\\n&(7)   (\\sec x)^{\\prime}=\\sec x \\tan x, \\\\\n&(8)   (\\csc x)^{\\prime}=-\\csc x \\cot x, \\\\\n&(9)   (a^x)^{\\prime}=a^x \\ln a \\quad(a>0, a \\neq 1), \\\\\n&(10)  (\\mathrm{e}^x)^{\\prime}=\\mathrm{e}^x, \\\\ \n&(11)  (\\log _a )^{\\prime}=\\frac{1}{x \\ln a}(a>0, a \\neq 1), \\\\\n&(12)  (\\ln x)^{\\prime}=\\frac{1}{x}, \\\\\n&(13)  (\\arcsin x)^{\\prime}=\\frac{1}{\\sqrt{1-x^2}}, \\\\\n&(14)  (\\arccos x)^{\\prime}=-\\frac{1}{\\sqrt{1-x^2}}, \\\\\n&(15)  (\\arctan x)^{\\prime}=\\frac{1}{1+x^2}, \\\\\n&(16)  (\\operatorname{arccot} x)^{\\prime}=-\\frac{1}{1+x^2} \\\\\n\\end{align}</script><h3 id=\"常见函数的Taylor公式1\"><a href=\"#常见函数的Taylor公式1\" class=\"headerlink\" title=\"常见函数的Taylor公式1\"></a>常见函数的Taylor公式<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& \\mathrm{e}^{\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{1}{\\mathrm{n} !} \\mathrm{x}^{\\mathrm{n}}=1+\\mathrm{x}+\\frac{1}{2 !} \\mathrm{x}^2+\\cdots \\in(-\\infty,+\\infty) \\\\\n& \\sin \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{(2 \\mathrm{n}+1) !} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}-\\frac{1}{3 !} \\mathrm{x}^3+\\frac{1}{5 !} \\mathrm{x}^5+\\cdots, \\mathrm{x} \\in(-\\infty,+\\infty) \\\\\n& \\alpha^{x}  = \\sum_{n = 0}^{\\infty}\\frac{(\\ln\\alpha)^n}{n!}x^n = 1+\\ln\\alpha x +\\frac{(\\ln\\alpha)^2}{2!}x^2+\\frac{(\\ln\\alpha)^3}{3!} + \\cdots\\\\\n& \\arcsin \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(2 \\mathrm{n}) !}{4^{\\mathrm{n}}(\\mathrm{n} !)^2(2 \\mathrm{n}+1)} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}+\\frac{1}{6} \\mathrm{x}^3+\\frac{3}{40} \\mathrm{x}^5+\\frac{5}{112} \\mathrm{x}^7+\\frac{35}{1152} \\mathrm{x}^9+\\cdots+, \\mathrm{x} \\in(-1,1) \\\\\n& \\cos \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{(2 \\mathrm{n}) !} \\mathrm{x}^{2 \\mathrm{n}}=1-\\frac{1}{2 !} \\mathrm{x}^2+\\frac{1}{4 !} \\mathrm{x}^4+\\cdots, \\mathrm{x} \\in(-\\infty,+\\infty) \\\\\n& 注意：\\arcsin+\\arccos = \\frac{\\pi}{2} : \\\\\n& \\arccos \\mathrm{x} =  \\frac{\\pi}{2} - (\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(2 \\mathrm{n}) !}{4^{\\mathrm{n}}(\\mathrm{n} !)^2(2 \\mathrm{n}+1)} \\mathrm{x}^{2 \\mathrm{n}+1}) =  \\frac{\\pi}{2} - ( \\mathrm{x}+\\frac{1}{6} \\mathrm{x}^3+\\frac{3}{40} \\mathrm{x}^5+\\frac{5}{112} \\mathrm{x}^7+\\frac{35}{1152} \\mathrm{x}^9+\\cdots+ ) \\\\\n& \\ln (1+x)=\\sum_{n=0}^{\\infty} \\frac{(-1)^n}{n+1} x^{n+1}=x-\\frac{1}{2} x^2+\\frac{1}{3} x^3+\\cdots, x \\in(-1,1] \\\\\n& \\frac{1}{1-\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty} \\mathrm{x}^{\\mathrm{n}}=1+\\mathrm{x}+\\mathrm{x}^2+\\mathrm{x}^3+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& \\frac{1}{1+\\mathrm{x}}=\\sum_{\\mathrm{n}=0}^{\\infty}(-1)^{\\mathrm{n}} \\mathrm{x}^{\\mathrm{n}}=1-\\mathrm{x}+\\mathrm{x}^2-\\mathrm{x}^3+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& (1+\\mathrm{x})^\\alpha=1+\\sum_{\\mathrm{n}=1}^{\\infty} \\frac{\\alpha(\\alpha-1) \\cdots(\\alpha-\\mathrm{n}+1)}{\\mathrm{n} !} \\mathrm{x}^{\\mathrm{n}}=1+\\alpha \\mathrm{x}+\\frac{\\alpha(\\alpha-1)}{2 !} \\mathrm{x}^2+\\cdots, \\mathrm{x} \\in(-1,1) \\\\\n& \\arctan \\mathrm{x}=\\sum_{\\mathrm{n}=0}^{\\infty} \\frac{(-1)^{\\mathrm{n}}}{2 \\mathrm{n}+1} \\mathrm{x}^{2 \\mathrm{n}+1}=\\mathrm{x}-\\frac{1}{3} \\mathrm{x}^3+\\frac{1}{5} \\mathrm{x}^5+\\cdots+\\mathrm{x} \\in[-1,1] \\\\\n\n& \\tan \\mathrm{x}=\\sum_{\\mathrm{n}=1}^{\\infty} \\frac{\\mathrm{B}_{2 \\mathrm{n}}(-4)^{\\mathrm{n}}\\left(1-4^{\\mathrm{n}}\\right)}{(2 \\mathrm{n}) !} \\mathrm{x}^{2 \\mathrm{n}-1}=\\mathrm{x}+\\frac{1}{3} \\mathrm{x}^3+\\frac{2}{15} \\mathrm{x}^5+\\frac{17}{315} \\mathrm{x}^7+\\frac{62}{2835} \\mathrm{x}^9+\\frac{1382}{155925} \\mathrm{x}^{11}+\\frac{21844}{6081075} \\mathrm{x}^{13}+... \\mathrm{x} \\in(-\\frac{\\pi}{2},\\frac{\\pi}{2}) \\\\\n&\n\\end{align}</script><p>推广：这里的taylor公式也可以推广为【..】=&gt; 0；类似复合函数的形式,注意函数极限中的两个式子的加减是否产生了抵消。</p>\n<h2 id=\"1-6-七类未定式\"><a href=\"#1-6-七类未定式\" class=\"headerlink\" title=\"1.6 七类未定式\"></a>1.6 七类未定式</h2><script type=\"math/tex; mode=display\">\n七类未定式：\n\\ \\ \\ \\frac{0}{0} \n\\ \\ \\ \\frac{\\infty}{\\infty} \n\\ \\ \\ 0\\times\\infty\n\\ \\ \\ \\infty - \\infty \n\\ \\ \\ 0^{\\infty}\n\\ \\ \\ \\infty^{0}\n\\ \\ \\ 1^{\\infty}</script><ul>\n<li><script type=\"math/tex; mode=display\">\\infty^{0}</script></li>\n</ul>\n<div class=\"tabs\" id=\"无穷的0次方例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#无穷的0次方例题-1\">无穷的0次方例题 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#无穷的0次方例题-2\">无穷的0次方例题 2</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#无穷的0次方例题-3\">无穷的0次方例题 3</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"无穷的0次方例题-1\"><script type=\"math/tex; mode=display\">\nI = \\lim_{x \\to \\infty}(e^{x^2}+x^3)^{\\frac{1}{x^2}}\\\\\n(1) \\ \\ I = \\lim_{x \\to \\infty} e^{\\frac{\\ln{(e^{x^2}+x^3})}{x^2}} \\Rightarrow 对于指数 \\frac{\\ln{(e^{x^2}+x^3)}}{x^2} 使用洛必达 \\\\\n(2) 观察到外层的指数和里面的某一项有可以相消的指数：化简\\Rightarrow \\lim_{x\\to \\infty} [e^{x^2}(1+\\frac{x^3}{e^{x^2}})]^{\\frac{1}{x^2}}</script><p>将函数指数化、对数化，将其变为一个<script type=\"math/tex\">\\frac{\\infty}{\\infty}</script>类型，然后研究指数，使用洛必达解出</p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"无穷的0次方例题-2\"><p><strong>This is Tab 2.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"无穷的0次方例题-3\"><p><strong>This is Tab 3.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"Lagrange方法\"><a href=\"#Lagrange方法\" class=\"headerlink\" title=\"Lagrange方法\"></a>Lagrange方法</h3><script type=\"math/tex; mode=display\">\nf(a)-f(b) = f'(\\xi)(a-b)</script><p> 拉格朗日求函数极限的方法一定要注意 构造的函数的两个区间一定 </p>\n<h3 id=\"对数函数公式\"><a href=\"#对数函数公式\" class=\"headerlink\" title=\"对数函数公式\"></a>对数函数公式</h3><script type=\"math/tex; mode=display\">\n\\begin{cases}\n&恒等变形 \\ \\ \\ f(x) = e^{\\ln f(x)} = \\ln {e^{f(x)}} \\\\\n& 加法公式 \\ \\ \\ \\ln{a} + \\ln{b} = \\ln{ab} \\\\\n& 减法公式 \\ \\ \\ \\ln{a} - \\ln{b} = \\ln{\\frac{a}{b}} \\\\\n&换底公式 \\ \\ \\ \\log_a b = \\frac{\\ln{b}}{\\ln{a}} \\\\\n\\end{cases}</script><h3 id=\"三角函数公式2\"><a href=\"#三角函数公式2\" class=\"headerlink\" title=\"三角函数公式2\"></a>三角函数公式<sup><a href=\"#fn_2\" id=\"reffn_2\">2</a></sup></h3><h4 id=\"和差化积公式记忆口诀\"><a href=\"#和差化积公式记忆口诀\" class=\"headerlink\" title=\"和差化积公式记忆口诀\"></a>和差化积公式记忆口诀</h4><p>正加正，正在前，余减余，余并肩，正减正，余在前，余减余，负正弦。</p>\n<h3 id=\"解决七类未定式的方法论：\"><a href=\"#解决七类未定式的方法论：\" class=\"headerlink\" title=\"解决七类未定式的方法论：\"></a>解决七类未定式的方法论：</h3><ul>\n<li><p>三种：等价、洛必达、泰勒</p>\n</li>\n<li><p>三种：洛必达、同除最高次幂项（注意符号的问题）、抓大头</p>\n</li>\n<li><p>两种：将其化为第一种或者第二种方法 来做</p>\n</li>\n<li><p>三种：通分、有理化、倒代换</p>\n</li>\n<li><p>第五和第六中未定式：使用对数的公式化简</p>\n<blockquote>\n<p>tips (注意): <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"34.515ex\" height=\"2.646ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -919.6 15255.7 1169.6\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mo\"><path data-c=\"6C\" d=\"M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z\"></path><path data-c=\"69\" d=\"M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z\" transform=\"translate(278,0)\"></path><path data-c=\"6D\" d=\"M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z\" transform=\"translate(556,0)\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(1422,-150) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(572,0)\"><path data-c=\"2192\" d=\"M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1572,0)\"><g data-mml-node=\"mn\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(533,289) scale(0.707)\"><path data-c=\"2B\" d=\"M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z\"></path></g></g></g></g><g data-mml-node=\"msup\" transform=\"translate(3551.5,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(605,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D6FC\" d=\"M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z\"></path></g></g></g><g data-mml-node=\"msup\" transform=\"translate(4825.7,0)\"><g data-mml-node=\"mi\"><path data-c=\"6C\" d=\"M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z\"></path><path data-c=\"6E\" d=\"M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z\" transform=\"translate(278,0)\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(867,421.1) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D6FD\" d=\"M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z\"></path></g></g></g><g data-mml-node=\"mo\" transform=\"translate(6142.9,0)\"><path data-c=\"2061\" d=\"\"></path></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(6309.6,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(7159.4,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(8215.1,0)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(8715.1,0)\"><path data-c=\"2C\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(9159.8,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(9409.8,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mi\" transform=\"translate(9659.8,0)\"><path data-c=\"1D6FC\" d=\"M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(10299.8,0)\"><path data-c=\"2C\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(10744.5,0)\"><path data-c=\"1D6FD\" d=\"M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(11588.3,0)\"><path data-c=\"2208\" d=\"M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(12533,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(12922,0)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(13422,0)\"><path data-c=\"2C\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(13866.7,0)\"><path data-c=\"221E\" d=\"M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(14866.7,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"1-7-数列极限-（单调有界定理）\"><a href=\"#1-7-数列极限-（单调有界定理）\" class=\"headerlink\" title=\"1.7 数列极限 （单调有界定理）\"></a>1.7 数列极限 （单调有界定理）</h2><h3 id=\"重要不等式\"><a href=\"#重要不等式\" class=\"headerlink\" title=\"重要不等式\"></a>重要不等式</h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) \\sin(x) \\lt x \\lt \\tan(x) , x \\in(0,\\frac{\\pi}{2})   \\\\\n& (2) e^x \\lt 1+x, x \\neq 0 \\\\\n& (3) \\frac{x}{1+x} \\lt \\ln(1+x) \\lt x , x \\neq 0 \\ \\ and \\ \\ x \\in(-1,\\infty) \\\\\n\\end{align}</script><h3 id=\"单调有界定理的步骤\"><a href=\"#单调有界定理的步骤\" class=\"headerlink\" title=\"单调有界定理的步骤\"></a>单调有界定理的步骤</h3><ul>\n<li><p>放缩确定界（证明有界）</p>\n</li>\n<li><p>证明单调</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 做差 \\ \\ x_{n+1}-x_{n}   \\\\\n& (2) 做商 \\ \\ \\frac{x_{n+1}}{x_n} \\\\\n& (3) 求解函数的单调性 \\ \\ y = f(x)\n\\begin{cases}\nf'(x) \\gt 0 \n\\begin{cases}\nx_1 \\gt x_2 \\rightarrow \\ x_2 = f(x_1)>f(x_2) = x_3,即 x_2 \\gt x_3 以此类推,x_{n-1} \\gt x_{n} \\\\\nx_1 \\lt x_2 \\rightarrow \\ x_2 = f(x_1) \\lt f(x_2) = x_3,...., x_{n-1} \\lt x_{n}\n\\end{cases} \\\\\nf'(x) \\lt 0 \\ \\ 使用夹逼准则\n\\end{cases}\n\\\\\n\\end{align}</script></li>\n<li><p>两边做极限解方程求解最后的极限值</p>\n</li>\n</ul>\n<h2 id=\"1-8-数列极限（夹逼准则）\"><a href=\"#1-8-数列极限（夹逼准则）\" class=\"headerlink\" title=\"1.8 数列极限（夹逼准则）\"></a>1.8 数列极限（夹逼准则）</h2><p>难点在于如何构造夹逼的两个函数。</p>\n<script type=\"math/tex; mode=display\">\nx_n \\le y_n \\le z_n \\  and \\ \\lim_{n \\to \\infty} x_n = \\lim_{n \\to \\infty} y_n = A \\rightarrow \\lim_{n \\to \\infty} y_n = A</script><h2 id=\"1-9-定积分定义-（这个比较简单）\"><a href=\"#1-9-定积分定义-（这个比较简单）\" class=\"headerlink\" title=\"1.9 定积分定义 （这个比较简单）\"></a>1.9 定积分定义 （这个比较简单）</h2><p>夹逼准则和定积分定义有时候会搞混。</p>\n<h2 id=\"2-1-连续\"><a href=\"#2-1-连续\" class=\"headerlink\" title=\"2.1 连续\"></a>2.1 连续</h2><h3 id=\"连续的定义\"><a href=\"#连续的定义\" class=\"headerlink\" title=\"连续的定义\"></a>连续的定义</h3><p>连续、右连续、左连续</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 连续 \\ \\ \\ \\lim_{x \\to x_0} f(x) = f(x_0) \\\\\n& (2) 右连续 \\ \\ \\ \\lim_{x \\to x_0^+} f(x) = f(x_0)  \\\\\n& (3) 左连续 \\ \\ \\ \\lim_{x \\to x_0^-} f(x) = f(x_0)  \\\\\n\\end{align}</script><h3 id=\"连续函数的性质\"><a href=\"#连续函数的性质\" class=\"headerlink\" title=\"连续函数的性质\"></a>连续函数的性质</h3><p>基本初等函数：反、对、幂、指、三（反三角函数、对数函数、幂函数、指数函数、三角函数）</p>\n<p>初等函数：基本初等函数经过有限次四则运算或者复合 得到的函数</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 基本初等函数在其定义域内都连续\\\\\n& (2) 连续函数经过有限次的四则运算以及复合任然是连续的 \\\\\n& (3) 初等函数都是连续函数\\\\\n\\end{align}</script><h3 id=\"闭区间连续函数的性质（定理，一定是闭区间的、连续的）\"><a href=\"#闭区间连续函数的性质（定理，一定是闭区间的、连续的）\" class=\"headerlink\" title=\"闭区间连续函数的性质（定理，一定是闭区间的、连续的）\"></a>闭区间连续函数的性质（定理，一定是闭区间的、连续的）</h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 最值定理: 闭区间连续函数一定存在最大值M 最小值m，即 m \\le f(x) \\le M  \\\\\n& (1.1) 最值定理推论：有界定理【闭区间连续函数必定有界】\\\\\n& (2) 介值定理: 若f(x) ， x \\in[a,b] 则一定有 \\exists \\xi \\in [a,b], 使得 f(\\xi) = \\frac{f(a)+f(b)}{2} \\\\\n& (2.1) 介值定理推论: \\ \\forall x_1,x_2,x_3 \\dots x_n \\in[a,b] ,则有\\exists \\xi \\in[a,b] \\ \\ f(\\xi) = \\frac{f(x_1)+f(x_2)+\\dots +f(x_n)}{n}   \\\\\n& (3) 零点定理: 若 f(a)f(b) \\lt 0, 则\\exists \\xi \\in(a,b), f(\\xi) = 0 \\\\\n\\end{align}</script><div class=\"tabs\" id=\"例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#例题-1\">例题 1</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-2\">例题 2</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-3\">例题 3</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"例题-1\"><script type=\"math/tex; mode=display\">\n例：设 f(x) 在x \\in[a,b]上连续 and\\ \\ f(1) = f(0) \\ \\ \\ 证明: \\exists \\xi 使得 f(\\xi+\\frac{1}{4}) = f(\\xi)</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-2\"><p><strong>This is Tab 2.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-3\"><p><strong>This is Tab 3.</strong></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"2-2-间断点\"><a href=\"#2-2-间断点\" class=\"headerlink\" title=\"2.2 间断点\"></a>2.2 间断点</h2><h3 id=\"间断点的定义\"><a href=\"#间断点的定义\" class=\"headerlink\" title=\"间断点的定义\"></a>间断点的定义</h3><script type=\"math/tex; mode=display\">\nf(x)在某个（存在这样的去心邻域即可）\\mathring{U}(x_0)有定义,并且f(x)在x_0处不连续（连续的定义见上文）。</script><h3 id=\"间断点的分类\"><a href=\"#间断点的分类\" class=\"headerlink\" title=\"间断点的分类\"></a>间断点的分类</h3><ul>\n<li>左右极限均存在的<ul>\n<li>可去间断点，左极限=右极限，但是不等于点处的值。（或者该点处没有定义）</li>\n<li>跳跃间断点</li>\n</ul>\n</li>\n<li>左右极限至少有一个不存在的<ul>\n<li>无穷间断点</li>\n<li>振荡间断点</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h1><blockquote id=\"fn_1\">\n<sup>1</sup>.  <a href=\"https://zhuanlan.zhihu.com/p/348178130\">Taylor多项式/Taylor公式 - 知乎 (zhihu.com)</a> ↩<a href=\"https://blog.csdn.net/Infinity_07/article/details/113830088\">(10条消息) 常见函数泰勒公式展开（清晰）<em>常见的泰勒展开公式大全</em>陌雨’的博客-CSDN博客</a><a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> ↩</a>\n</blockquote>\n<blockquote id=\"fn_2\">\n<sup>2</sup>. <a href=\"https://zhuanlan.zhihu.com/p/89073536\">考研数学的初等函数变换公式——三角相关 - 知乎 (zhihu.com)</a><a href=\"#reffn_2\" title=\"Jump back to footnote [2] in the text.\"> ↩</a>\n</blockquote>\n<blockquote id=\"fn_3\">\n<sup>3</sup>. <a href=\"https://www.zhihu.com/question/26383384\">(18 封私信 / 4 条消息) 有极限的数列是有界的怎么理解? - 知乎 (zhihu.com)</a><a href=\"#reffn_3\" title=\"Jump back to footnote [3] in the text.\"> ↩</a>\n</blockquote>\n"},{"title":"考研数学（高数部分，第三章）复习","mathjax":true,"copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-15T02:55:22.000Z","updated":"2023-04-15T02:55:22.000Z","keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg","_content":"\n\n\n\n\n[toc]\n\n\n\n\n\n# 不定积分\n\n## 不定积分的该概念\n\n### 原函数的定义\n\n$$\nasume: \\ \\exists f(x) 使得 F'(x) = f(x), 则F(x)就是f(x)的原函数。\n$$\n\n### 不定积分的定义\n\n### 不定积分的性质\n\n- 加减的性质\n\n- 性质二\n  $$\n  \\int d(f(x)) = \\int f'(x)dx\n  $$\n  \n- 性质三\n  $$\n  asume:\\int f(x)dx = F(x)+C \\Rightarrow d(\\int f(x)dx) = d(F(x)) = F'(x)dx = f(x)dx\n  $$\n  \n\n### 不定积分的计算方法\n\n- 凑微分\n- 分部\n- 换元\n  - 三角代换\n  - 根式代换\n  - 倒代换\n  - 万能代换\n  - 整体代换\n- 有理函数分解\n\n## 基本积分公式\n\n## 有理函数分解求不定积分\n\n### 有理函数定义\n\n### 有理函数分解定理\n\n\n\n# 定积分\n\n## 定积分计算方法\n\n- 凑微分\n\n- 分部\n\n- 换元\n\n- 奇偶性 \n\n  奇偶性的使用需要：1、判断函数是否具有奇偶性；2、区间对称\n\n- 周期性\n\n- Wallis公式\n\n- 定积分性质（带有极限的定积分）\n\n定积分的方法+N-L公式\n\n\n\n## 定积分概念\n\n### 定积分的定义\n\n### 定积分性质\n\n- 线性性质：加法\n- 区间可加\n- 比较性质 \n  - 推论一\n  - 推论二\n\n- 估值定理（了解）\n- 积分中值定理\n  - 一般积分中值\n  - 加强积分中值\n    - 为什么可以确定可以不在端点（Largrange中值）\n  - 广义积分中值\n    - 为什么gx不变号:exclamation:\n\n## 变限积分\n\n### 变限积分的定义\n\n### 变限积分的性质\n\n- 性质一\n- 性质二\n- 性质三\n\n推广：\n\n- 性质一\n- 性质二\n- 性质三\n\n## 反常积分\n\n### 反常积分的概念\n\n- 无穷积分\n  - 无穷积分的定义\n- 瑕积分\n\n## 定积分的应用\n\n- 几何\n  - 面积\n    - 极坐标\n  - 体积\n  - 弧长\n  - 侧面积\n- 物理\n  - 做工\n  - 受力\n\n### 直角坐标\n\n面积\n\n体积\n\n### 极坐标\n\n面积\n\n体积\n\n","source":"_posts/考研数学（高数部分，第三章）复习.md","raw":"---\ntitle: 考研数学（高数部分，第三章）复习\nmathjax: true\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-15 10:55:22\nupdated: 2023-04-15 10:55:22\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg\n---\n\n\n\n\n\n[toc]\n\n\n\n\n\n# 不定积分\n\n## 不定积分的该概念\n\n### 原函数的定义\n\n$$\nasume: \\ \\exists f(x) 使得 F'(x) = f(x), 则F(x)就是f(x)的原函数。\n$$\n\n### 不定积分的定义\n\n### 不定积分的性质\n\n- 加减的性质\n\n- 性质二\n  $$\n  \\int d(f(x)) = \\int f'(x)dx\n  $$\n  \n- 性质三\n  $$\n  asume:\\int f(x)dx = F(x)+C \\Rightarrow d(\\int f(x)dx) = d(F(x)) = F'(x)dx = f(x)dx\n  $$\n  \n\n### 不定积分的计算方法\n\n- 凑微分\n- 分部\n- 换元\n  - 三角代换\n  - 根式代换\n  - 倒代换\n  - 万能代换\n  - 整体代换\n- 有理函数分解\n\n## 基本积分公式\n\n## 有理函数分解求不定积分\n\n### 有理函数定义\n\n### 有理函数分解定理\n\n\n\n# 定积分\n\n## 定积分计算方法\n\n- 凑微分\n\n- 分部\n\n- 换元\n\n- 奇偶性 \n\n  奇偶性的使用需要：1、判断函数是否具有奇偶性；2、区间对称\n\n- 周期性\n\n- Wallis公式\n\n- 定积分性质（带有极限的定积分）\n\n定积分的方法+N-L公式\n\n\n\n## 定积分概念\n\n### 定积分的定义\n\n### 定积分性质\n\n- 线性性质：加法\n- 区间可加\n- 比较性质 \n  - 推论一\n  - 推论二\n\n- 估值定理（了解）\n- 积分中值定理\n  - 一般积分中值\n  - 加强积分中值\n    - 为什么可以确定可以不在端点（Largrange中值）\n  - 广义积分中值\n    - 为什么gx不变号:exclamation:\n\n## 变限积分\n\n### 变限积分的定义\n\n### 变限积分的性质\n\n- 性质一\n- 性质二\n- 性质三\n\n推广：\n\n- 性质一\n- 性质二\n- 性质三\n\n## 反常积分\n\n### 反常积分的概念\n\n- 无穷积分\n  - 无穷积分的定义\n- 瑕积分\n\n## 定积分的应用\n\n- 几何\n  - 面积\n    - 极坐标\n  - 体积\n  - 弧长\n  - 侧面积\n- 物理\n  - 做工\n  - 受力\n\n### 直角坐标\n\n面积\n\n体积\n\n### 极坐标\n\n面积\n\n体积\n\n","slug":"考研数学（高数部分，第三章）复习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmg0011bsuofuy269m4","content":"<p>[toc]</p>\n<h1 id=\"不定积分\"><a href=\"#不定积分\" class=\"headerlink\" title=\"不定积分\"></a>不定积分</h1><h2 id=\"不定积分的该概念\"><a href=\"#不定积分的该概念\" class=\"headerlink\" title=\"不定积分的该概念\"></a>不定积分的该概念</h2><h3 id=\"原函数的定义\"><a href=\"#原函数的定义\" class=\"headerlink\" title=\"原函数的定义\"></a>原函数的定义</h3><script type=\"math/tex; mode=display\">\nasume: \\ \\exists f(x) 使得 F'(x) = f(x), 则F(x)就是f(x)的原函数。</script><h3 id=\"不定积分的定义\"><a href=\"#不定积分的定义\" class=\"headerlink\" title=\"不定积分的定义\"></a>不定积分的定义</h3><h3 id=\"不定积分的性质\"><a href=\"#不定积分的性质\" class=\"headerlink\" title=\"不定积分的性质\"></a>不定积分的性质</h3><ul>\n<li><p>加减的性质</p>\n</li>\n<li><p>性质二</p>\n<script type=\"math/tex; mode=display\">\n\\int d(f(x)) = \\int f'(x)dx</script></li>\n<li><p>性质三</p>\n<script type=\"math/tex; mode=display\">\nasume:\\int f(x)dx = F(x)+C \\Rightarrow d(\\int f(x)dx) = d(F(x)) = F'(x)dx = f(x)dx</script></li>\n</ul>\n<h3 id=\"不定积分的计算方法\"><a href=\"#不定积分的计算方法\" class=\"headerlink\" title=\"不定积分的计算方法\"></a>不定积分的计算方法</h3><ul>\n<li>凑微分</li>\n<li>分部</li>\n<li>换元<ul>\n<li>三角代换</li>\n<li>根式代换</li>\n<li>倒代换</li>\n<li>万能代换</li>\n<li>整体代换</li>\n</ul>\n</li>\n<li>有理函数分解</li>\n</ul>\n<h2 id=\"基本积分公式\"><a href=\"#基本积分公式\" class=\"headerlink\" title=\"基本积分公式\"></a>基本积分公式</h2><h2 id=\"有理函数分解求不定积分\"><a href=\"#有理函数分解求不定积分\" class=\"headerlink\" title=\"有理函数分解求不定积分\"></a>有理函数分解求不定积分</h2><h3 id=\"有理函数定义\"><a href=\"#有理函数定义\" class=\"headerlink\" title=\"有理函数定义\"></a>有理函数定义</h3><h3 id=\"有理函数分解定理\"><a href=\"#有理函数分解定理\" class=\"headerlink\" title=\"有理函数分解定理\"></a>有理函数分解定理</h3><h1 id=\"定积分\"><a href=\"#定积分\" class=\"headerlink\" title=\"定积分\"></a>定积分</h1><h2 id=\"定积分计算方法\"><a href=\"#定积分计算方法\" class=\"headerlink\" title=\"定积分计算方法\"></a>定积分计算方法</h2><ul>\n<li><p>凑微分</p>\n</li>\n<li><p>分部</p>\n</li>\n<li><p>换元</p>\n</li>\n<li><p>奇偶性 </p>\n<p>奇偶性的使用需要：1、判断函数是否具有奇偶性；2、区间对称</p>\n</li>\n<li><p>周期性</p>\n</li>\n<li><p>Wallis公式</p>\n</li>\n<li><p>定积分性质（带有极限的定积分）</p>\n</li>\n</ul>\n<p>定积分的方法+N-L公式</p>\n<h2 id=\"定积分概念\"><a href=\"#定积分概念\" class=\"headerlink\" title=\"定积分概念\"></a>定积分概念</h2><h3 id=\"定积分的定义\"><a href=\"#定积分的定义\" class=\"headerlink\" title=\"定积分的定义\"></a>定积分的定义</h3><h3 id=\"定积分性质\"><a href=\"#定积分性质\" class=\"headerlink\" title=\"定积分性质\"></a>定积分性质</h3><ul>\n<li>线性性质：加法</li>\n<li>区间可加</li>\n<li><p>比较性质 </p>\n<ul>\n<li>推论一</li>\n<li>推论二</li>\n</ul>\n</li>\n<li><p>估值定理（了解）</p>\n</li>\n<li>积分中值定理<ul>\n<li>一般积分中值</li>\n<li>加强积分中值<ul>\n<li>为什么可以确定可以不在端点（Largrange中值）</li>\n</ul>\n</li>\n<li>广义积分中值<ul>\n<li>为什么gx不变号:exclamation:</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"变限积分\"><a href=\"#变限积分\" class=\"headerlink\" title=\"变限积分\"></a>变限积分</h2><h3 id=\"变限积分的定义\"><a href=\"#变限积分的定义\" class=\"headerlink\" title=\"变限积分的定义\"></a>变限积分的定义</h3><h3 id=\"变限积分的性质\"><a href=\"#变限积分的性质\" class=\"headerlink\" title=\"变限积分的性质\"></a>变限积分的性质</h3><ul>\n<li>性质一</li>\n<li>性质二</li>\n<li>性质三</li>\n</ul>\n<p>推广：</p>\n<ul>\n<li>性质一</li>\n<li>性质二</li>\n<li>性质三</li>\n</ul>\n<h2 id=\"反常积分\"><a href=\"#反常积分\" class=\"headerlink\" title=\"反常积分\"></a>反常积分</h2><h3 id=\"反常积分的概念\"><a href=\"#反常积分的概念\" class=\"headerlink\" title=\"反常积分的概念\"></a>反常积分的概念</h3><ul>\n<li>无穷积分<ul>\n<li>无穷积分的定义</li>\n</ul>\n</li>\n<li>瑕积分</li>\n</ul>\n<h2 id=\"定积分的应用\"><a href=\"#定积分的应用\" class=\"headerlink\" title=\"定积分的应用\"></a>定积分的应用</h2><ul>\n<li>几何<ul>\n<li>面积<ul>\n<li>极坐标</li>\n</ul>\n</li>\n<li>体积</li>\n<li>弧长</li>\n<li>侧面积</li>\n</ul>\n</li>\n<li>物理<ul>\n<li>做工</li>\n<li>受力</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"直角坐标\"><a href=\"#直角坐标\" class=\"headerlink\" title=\"直角坐标\"></a>直角坐标</h3><p>面积</p>\n<p>体积</p>\n<h3 id=\"极坐标\"><a href=\"#极坐标\" class=\"headerlink\" title=\"极坐标\"></a>极坐标</h3><p>面积</p>\n<p>体积</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"不定积分\"><a href=\"#不定积分\" class=\"headerlink\" title=\"不定积分\"></a>不定积分</h1><h2 id=\"不定积分的该概念\"><a href=\"#不定积分的该概念\" class=\"headerlink\" title=\"不定积分的该概念\"></a>不定积分的该概念</h2><h3 id=\"原函数的定义\"><a href=\"#原函数的定义\" class=\"headerlink\" title=\"原函数的定义\"></a>原函数的定义</h3><script type=\"math/tex; mode=display\">\nasume: \\ \\exists f(x) 使得 F'(x) = f(x), 则F(x)就是f(x)的原函数。</script><h3 id=\"不定积分的定义\"><a href=\"#不定积分的定义\" class=\"headerlink\" title=\"不定积分的定义\"></a>不定积分的定义</h3><h3 id=\"不定积分的性质\"><a href=\"#不定积分的性质\" class=\"headerlink\" title=\"不定积分的性质\"></a>不定积分的性质</h3><ul>\n<li><p>加减的性质</p>\n</li>\n<li><p>性质二</p>\n<script type=\"math/tex; mode=display\">\n\\int d(f(x)) = \\int f'(x)dx</script></li>\n<li><p>性质三</p>\n<script type=\"math/tex; mode=display\">\nasume:\\int f(x)dx = F(x)+C \\Rightarrow d(\\int f(x)dx) = d(F(x)) = F'(x)dx = f(x)dx</script></li>\n</ul>\n<h3 id=\"不定积分的计算方法\"><a href=\"#不定积分的计算方法\" class=\"headerlink\" title=\"不定积分的计算方法\"></a>不定积分的计算方法</h3><ul>\n<li>凑微分</li>\n<li>分部</li>\n<li>换元<ul>\n<li>三角代换</li>\n<li>根式代换</li>\n<li>倒代换</li>\n<li>万能代换</li>\n<li>整体代换</li>\n</ul>\n</li>\n<li>有理函数分解</li>\n</ul>\n<h2 id=\"基本积分公式\"><a href=\"#基本积分公式\" class=\"headerlink\" title=\"基本积分公式\"></a>基本积分公式</h2><h2 id=\"有理函数分解求不定积分\"><a href=\"#有理函数分解求不定积分\" class=\"headerlink\" title=\"有理函数分解求不定积分\"></a>有理函数分解求不定积分</h2><h3 id=\"有理函数定义\"><a href=\"#有理函数定义\" class=\"headerlink\" title=\"有理函数定义\"></a>有理函数定义</h3><h3 id=\"有理函数分解定理\"><a href=\"#有理函数分解定理\" class=\"headerlink\" title=\"有理函数分解定理\"></a>有理函数分解定理</h3><h1 id=\"定积分\"><a href=\"#定积分\" class=\"headerlink\" title=\"定积分\"></a>定积分</h1><h2 id=\"定积分计算方法\"><a href=\"#定积分计算方法\" class=\"headerlink\" title=\"定积分计算方法\"></a>定积分计算方法</h2><ul>\n<li><p>凑微分</p>\n</li>\n<li><p>分部</p>\n</li>\n<li><p>换元</p>\n</li>\n<li><p>奇偶性 </p>\n<p>奇偶性的使用需要：1、判断函数是否具有奇偶性；2、区间对称</p>\n</li>\n<li><p>周期性</p>\n</li>\n<li><p>Wallis公式</p>\n</li>\n<li><p>定积分性质（带有极限的定积分）</p>\n</li>\n</ul>\n<p>定积分的方法+N-L公式</p>\n<h2 id=\"定积分概念\"><a href=\"#定积分概念\" class=\"headerlink\" title=\"定积分概念\"></a>定积分概念</h2><h3 id=\"定积分的定义\"><a href=\"#定积分的定义\" class=\"headerlink\" title=\"定积分的定义\"></a>定积分的定义</h3><h3 id=\"定积分性质\"><a href=\"#定积分性质\" class=\"headerlink\" title=\"定积分性质\"></a>定积分性质</h3><ul>\n<li>线性性质：加法</li>\n<li>区间可加</li>\n<li><p>比较性质 </p>\n<ul>\n<li>推论一</li>\n<li>推论二</li>\n</ul>\n</li>\n<li><p>估值定理（了解）</p>\n</li>\n<li>积分中值定理<ul>\n<li>一般积分中值</li>\n<li>加强积分中值<ul>\n<li>为什么可以确定可以不在端点（Largrange中值）</li>\n</ul>\n</li>\n<li>广义积分中值<ul>\n<li>为什么gx不变号:exclamation:</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"变限积分\"><a href=\"#变限积分\" class=\"headerlink\" title=\"变限积分\"></a>变限积分</h2><h3 id=\"变限积分的定义\"><a href=\"#变限积分的定义\" class=\"headerlink\" title=\"变限积分的定义\"></a>变限积分的定义</h3><h3 id=\"变限积分的性质\"><a href=\"#变限积分的性质\" class=\"headerlink\" title=\"变限积分的性质\"></a>变限积分的性质</h3><ul>\n<li>性质一</li>\n<li>性质二</li>\n<li>性质三</li>\n</ul>\n<p>推广：</p>\n<ul>\n<li>性质一</li>\n<li>性质二</li>\n<li>性质三</li>\n</ul>\n<h2 id=\"反常积分\"><a href=\"#反常积分\" class=\"headerlink\" title=\"反常积分\"></a>反常积分</h2><h3 id=\"反常积分的概念\"><a href=\"#反常积分的概念\" class=\"headerlink\" title=\"反常积分的概念\"></a>反常积分的概念</h3><ul>\n<li>无穷积分<ul>\n<li>无穷积分的定义</li>\n</ul>\n</li>\n<li>瑕积分</li>\n</ul>\n<h2 id=\"定积分的应用\"><a href=\"#定积分的应用\" class=\"headerlink\" title=\"定积分的应用\"></a>定积分的应用</h2><ul>\n<li>几何<ul>\n<li>面积<ul>\n<li>极坐标</li>\n</ul>\n</li>\n<li>体积</li>\n<li>弧长</li>\n<li>侧面积</li>\n</ul>\n</li>\n<li>物理<ul>\n<li>做工</li>\n<li>受力</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"直角坐标\"><a href=\"#直角坐标\" class=\"headerlink\" title=\"直角坐标\"></a>直角坐标</h3><p>面积</p>\n<p>体积</p>\n<h3 id=\"极坐标\"><a href=\"#极坐标\" class=\"headerlink\" title=\"极坐标\"></a>极坐标</h3><p>面积</p>\n<p>体积</p>\n"},{"title":"考研数学（高数部分，第五章）复习","mathjax":true,"copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-21T05:23:36.000Z","updated":"2023-04-21T05:23:36.000Z","keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg","_content":"\n\n\n{% timeline 2023,blue %}\n\n<!-- timeline 04-21 -->\n\n- 多元函数微分学\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n[toc]\n\n\n\n# 偏导数与全微分\n\n## 重极限的定义\n\n个人补充：累次极限[^1]\n\n## 多元函数连续定义\n\n### 计算重极限\n\n### 判断重极限的存在 与否\n\n## 偏导数的定义\n\n### 偏积分 \n\n## 全微分\n\n### 可微的充要条件\n\n## 总结\n\n$$\n偏导数在(x_0,y_0)处连续 \\Rightarrow 函数在(x_0,y_0)可微（可全微分） \n\\begin{matrix}\n\\Rightarrow 函数在(x_0,y_0)处偏导数存在 即f'_x(x_0,y_0) f'_y(x_0,y_0) 存在 \\\\\n\\Rightarrow 函数在(x_0,y_0)处连续即f(x_0,y_0) 连续\\\\\n\\end{matrix}\n$$\n\n偏导数连续推可微的过程[^2]\n\n# 多元复合函数与隐函数\n\n## 多元复合函数\n\n链式法则\n\n## 隐函数\n\n# 多元函数极值\n\n\n\n## 无条件机制\n\n## 条件极值\n\n\n\n\n\n\n\n\n\n\n\n[^1]: [数学分析：重极限和累次极限_萝卜丝皮尔的博客-CSDN博客](https://blog.csdn.net/qq_43448491/article/details/104086375)\n[^2]: [(13条消息) 为什么偏导数连续，函数就可微？_为什么偏导数连续可以推出可微_马同学图解数学的博客-CSDN博客](https://blog.csdn.net/ccnt_2012/article/details/83310653)\n","source":"_posts/考研数学（高数部分，第五章）复习.md","raw":"---\ntitle: 考研数学（高数部分，第五章）复习\nmathjax: true\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-21 13:23:36\nupdated: 2023-04-21 13:23:36\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg\n---\n\n\n\n{% timeline 2023,blue %}\n\n<!-- timeline 04-21 -->\n\n- 多元函数微分学\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n[toc]\n\n\n\n# 偏导数与全微分\n\n## 重极限的定义\n\n个人补充：累次极限[^1]\n\n## 多元函数连续定义\n\n### 计算重极限\n\n### 判断重极限的存在 与否\n\n## 偏导数的定义\n\n### 偏积分 \n\n## 全微分\n\n### 可微的充要条件\n\n## 总结\n\n$$\n偏导数在(x_0,y_0)处连续 \\Rightarrow 函数在(x_0,y_0)可微（可全微分） \n\\begin{matrix}\n\\Rightarrow 函数在(x_0,y_0)处偏导数存在 即f'_x(x_0,y_0) f'_y(x_0,y_0) 存在 \\\\\n\\Rightarrow 函数在(x_0,y_0)处连续即f(x_0,y_0) 连续\\\\\n\\end{matrix}\n$$\n\n偏导数连续推可微的过程[^2]\n\n# 多元复合函数与隐函数\n\n## 多元复合函数\n\n链式法则\n\n## 隐函数\n\n# 多元函数极值\n\n\n\n## 无条件机制\n\n## 条件极值\n\n\n\n\n\n\n\n\n\n\n\n[^1]: [数学分析：重极限和累次极限_萝卜丝皮尔的博客-CSDN博客](https://blog.csdn.net/qq_43448491/article/details/104086375)\n[^2]: [(13条消息) 为什么偏导数连续，函数就可微？_为什么偏导数连续可以推出可微_马同学图解数学的博客-CSDN博客](https://blog.csdn.net/ccnt_2012/article/details/83310653)\n","slug":"考研数学（高数部分，第五章）复习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmh0015bsuod42lbmlq","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-21</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>多元函数微分学</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"偏导数与全微分\"><a href=\"#偏导数与全微分\" class=\"headerlink\" title=\"偏导数与全微分\"></a>偏导数与全微分</h1><h2 id=\"重极限的定义\"><a href=\"#重极限的定义\" class=\"headerlink\" title=\"重极限的定义\"></a>重极限的定义</h2><p>个人补充：累次极限<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></p>\n<h2 id=\"多元函数连续定义\"><a href=\"#多元函数连续定义\" class=\"headerlink\" title=\"多元函数连续定义\"></a>多元函数连续定义</h2><h3 id=\"计算重极限\"><a href=\"#计算重极限\" class=\"headerlink\" title=\"计算重极限\"></a>计算重极限</h3><h3 id=\"判断重极限的存在-与否\"><a href=\"#判断重极限的存在-与否\" class=\"headerlink\" title=\"判断重极限的存在 与否\"></a>判断重极限的存在 与否</h3><h2 id=\"偏导数的定义\"><a href=\"#偏导数的定义\" class=\"headerlink\" title=\"偏导数的定义\"></a>偏导数的定义</h2><h3 id=\"偏积分\"><a href=\"#偏积分\" class=\"headerlink\" title=\"偏积分\"></a>偏积分</h3><h2 id=\"全微分\"><a href=\"#全微分\" class=\"headerlink\" title=\"全微分\"></a>全微分</h2><h3 id=\"可微的充要条件\"><a href=\"#可微的充要条件\" class=\"headerlink\" title=\"可微的充要条件\"></a>可微的充要条件</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><script type=\"math/tex; mode=display\">\n偏导数在(x_0,y_0)处连续 \\Rightarrow 函数在(x_0,y_0)可微（可全微分） \n\\begin{matrix}\n\\Rightarrow 函数在(x_0,y_0)处偏导数存在 即f'_x(x_0,y_0) f'_y(x_0,y_0) 存在 \\\\\n\\Rightarrow 函数在(x_0,y_0)处连续即f(x_0,y_0) 连续\\\\\n\\end{matrix}</script><p>偏导数连续推可微的过程<sup><a href=\"#fn_2\" id=\"reffn_2\">2</a></sup></p>\n<h1 id=\"多元复合函数与隐函数\"><a href=\"#多元复合函数与隐函数\" class=\"headerlink\" title=\"多元复合函数与隐函数\"></a>多元复合函数与隐函数</h1><h2 id=\"多元复合函数\"><a href=\"#多元复合函数\" class=\"headerlink\" title=\"多元复合函数\"></a>多元复合函数</h2><p>链式法则</p>\n<h2 id=\"隐函数\"><a href=\"#隐函数\" class=\"headerlink\" title=\"隐函数\"></a>隐函数</h2><h1 id=\"多元函数极值\"><a href=\"#多元函数极值\" class=\"headerlink\" title=\"多元函数极值\"></a>多元函数极值</h1><h2 id=\"无条件机制\"><a href=\"#无条件机制\" class=\"headerlink\" title=\"无条件机制\"></a>无条件机制</h2><h2 id=\"条件极值\"><a href=\"#条件极值\" class=\"headerlink\" title=\"条件极值\"></a>条件极值</h2><blockquote id=\"fn_1\">\n<sup>1</sup>. <a href=\"https://blog.csdn.net/qq_43448491/article/details/104086375\">数学分析：重极限和累次极限_萝卜丝皮尔的博客-CSDN博客</a><a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> ↩</a>\n</blockquote>\n<blockquote id=\"fn_2\">\n<sup>2</sup>. <a href=\"https://blog.csdn.net/ccnt_2012/article/details/83310653\">(13条消息) 为什么偏导数连续，函数就可微？<em>为什么偏导数连续可以推出可微</em>马同学图解数学的博客-CSDN博客</a><a href=\"#reffn_2\" title=\"Jump back to footnote [2] in the text.\"> ↩</a>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-21</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>多元函数微分学</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"偏导数与全微分\"><a href=\"#偏导数与全微分\" class=\"headerlink\" title=\"偏导数与全微分\"></a>偏导数与全微分</h1><h2 id=\"重极限的定义\"><a href=\"#重极限的定义\" class=\"headerlink\" title=\"重极限的定义\"></a>重极限的定义</h2><p>个人补充：累次极限<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></p>\n<h2 id=\"多元函数连续定义\"><a href=\"#多元函数连续定义\" class=\"headerlink\" title=\"多元函数连续定义\"></a>多元函数连续定义</h2><h3 id=\"计算重极限\"><a href=\"#计算重极限\" class=\"headerlink\" title=\"计算重极限\"></a>计算重极限</h3><h3 id=\"判断重极限的存在-与否\"><a href=\"#判断重极限的存在-与否\" class=\"headerlink\" title=\"判断重极限的存在 与否\"></a>判断重极限的存在 与否</h3><h2 id=\"偏导数的定义\"><a href=\"#偏导数的定义\" class=\"headerlink\" title=\"偏导数的定义\"></a>偏导数的定义</h2><h3 id=\"偏积分\"><a href=\"#偏积分\" class=\"headerlink\" title=\"偏积分\"></a>偏积分</h3><h2 id=\"全微分\"><a href=\"#全微分\" class=\"headerlink\" title=\"全微分\"></a>全微分</h2><h3 id=\"可微的充要条件\"><a href=\"#可微的充要条件\" class=\"headerlink\" title=\"可微的充要条件\"></a>可微的充要条件</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><script type=\"math/tex; mode=display\">\n偏导数在(x_0,y_0)处连续 \\Rightarrow 函数在(x_0,y_0)可微（可全微分） \n\\begin{matrix}\n\\Rightarrow 函数在(x_0,y_0)处偏导数存在 即f'_x(x_0,y_0) f'_y(x_0,y_0) 存在 \\\\\n\\Rightarrow 函数在(x_0,y_0)处连续即f(x_0,y_0) 连续\\\\\n\\end{matrix}</script><p>偏导数连续推可微的过程<sup><a href=\"#fn_2\" id=\"reffn_2\">2</a></sup></p>\n<h1 id=\"多元复合函数与隐函数\"><a href=\"#多元复合函数与隐函数\" class=\"headerlink\" title=\"多元复合函数与隐函数\"></a>多元复合函数与隐函数</h1><h2 id=\"多元复合函数\"><a href=\"#多元复合函数\" class=\"headerlink\" title=\"多元复合函数\"></a>多元复合函数</h2><p>链式法则</p>\n<h2 id=\"隐函数\"><a href=\"#隐函数\" class=\"headerlink\" title=\"隐函数\"></a>隐函数</h2><h1 id=\"多元函数极值\"><a href=\"#多元函数极值\" class=\"headerlink\" title=\"多元函数极值\"></a>多元函数极值</h1><h2 id=\"无条件机制\"><a href=\"#无条件机制\" class=\"headerlink\" title=\"无条件机制\"></a>无条件机制</h2><h2 id=\"条件极值\"><a href=\"#条件极值\" class=\"headerlink\" title=\"条件极值\"></a>条件极值</h2><blockquote id=\"fn_1\">\n<sup>1</sup>. <a href=\"https://blog.csdn.net/qq_43448491/article/details/104086375\">数学分析：重极限和累次极限_萝卜丝皮尔的博客-CSDN博客</a><a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> ↩</a>\n</blockquote>\n<blockquote id=\"fn_2\">\n<sup>2</sup>. <a href=\"https://blog.csdn.net/ccnt_2012/article/details/83310653\">(13条消息) 为什么偏导数连续，函数就可微？<em>为什么偏导数连续可以推出可微</em>马同学图解数学的博客-CSDN博客</a><a href=\"#reffn_2\" title=\"Jump back to footnote [2] in the text.\"> ↩</a>\n</blockquote>\n"},{"title":"考研数学（高数部分，第二章）复习","mathjax":true,"copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-13T00:27:53.000Z","updated":"2023-04-13T00:27:53.000Z","keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg","_content":"\n\n\n{% timeline 2023,blue %}\n\n<!-- timeline 04-12 -->\n\n- 微分部分知识点的构建\n\n<!-- endtimeline -->\n\n<!-- timeline 04-13 -->\n\n- 导数应用\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n[toc]\n\n\n\n# 一元函数微分学\n\n## 1.1 导数与微分\n\n### 导数定义\n\n$$\n\\begin{align}\n& (1) 函数在某一个点x_0上的导数, f'(x_0) = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} \n= \\lim_{\\Delta x \\to 0} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0} \\frac{f(x)- f(x_0)}{x} \\\\\n& (2) 右导数, f'_+(x_0) = \\lim_{\\Delta x \\to 0^+} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0^+} \\frac{f(x)- f(x_0)}{x} \\\\\n& (3) 左导数, f'_-(x_0) = \\lim_{\\Delta x \\to 0^-} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0^-} \\frac{f(x)- f(x_0)}{x} \\\\\n& (4) 导(函)数,f(x) = = \\lim_{\\Delta x \\to 0} \\frac{f(x+\\Delta x)- f(x)}{\\Delta x} \\\\\n& (5) 高阶导数, f^{(n)}(x_0) = \\lim_{\\Delta x \\to 0} \\frac{f^{(n-1)}(x_0+\\Delta x) - f^{(n-1)}(x_0)}{\\Delta x},\\\\\n& 该定义说明了:如果函数f(x)在x_0处存在n阶导数(存在n阶导数)，那么必然的: f^{(n-1)}(x),在某\\mathring{U}(x_0)处有定义，即在某\\mathring{U}(x_0) 内n-1阶可导\n\\end{align}\n$$\n\n### 可导的充要条件\n\n根据导数的定义（导数实际上是极限）所以可导的充要条件和极限的充要条件差不多。\n\n为什么可导的充要条件中不去定义$$F'(x_0)存在 $$：\n$$\n根据定义：f'(x_0) = \\lim_{x \\to x_0} \\frac{f(x)-f(x_0)}{x-x_0};\\\\\n其中并没有定义f'(x_0)\n$$\n该点导数存在不能直接说名该点的导数存在，只有当导函数满足连续条件后才能定义出该点的导数是多少。\n\n可导其实是导函数的极限？：经典错误！ 答案是否定的\n$$\nf(x) = x^2\\sin(\\frac{1}{x}) \\ \\ 在x = 0处导数存在但是导函数极限不存在\n$$\n\n\n### 可导的必要条件 \n\n可导必连续\n\n### 导数的几何意义\n\n变化率，切线、法线\n\n### 导数极限定理\n\n如果 $$f(x)$$==在 $$x_0$$的邻域内连续==，==在 $$x_0$$的去心领域内可导==，且==导函数==在 $$x_0$$ 处的==极限存在==，则 $$f(x)$$在 $$x_0$$处的导数也存在并且等于导函数的极限。\n\n## 1.2 微分\n\n### 微分定义 \n\n$$\n对于函数y = f(x),在x = x_0 处 满足 \\Delta y = A\\Delta x+o(\\Delta x),即称f(x)在x_0处可微 \\\\\n记dy = A\\Delta x \\ (线性主部) , dx = \\Delta x, (请记住)dy \\neq \\Delta y\n$$\n\n由微分的定义以及导数的定义可知:此处的$$ A\\Delta x ,即微分中的线性主部中的A=f'(x_0) $$ 具体推导如下\n$$\n由导数的定义,f(x)在x_0处的导数f'(x_0) = \\lim_{x \\to x_0} \\frac{\\Delta y}{\\Delta x},\\\\\n由微分定义知道\\Delta y = A\\Delta x+o(\\Delta x),故\\\\\nf'(x_0) = \\lim_{x \\to x_0} \\frac{\\Delta y}{\\Delta x} = \\lim_{x \\to x_0} \\frac{A\\Delta x+o(\\Delta x)}{\\Delta x} =  \\lim_{x \\to x_0} A+\\frac{o(\\Delta x)}{\\Delta x} = A\n$$\n\n\n### 关于极限  连续 导数的三个重要结论\n\n- 分式极限存在,且分母极限为0,则分子极限为0\n\n- 分式极限存在且不为0时,分子极限为0,则分母极限也为0\n\n- 如果分子在该点处连续,且分母为0,则分子在该点处的取值为0;\n\n- 一个重要的结论\n  $$\n  f(x) = (x-x_0)^n|x-x_0| 该函数n阶可导n+1阶不可导\n  $$\n\n{% tabs 上述的结论相关的例题 %}\n<!-- tab 例题一:求函数最高几阶可导 -->\n$$\n设函数f(x) = 3x^3+2x^2|x|,问该函数几阶可导\n$$\n\n\n<!-- endtab -->\n\n<!-- tab 例题二:求函数的不可导点 -->\n$$\n设函数f(x) = (x^2-x-2)|x^3-x|,问该函数有几个不可导的点.\n$$\n<!-- endtab -->\n{% endtabs %}\n\n\n\n### 基本函数求导\n\n[上文](###常见函数的一阶导数)\n\n### 四则运算的求导\n\n基础啊\n\n### 复合函数求导\n\n链式法则\n\n### 隐函数求导\n\n- 法一: 带入求导\n- 法二: 公式法 \n- 法三: 全微分\n- \n\n例题:\n$$\ny = y(x), 由y = \\tan(x+y),确定,求y'(x), y''(x)\n$$\n\n\n### 反函数的求导\n\n- 反函数存在的前提: 函数可导且单调\n\n$$\ny = \\Phi(x),设其反函数 x = \\Phi^{-1}(y),则有如下: \\\\\n{\\Phi^{-1}}'(y) = \\frac{dx}{dy} = \\frac{1}{\\frac{dy}{dx}} = \\frac{1}{\\Phi'(x)} \\\\\n{\\Phi^{-1}}''(y) = \\frac{d^2x}{dy^2} = \\frac{\\frac{d\\frac{dy}{dx}}{dx}}{\\frac{dy}{dx}} = -\\frac{\\Phi''(x)}{\\Phi'(x)^3} \\\\\n$$\n\n:exclamation: ==特别注意求三角函数的反函数不能用上述方法，因为三角函数不满足单调==\n\n{% tabs 例题 %}\n<!-- tab 三角函数的反函数的求导-->\n$$\n39 设 y=y(x) 在 (-1,1) 二阶可导, 满足方程: \\left(1-x^2\\right) \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}-x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}+a^2 y=0, 作变 量替换 x=\\sin t 后, y 作为 t的函数满足的方程是\n$$\n<!-- endtab -->\n\n<!-- tab 错解-->\n$$\n\\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\frac{\\mathrm{d} t}{\\mathrm{~d} x}=\\frac{1}{\\cos t} \\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\ \\ 这里\\frac{dt}{dx} \\neq \\frac{1}{\\frac{dx}{dt}} \\ \\ 因为三角函数并不满足单调性\n$$\n\n\n<!-- endtab -->\n\n<!-- tab 正解-->\n$$\n方法 2 y=y(x) 也是 y 作为 t 的函数与 t=\\arcsin x 的复合函数, 由复合函数求导法得\\\\\n\n\\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\frac{\\mathrm{d} t}{\\mathrm{~d} x}=\\frac{1}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}, x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{x}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}\n\n再对 x 求导得\\\\\n\n\\begin{gathered}\n\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}=\\frac{1}{\\left(1-x^2\\right)} \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+\\frac{x}{\\left(1-x^2\\right)^{\\frac{3}{2}}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\\\\n\\left(1-x^2\\right) \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}=\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+\\frac{x}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}=\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}\n\\end{gathered}\\\\\n\n由原方程得\n\n\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+a^2 y=0\n$$\n\n\n<!-- endtab -->\n{% endtabs %}\n\n### 参数方程的求导\n\n链式法则\n\n### 对数求导\n\n解决如下问题:\n\n- 解决幂指函数\n- 对各因式积商 \\ 开方\n\n例如:\n$$\ny = (1+x^2)^{\\sin x},求y'\\\\\ny = \\sqrt[3]{\\frac{(x+1)(x+2)}{x(1+x^2)}}\n$$\n方法:\n\n- 恒等变形\n- 对数求导\n\n### 高阶导数\n\n常见高阶导数公式[^4]:\n\n- 奇偶性\n\n- 递推公式\n\n- Leibniz公式\n\n- Taylor公式: taylor公式中系数的唯一性\n\n## 1.3 导数应用\n\n导数应用涉及内容\n\n- 两点\n  - 极值点\n  - 拐点\n- 两性\n  - 单调性\n  - 凹凸性\n- 两线\n  - 切线、法线\n  - 渐近线\n- 不等式\n- 方程的根\n\n### 1.3.1 单调性与极值点\n\n#### 单调性的定义\n\n#### 单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）\n\n$$\n若x \\in I, and \\ f'(x) \\gt 0 \\Rightarrow 函数f(x)单调递增(反之递减) \\\\\n(1) 函数的一阶导函数可以不存在吗？ 例如为正无穷\\\\\n(2) 补充：(这个条件不能做充要条件的原因之一) 个别点导数为0 不影响函数的单调性。\n$$\n\n\n\n#### 极值的定义\n\n- 极小值定义\n  $$\n  存在一个U(x_0,\\delta),f(x)在该邻域内有定义,且f(x)\\gt f(x_0) \\Rightarrow f(x_0)为极小值\n  $$\n\n- 极大值定义\n  $$\n  存在一个U(x_0,\\delta),f(x)在该邻域内有定义,且f(x)\\lt f(x_0) \\Rightarrow f(x_0)为极大值\n  $$\n  \n  \n  \n\n> 注意点：\n>\n> - 极值不一定是最值，最值不一定是极值\n> - 在区间内部的最值是极值，连续函数唯一的极值是最值。\n\n#### 极值的必要条件（Fermat 引理）\n\n==可导的==极值点导数为0（涉及到两个定义：可导的定义、极值点的定义）\n$$\n若该点为极值，且函数连续并且可导，则f'(x_0) = 0\n$$\n\n\n#### 极值的充分条件\n\n- 充分条件一\n- 充分条件二\n  - 充分二还有推论。\n\n#### 关于极值点的定义、必要条件、充分条件的一点理解\n\n极值点的定义中没有提及：1、该点附近是否是==连续==或者==间断== 2、该点处是否可导\n\n如果可导->\n\n### 1.3.2 凹凸性\n\n#### 凹凸性的定义\n\n$$\n若\\forall x_1,x_2 \\in I, 有f(\\frac{x_1+x_2}{2})\\lt \\frac{f(x_1)+f(x_2)}{2},则为凹函数，否则为凸函数\n$$\n\n#### 凹凸函数的充分条件\n\n- 二阶导数的符号 可知 凹凸性\n- 一阶导数=0，二阶导数不等于0 可知凹凸性\n  - 推导 n阶导数的取值与凹凸性\n\n### 1.3.3 拐点\n\n#### 定义：\n\n凹凸函数的转折点：一边凹一边凸\n\n> 注意：问极值点：写横坐标；问极值：写纵坐标；问拐点：横纵坐标都写\n\n#### 拐点的必要条件\n\n二阶可导的拐点 该点处的二阶导数为0\n\n#### 拐点的充分条件（类似极值点的充分条件）\n\n- 拐点的充分条件一\n- 充分条件二\n  - 推论\n\n\n\n### 1.3.4 渐近线\n\n- 水平渐近线\n- 斜渐近线\n- 垂直渐近线\n\n反三角函数公式\n$$\n\\arcsin(x)+\\arccos(x) = \\frac{\\pi}{2} \\\\\n\\arctan(x) +\\arccot(x) = \\frac{\\pi}{2} \\\\\n\\arctan(x) +\\arccot(\\frac{1}{x}) = \n\\begin{cases}\n\\frac{\\pi}{2}  , &x \\gt 0 \\\\\n-\\frac{\\pi}{2} , &x\\lt 0\n\\end{cases}\n\\\\\n$$\n\n### 1.3.5 证明不等式\n\n- 化简构造辅助函数\n- 求导得到单调区间\n- 带入端点证明不等式--该函数在区间内符合该不等式（恒大于0 或者恒小于0）\n\n### 1.3.6 方程的根\n\n- 化简构造辅助函数\n- 求导得到单调区间\n- 带入端点 如果异号则有根且有一个，否则没有\n\n### 1.3.7 微分中值定理\n\n#### Rolle\n\n#### Lagrange\n\n#### Cauthy\n\n#### Taylor\n\n[^4]: [高阶导数公式汇总 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/303161999)\n","source":"_posts/考研数学（高数部分，第二章）复习.md","raw":"---\ntitle: 考研数学（高数部分，第二章）复习\nmathjax: true\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-13 08:27:53\nupdated: 2023-04-13 08:27:53\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg\n---\n\n\n\n{% timeline 2023,blue %}\n\n<!-- timeline 04-12 -->\n\n- 微分部分知识点的构建\n\n<!-- endtimeline -->\n\n<!-- timeline 04-13 -->\n\n- 导数应用\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n[toc]\n\n\n\n# 一元函数微分学\n\n## 1.1 导数与微分\n\n### 导数定义\n\n$$\n\\begin{align}\n& (1) 函数在某一个点x_0上的导数, f'(x_0) = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} \n= \\lim_{\\Delta x \\to 0} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0} \\frac{f(x)- f(x_0)}{x} \\\\\n& (2) 右导数, f'_+(x_0) = \\lim_{\\Delta x \\to 0^+} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0^+} \\frac{f(x)- f(x_0)}{x} \\\\\n& (3) 左导数, f'_-(x_0) = \\lim_{\\Delta x \\to 0^-} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0^-} \\frac{f(x)- f(x_0)}{x} \\\\\n& (4) 导(函)数,f(x) = = \\lim_{\\Delta x \\to 0} \\frac{f(x+\\Delta x)- f(x)}{\\Delta x} \\\\\n& (5) 高阶导数, f^{(n)}(x_0) = \\lim_{\\Delta x \\to 0} \\frac{f^{(n-1)}(x_0+\\Delta x) - f^{(n-1)}(x_0)}{\\Delta x},\\\\\n& 该定义说明了:如果函数f(x)在x_0处存在n阶导数(存在n阶导数)，那么必然的: f^{(n-1)}(x),在某\\mathring{U}(x_0)处有定义，即在某\\mathring{U}(x_0) 内n-1阶可导\n\\end{align}\n$$\n\n### 可导的充要条件\n\n根据导数的定义（导数实际上是极限）所以可导的充要条件和极限的充要条件差不多。\n\n为什么可导的充要条件中不去定义$$F'(x_0)存在 $$：\n$$\n根据定义：f'(x_0) = \\lim_{x \\to x_0} \\frac{f(x)-f(x_0)}{x-x_0};\\\\\n其中并没有定义f'(x_0)\n$$\n该点导数存在不能直接说名该点的导数存在，只有当导函数满足连续条件后才能定义出该点的导数是多少。\n\n可导其实是导函数的极限？：经典错误！ 答案是否定的\n$$\nf(x) = x^2\\sin(\\frac{1}{x}) \\ \\ 在x = 0处导数存在但是导函数极限不存在\n$$\n\n\n### 可导的必要条件 \n\n可导必连续\n\n### 导数的几何意义\n\n变化率，切线、法线\n\n### 导数极限定理\n\n如果 $$f(x)$$==在 $$x_0$$的邻域内连续==，==在 $$x_0$$的去心领域内可导==，且==导函数==在 $$x_0$$ 处的==极限存在==，则 $$f(x)$$在 $$x_0$$处的导数也存在并且等于导函数的极限。\n\n## 1.2 微分\n\n### 微分定义 \n\n$$\n对于函数y = f(x),在x = x_0 处 满足 \\Delta y = A\\Delta x+o(\\Delta x),即称f(x)在x_0处可微 \\\\\n记dy = A\\Delta x \\ (线性主部) , dx = \\Delta x, (请记住)dy \\neq \\Delta y\n$$\n\n由微分的定义以及导数的定义可知:此处的$$ A\\Delta x ,即微分中的线性主部中的A=f'(x_0) $$ 具体推导如下\n$$\n由导数的定义,f(x)在x_0处的导数f'(x_0) = \\lim_{x \\to x_0} \\frac{\\Delta y}{\\Delta x},\\\\\n由微分定义知道\\Delta y = A\\Delta x+o(\\Delta x),故\\\\\nf'(x_0) = \\lim_{x \\to x_0} \\frac{\\Delta y}{\\Delta x} = \\lim_{x \\to x_0} \\frac{A\\Delta x+o(\\Delta x)}{\\Delta x} =  \\lim_{x \\to x_0} A+\\frac{o(\\Delta x)}{\\Delta x} = A\n$$\n\n\n### 关于极限  连续 导数的三个重要结论\n\n- 分式极限存在,且分母极限为0,则分子极限为0\n\n- 分式极限存在且不为0时,分子极限为0,则分母极限也为0\n\n- 如果分子在该点处连续,且分母为0,则分子在该点处的取值为0;\n\n- 一个重要的结论\n  $$\n  f(x) = (x-x_0)^n|x-x_0| 该函数n阶可导n+1阶不可导\n  $$\n\n{% tabs 上述的结论相关的例题 %}\n<!-- tab 例题一:求函数最高几阶可导 -->\n$$\n设函数f(x) = 3x^3+2x^2|x|,问该函数几阶可导\n$$\n\n\n<!-- endtab -->\n\n<!-- tab 例题二:求函数的不可导点 -->\n$$\n设函数f(x) = (x^2-x-2)|x^3-x|,问该函数有几个不可导的点.\n$$\n<!-- endtab -->\n{% endtabs %}\n\n\n\n### 基本函数求导\n\n[上文](###常见函数的一阶导数)\n\n### 四则运算的求导\n\n基础啊\n\n### 复合函数求导\n\n链式法则\n\n### 隐函数求导\n\n- 法一: 带入求导\n- 法二: 公式法 \n- 法三: 全微分\n- \n\n例题:\n$$\ny = y(x), 由y = \\tan(x+y),确定,求y'(x), y''(x)\n$$\n\n\n### 反函数的求导\n\n- 反函数存在的前提: 函数可导且单调\n\n$$\ny = \\Phi(x),设其反函数 x = \\Phi^{-1}(y),则有如下: \\\\\n{\\Phi^{-1}}'(y) = \\frac{dx}{dy} = \\frac{1}{\\frac{dy}{dx}} = \\frac{1}{\\Phi'(x)} \\\\\n{\\Phi^{-1}}''(y) = \\frac{d^2x}{dy^2} = \\frac{\\frac{d\\frac{dy}{dx}}{dx}}{\\frac{dy}{dx}} = -\\frac{\\Phi''(x)}{\\Phi'(x)^3} \\\\\n$$\n\n:exclamation: ==特别注意求三角函数的反函数不能用上述方法，因为三角函数不满足单调==\n\n{% tabs 例题 %}\n<!-- tab 三角函数的反函数的求导-->\n$$\n39 设 y=y(x) 在 (-1,1) 二阶可导, 满足方程: \\left(1-x^2\\right) \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}-x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}+a^2 y=0, 作变 量替换 x=\\sin t 后, y 作为 t的函数满足的方程是\n$$\n<!-- endtab -->\n\n<!-- tab 错解-->\n$$\n\\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\frac{\\mathrm{d} t}{\\mathrm{~d} x}=\\frac{1}{\\cos t} \\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\ \\ 这里\\frac{dt}{dx} \\neq \\frac{1}{\\frac{dx}{dt}} \\ \\ 因为三角函数并不满足单调性\n$$\n\n\n<!-- endtab -->\n\n<!-- tab 正解-->\n$$\n方法 2 y=y(x) 也是 y 作为 t 的函数与 t=\\arcsin x 的复合函数, 由复合函数求导法得\\\\\n\n\\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\frac{\\mathrm{d} t}{\\mathrm{~d} x}=\\frac{1}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}, x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{x}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}\n\n再对 x 求导得\\\\\n\n\\begin{gathered}\n\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}=\\frac{1}{\\left(1-x^2\\right)} \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+\\frac{x}{\\left(1-x^2\\right)^{\\frac{3}{2}}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\\\\n\\left(1-x^2\\right) \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}=\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+\\frac{x}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}=\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}\n\\end{gathered}\\\\\n\n由原方程得\n\n\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+a^2 y=0\n$$\n\n\n<!-- endtab -->\n{% endtabs %}\n\n### 参数方程的求导\n\n链式法则\n\n### 对数求导\n\n解决如下问题:\n\n- 解决幂指函数\n- 对各因式积商 \\ 开方\n\n例如:\n$$\ny = (1+x^2)^{\\sin x},求y'\\\\\ny = \\sqrt[3]{\\frac{(x+1)(x+2)}{x(1+x^2)}}\n$$\n方法:\n\n- 恒等变形\n- 对数求导\n\n### 高阶导数\n\n常见高阶导数公式[^4]:\n\n- 奇偶性\n\n- 递推公式\n\n- Leibniz公式\n\n- Taylor公式: taylor公式中系数的唯一性\n\n## 1.3 导数应用\n\n导数应用涉及内容\n\n- 两点\n  - 极值点\n  - 拐点\n- 两性\n  - 单调性\n  - 凹凸性\n- 两线\n  - 切线、法线\n  - 渐近线\n- 不等式\n- 方程的根\n\n### 1.3.1 单调性与极值点\n\n#### 单调性的定义\n\n#### 单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）\n\n$$\n若x \\in I, and \\ f'(x) \\gt 0 \\Rightarrow 函数f(x)单调递增(反之递减) \\\\\n(1) 函数的一阶导函数可以不存在吗？ 例如为正无穷\\\\\n(2) 补充：(这个条件不能做充要条件的原因之一) 个别点导数为0 不影响函数的单调性。\n$$\n\n\n\n#### 极值的定义\n\n- 极小值定义\n  $$\n  存在一个U(x_0,\\delta),f(x)在该邻域内有定义,且f(x)\\gt f(x_0) \\Rightarrow f(x_0)为极小值\n  $$\n\n- 极大值定义\n  $$\n  存在一个U(x_0,\\delta),f(x)在该邻域内有定义,且f(x)\\lt f(x_0) \\Rightarrow f(x_0)为极大值\n  $$\n  \n  \n  \n\n> 注意点：\n>\n> - 极值不一定是最值，最值不一定是极值\n> - 在区间内部的最值是极值，连续函数唯一的极值是最值。\n\n#### 极值的必要条件（Fermat 引理）\n\n==可导的==极值点导数为0（涉及到两个定义：可导的定义、极值点的定义）\n$$\n若该点为极值，且函数连续并且可导，则f'(x_0) = 0\n$$\n\n\n#### 极值的充分条件\n\n- 充分条件一\n- 充分条件二\n  - 充分二还有推论。\n\n#### 关于极值点的定义、必要条件、充分条件的一点理解\n\n极值点的定义中没有提及：1、该点附近是否是==连续==或者==间断== 2、该点处是否可导\n\n如果可导->\n\n### 1.3.2 凹凸性\n\n#### 凹凸性的定义\n\n$$\n若\\forall x_1,x_2 \\in I, 有f(\\frac{x_1+x_2}{2})\\lt \\frac{f(x_1)+f(x_2)}{2},则为凹函数，否则为凸函数\n$$\n\n#### 凹凸函数的充分条件\n\n- 二阶导数的符号 可知 凹凸性\n- 一阶导数=0，二阶导数不等于0 可知凹凸性\n  - 推导 n阶导数的取值与凹凸性\n\n### 1.3.3 拐点\n\n#### 定义：\n\n凹凸函数的转折点：一边凹一边凸\n\n> 注意：问极值点：写横坐标；问极值：写纵坐标；问拐点：横纵坐标都写\n\n#### 拐点的必要条件\n\n二阶可导的拐点 该点处的二阶导数为0\n\n#### 拐点的充分条件（类似极值点的充分条件）\n\n- 拐点的充分条件一\n- 充分条件二\n  - 推论\n\n\n\n### 1.3.4 渐近线\n\n- 水平渐近线\n- 斜渐近线\n- 垂直渐近线\n\n反三角函数公式\n$$\n\\arcsin(x)+\\arccos(x) = \\frac{\\pi}{2} \\\\\n\\arctan(x) +\\arccot(x) = \\frac{\\pi}{2} \\\\\n\\arctan(x) +\\arccot(\\frac{1}{x}) = \n\\begin{cases}\n\\frac{\\pi}{2}  , &x \\gt 0 \\\\\n-\\frac{\\pi}{2} , &x\\lt 0\n\\end{cases}\n\\\\\n$$\n\n### 1.3.5 证明不等式\n\n- 化简构造辅助函数\n- 求导得到单调区间\n- 带入端点证明不等式--该函数在区间内符合该不等式（恒大于0 或者恒小于0）\n\n### 1.3.6 方程的根\n\n- 化简构造辅助函数\n- 求导得到单调区间\n- 带入端点 如果异号则有根且有一个，否则没有\n\n### 1.3.7 微分中值定理\n\n#### Rolle\n\n#### Lagrange\n\n#### Cauthy\n\n#### Taylor\n\n[^4]: [高阶导数公式汇总 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/303161999)\n","slug":"考研数学（高数部分，第二章）复习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmi0018bsuoa714fwws","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-12</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>微分部分知识点的构建</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-13</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>导数应用</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"一元函数微分学\"><a href=\"#一元函数微分学\" class=\"headerlink\" title=\"一元函数微分学\"></a>一元函数微分学</h1><h2 id=\"1-1-导数与微分\"><a href=\"#1-1-导数与微分\" class=\"headerlink\" title=\"1.1 导数与微分\"></a>1.1 导数与微分</h2><h3 id=\"导数定义\"><a href=\"#导数定义\" class=\"headerlink\" title=\"导数定义\"></a>导数定义</h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 函数在某一个点x_0上的导数, f'(x_0) = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} \n= \\lim_{\\Delta x \\to 0} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0} \\frac{f(x)- f(x_0)}{x} \\\\\n& (2) 右导数, f'_+(x_0) = \\lim_{\\Delta x \\to 0^+} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0^+} \\frac{f(x)- f(x_0)}{x} \\\\\n& (3) 左导数, f'_-(x_0) = \\lim_{\\Delta x \\to 0^-} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0^-} \\frac{f(x)- f(x_0)}{x} \\\\\n& (4) 导(函)数,f(x) = = \\lim_{\\Delta x \\to 0} \\frac{f(x+\\Delta x)- f(x)}{\\Delta x} \\\\\n& (5) 高阶导数, f^{(n)}(x_0) = \\lim_{\\Delta x \\to 0} \\frac{f^{(n-1)}(x_0+\\Delta x) - f^{(n-1)}(x_0)}{\\Delta x},\\\\\n& 该定义说明了:如果函数f(x)在x_0处存在n阶导数(存在n阶导数)，那么必然的: f^{(n-1)}(x),在某\\mathring{U}(x_0)处有定义，即在某\\mathring{U}(x_0) 内n-1阶可导\n\\end{align}</script><h3 id=\"可导的充要条件\"><a href=\"#可导的充要条件\" class=\"headerlink\" title=\"可导的充要条件\"></a>可导的充要条件</h3><p>根据导数的定义（导数实际上是极限）所以可导的充要条件和极限的充要条件差不多。</p>\n<p>为什么可导的充要条件中不去定义<script type=\"math/tex\">F'(x_0)存在</script>：</p>\n<script type=\"math/tex; mode=display\">\n根据定义：f'(x_0) = \\lim_{x \\to x_0} \\frac{f(x)-f(x_0)}{x-x_0};\\\\\n其中并没有定义f'(x_0)</script><p>该点导数存在不能直接说名该点的导数存在，只有当导函数满足连续条件后才能定义出该点的导数是多少。</p>\n<p>可导其实是导函数的极限？：经典错误！ 答案是否定的</p>\n<script type=\"math/tex; mode=display\">\nf(x) = x^2\\sin(\\frac{1}{x}) \\ \\ 在x = 0处导数存在但是导函数极限不存在</script><h3 id=\"可导的必要条件\"><a href=\"#可导的必要条件\" class=\"headerlink\" title=\"可导的必要条件\"></a>可导的必要条件</h3><p>可导必连续</p>\n<h3 id=\"导数的几何意义\"><a href=\"#导数的几何意义\" class=\"headerlink\" title=\"导数的几何意义\"></a>导数的几何意义</h3><p>变化率，切线、法线</p>\n<h3 id=\"导数极限定理\"><a href=\"#导数极限定理\" class=\"headerlink\" title=\"导数极限定理\"></a>导数极限定理</h3><p>如果 <script type=\"math/tex\">f(x)</script>==在 <script type=\"math/tex\">x_0</script>的邻域内连续==，==在 <script type=\"math/tex\">x_0</script>的去心领域内可导==，且==导函数==在 <script type=\"math/tex\">x_0</script> 处的==极限存在==，则 <script type=\"math/tex\">f(x)</script>在 <script type=\"math/tex\">x_0</script>处的导数也存在并且等于导函数的极限。</p>\n<h2 id=\"1-2-微分\"><a href=\"#1-2-微分\" class=\"headerlink\" title=\"1.2 微分\"></a>1.2 微分</h2><h3 id=\"微分定义\"><a href=\"#微分定义\" class=\"headerlink\" title=\"微分定义\"></a>微分定义</h3><script type=\"math/tex; mode=display\">\n对于函数y = f(x),在x = x_0 处 满足 \\Delta y = A\\Delta x+o(\\Delta x),即称f(x)在x_0处可微 \\\\\n记dy = A\\Delta x \\ (线性主部) , dx = \\Delta x, (请记住)dy \\neq \\Delta y</script><p>由微分的定义以及导数的定义可知:此处的<script type=\"math/tex\">A\\Delta x ,即微分中的线性主部中的A=f'(x_0)</script> 具体推导如下</p>\n<script type=\"math/tex; mode=display\">\n由导数的定义,f(x)在x_0处的导数f'(x_0) = \\lim_{x \\to x_0} \\frac{\\Delta y}{\\Delta x},\\\\\n由微分定义知道\\Delta y = A\\Delta x+o(\\Delta x),故\\\\\nf'(x_0) = \\lim_{x \\to x_0} \\frac{\\Delta y}{\\Delta x} = \\lim_{x \\to x_0} \\frac{A\\Delta x+o(\\Delta x)}{\\Delta x} =  \\lim_{x \\to x_0} A+\\frac{o(\\Delta x)}{\\Delta x} = A</script><h3 id=\"关于极限-连续-导数的三个重要结论\"><a href=\"#关于极限-连续-导数的三个重要结论\" class=\"headerlink\" title=\"关于极限  连续 导数的三个重要结论\"></a>关于极限  连续 导数的三个重要结论</h3><ul>\n<li><p>分式极限存在,且分母极限为0,则分子极限为0</p>\n</li>\n<li><p>分式极限存在且不为0时,分子极限为0,则分母极限也为0</p>\n</li>\n<li><p>如果分子在该点处连续,且分母为0,则分子在该点处的取值为0;</p>\n</li>\n<li><p>一个重要的结论</p>\n<script type=\"math/tex; mode=display\">\nf(x) = (x-x_0)^n|x-x_0| 该函数n阶可导n+1阶不可导</script></li>\n</ul>\n<div class=\"tabs\" id=\"上述的结论相关的例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#上述的结论相关的例题-1\">例题一:求函数最高几阶可导</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#上述的结论相关的例题-2\">例题二:求函数的不可导点</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"上述的结论相关的例题-1\"><script type=\"math/tex; mode=display\">\n设函数f(x) = 3x^3+2x^2|x|,问该函数几阶可导</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"上述的结论相关的例题-2\"><script type=\"math/tex; mode=display\">\n设函数f(x) = (x^2-x-2)|x^3-x|,问该函数有几个不可导的点.</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"基本函数求导\"><a href=\"#基本函数求导\" class=\"headerlink\" title=\"基本函数求导\"></a>基本函数求导</h3><p><a href=\"###常见函数的一阶导数\">上文</a></p>\n<h3 id=\"四则运算的求导\"><a href=\"#四则运算的求导\" class=\"headerlink\" title=\"四则运算的求导\"></a>四则运算的求导</h3><p>基础啊</p>\n<h3 id=\"复合函数求导\"><a href=\"#复合函数求导\" class=\"headerlink\" title=\"复合函数求导\"></a>复合函数求导</h3><p>链式法则</p>\n<h3 id=\"隐函数求导\"><a href=\"#隐函数求导\" class=\"headerlink\" title=\"隐函数求导\"></a>隐函数求导</h3><ul>\n<li>法一: 带入求导</li>\n<li>法二: 公式法 </li>\n<li>法三: 全微分</li>\n<li></li>\n</ul>\n<p>例题:</p>\n<script type=\"math/tex; mode=display\">\ny = y(x), 由y = \\tan(x+y),确定,求y'(x), y''(x)</script><h3 id=\"反函数的求导\"><a href=\"#反函数的求导\" class=\"headerlink\" title=\"反函数的求导\"></a>反函数的求导</h3><ul>\n<li>反函数存在的前提: 函数可导且单调</li>\n</ul>\n<script type=\"math/tex; mode=display\">\ny = \\Phi(x),设其反函数 x = \\Phi^{-1}(y),则有如下: \\\\\n{\\Phi^{-1}}'(y) = \\frac{dx}{dy} = \\frac{1}{\\frac{dy}{dx}} = \\frac{1}{\\Phi'(x)} \\\\\n{\\Phi^{-1}}''(y) = \\frac{d^2x}{dy^2} = \\frac{\\frac{d\\frac{dy}{dx}}{dx}}{\\frac{dy}{dx}} = -\\frac{\\Phi''(x)}{\\Phi'(x)^3} \\\\</script><p>:exclamation: ==特别注意求三角函数的反函数不能用上述方法，因为三角函数不满足单调==</p>\n<div class=\"tabs\" id=\"例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#例题-1\">三角函数的反函数的求导</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-2\">错解</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-3\">正解</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"例题-1\"><script type=\"math/tex; mode=display\">\n39 设 y=y(x) 在 (-1,1) 二阶可导, 满足方程: \\left(1-x^2\\right) \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}-x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}+a^2 y=0, 作变 量替换 x=\\sin t 后, y 作为 t的函数满足的方程是</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-2\"><script type=\"math/tex; mode=display\">\n\\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\frac{\\mathrm{d} t}{\\mathrm{~d} x}=\\frac{1}{\\cos t} \\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\ \\ 这里\\frac{dt}{dx} \\neq \\frac{1}{\\frac{dx}{dt}} \\ \\ 因为三角函数并不满足单调性</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-3\"><script type=\"math/tex; mode=display\">\n方法 2 y=y(x) 也是 y 作为 t 的函数与 t=\\arcsin x 的复合函数, 由复合函数求导法得\\\\\n\n\\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\frac{\\mathrm{d} t}{\\mathrm{~d} x}=\\frac{1}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}, x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{x}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}\n\n再对 x 求导得\\\\\n\n\\begin{gathered}\n\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}=\\frac{1}{\\left(1-x^2\\right)} \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+\\frac{x}{\\left(1-x^2\\right)^{\\frac{3}{2}}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\\\\n\\left(1-x^2\\right) \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}=\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+\\frac{x}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}=\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}\n\\end{gathered}\\\\\n\n由原方程得\n\n\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+a^2 y=0</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"参数方程的求导\"><a href=\"#参数方程的求导\" class=\"headerlink\" title=\"参数方程的求导\"></a>参数方程的求导</h3><p>链式法则</p>\n<h3 id=\"对数求导\"><a href=\"#对数求导\" class=\"headerlink\" title=\"对数求导\"></a>对数求导</h3><p>解决如下问题:</p>\n<ul>\n<li>解决幂指函数</li>\n<li>对各因式积商 \\ 开方</li>\n</ul>\n<p>例如:</p>\n<script type=\"math/tex; mode=display\">\ny = (1+x^2)^{\\sin x},求y'\\\\\ny = \\sqrt[3]{\\frac{(x+1)(x+2)}{x(1+x^2)}}</script><p>方法:</p>\n<ul>\n<li>恒等变形</li>\n<li>对数求导</li>\n</ul>\n<h3 id=\"高阶导数\"><a href=\"#高阶导数\" class=\"headerlink\" title=\"高阶导数\"></a>高阶导数</h3><p>常见高阶导数公式<sup><a href=\"#fn_4\" id=\"reffn_4\">4</a></sup>:</p>\n<ul>\n<li><p>奇偶性</p>\n</li>\n<li><p>递推公式</p>\n</li>\n<li><p>Leibniz公式</p>\n</li>\n<li><p>Taylor公式: taylor公式中系数的唯一性</p>\n</li>\n</ul>\n<h2 id=\"1-3-导数应用\"><a href=\"#1-3-导数应用\" class=\"headerlink\" title=\"1.3 导数应用\"></a>1.3 导数应用</h2><p>导数应用涉及内容</p>\n<ul>\n<li>两点<ul>\n<li>极值点</li>\n<li>拐点</li>\n</ul>\n</li>\n<li>两性<ul>\n<li>单调性</li>\n<li>凹凸性</li>\n</ul>\n</li>\n<li>两线<ul>\n<li>切线、法线</li>\n<li>渐近线</li>\n</ul>\n</li>\n<li>不等式</li>\n<li>方程的根</li>\n</ul>\n<h3 id=\"1-3-1-单调性与极值点\"><a href=\"#1-3-1-单调性与极值点\" class=\"headerlink\" title=\"1.3.1 单调性与极值点\"></a>1.3.1 单调性与极值点</h3><h4 id=\"单调性的定义\"><a href=\"#单调性的定义\" class=\"headerlink\" title=\"单调性的定义\"></a>单调性的定义</h4><h4 id=\"单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）\"><a href=\"#单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）\" class=\"headerlink\" title=\"单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）\"></a>单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）</h4><script type=\"math/tex; mode=display\">\n若x \\in I, and \\ f'(x) \\gt 0 \\Rightarrow 函数f(x)单调递增(反之递减) \\\\\n(1) 函数的一阶导函数可以不存在吗？ 例如为正无穷\\\\\n(2) 补充：(这个条件不能做充要条件的原因之一) 个别点导数为0 不影响函数的单调性。</script><h4 id=\"极值的定义\"><a href=\"#极值的定义\" class=\"headerlink\" title=\"极值的定义\"></a>极值的定义</h4><ul>\n<li><p>极小值定义</p>\n<script type=\"math/tex; mode=display\">\n存在一个U(x_0,\\delta),f(x)在该邻域内有定义,且f(x)\\gt f(x_0) \\Rightarrow f(x_0)为极小值</script></li>\n<li><p>极大值定义</p>\n<script type=\"math/tex; mode=display\">\n存在一个U(x_0,\\delta),f(x)在该邻域内有定义,且f(x)\\lt f(x_0) \\Rightarrow f(x_0)为极大值</script></li>\n</ul>\n<blockquote>\n<p>注意点：</p>\n<ul>\n<li>极值不一定是最值，最值不一定是极值</li>\n<li>在区间内部的最值是极值，连续函数唯一的极值是最值。</li>\n</ul>\n</blockquote>\n<h4 id=\"极值的必要条件（Fermat-引理）\"><a href=\"#极值的必要条件（Fermat-引理）\" class=\"headerlink\" title=\"极值的必要条件（Fermat 引理）\"></a>极值的必要条件（Fermat 引理）</h4><p>==可导的==极值点导数为0（涉及到两个定义：可导的定义、极值点的定义）</p>\n<script type=\"math/tex; mode=display\">\n若该点为极值，且函数连续并且可导，则f'(x_0) = 0</script><h4 id=\"极值的充分条件\"><a href=\"#极值的充分条件\" class=\"headerlink\" title=\"极值的充分条件\"></a>极值的充分条件</h4><ul>\n<li>充分条件一</li>\n<li>充分条件二<ul>\n<li>充分二还有推论。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"关于极值点的定义、必要条件、充分条件的一点理解\"><a href=\"#关于极值点的定义、必要条件、充分条件的一点理解\" class=\"headerlink\" title=\"关于极值点的定义、必要条件、充分条件的一点理解\"></a>关于极值点的定义、必要条件、充分条件的一点理解</h4><p>极值点的定义中没有提及：1、该点附近是否是==连续==或者==间断== 2、该点处是否可导</p>\n<p>如果可导-&gt;</p>\n<h3 id=\"1-3-2-凹凸性\"><a href=\"#1-3-2-凹凸性\" class=\"headerlink\" title=\"1.3.2 凹凸性\"></a>1.3.2 凹凸性</h3><h4 id=\"凹凸性的定义\"><a href=\"#凹凸性的定义\" class=\"headerlink\" title=\"凹凸性的定义\"></a>凹凸性的定义</h4><script type=\"math/tex; mode=display\">\n若\\forall x_1,x_2 \\in I, 有f(\\frac{x_1+x_2}{2})\\lt \\frac{f(x_1)+f(x_2)}{2},则为凹函数，否则为凸函数</script><h4 id=\"凹凸函数的充分条件\"><a href=\"#凹凸函数的充分条件\" class=\"headerlink\" title=\"凹凸函数的充分条件\"></a>凹凸函数的充分条件</h4><ul>\n<li>二阶导数的符号 可知 凹凸性</li>\n<li>一阶导数=0，二阶导数不等于0 可知凹凸性<ul>\n<li>推导 n阶导数的取值与凹凸性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-3-拐点\"><a href=\"#1-3-3-拐点\" class=\"headerlink\" title=\"1.3.3 拐点\"></a>1.3.3 拐点</h3><h4 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h4><p>凹凸函数的转折点：一边凹一边凸</p>\n<blockquote>\n<p>注意：问极值点：写横坐标；问极值：写纵坐标；问拐点：横纵坐标都写</p>\n</blockquote>\n<h4 id=\"拐点的必要条件\"><a href=\"#拐点的必要条件\" class=\"headerlink\" title=\"拐点的必要条件\"></a>拐点的必要条件</h4><p>二阶可导的拐点 该点处的二阶导数为0</p>\n<h4 id=\"拐点的充分条件（类似极值点的充分条件）\"><a href=\"#拐点的充分条件（类似极值点的充分条件）\" class=\"headerlink\" title=\"拐点的充分条件（类似极值点的充分条件）\"></a>拐点的充分条件（类似极值点的充分条件）</h4><ul>\n<li>拐点的充分条件一</li>\n<li>充分条件二<ul>\n<li>推论</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-4-渐近线\"><a href=\"#1-3-4-渐近线\" class=\"headerlink\" title=\"1.3.4 渐近线\"></a>1.3.4 渐近线</h3><ul>\n<li>水平渐近线</li>\n<li>斜渐近线</li>\n<li>垂直渐近线</li>\n</ul>\n<p>反三角函数公式</p>\n<script type=\"math/tex; mode=display\">\n\\arcsin(x)+\\arccos(x) = \\frac{\\pi}{2} \\\\\n\\arctan(x) +\\arccot(x) = \\frac{\\pi}{2} \\\\\n\\arctan(x) +\\arccot(\\frac{1}{x}) = \n\\begin{cases}\n\\frac{\\pi}{2}  , &x \\gt 0 \\\\\n-\\frac{\\pi}{2} , &x\\lt 0\n\\end{cases}\n\\\\</script><h3 id=\"1-3-5-证明不等式\"><a href=\"#1-3-5-证明不等式\" class=\"headerlink\" title=\"1.3.5 证明不等式\"></a>1.3.5 证明不等式</h3><ul>\n<li>化简构造辅助函数</li>\n<li>求导得到单调区间</li>\n<li>带入端点证明不等式—该函数在区间内符合该不等式（恒大于0 或者恒小于0）</li>\n</ul>\n<h3 id=\"1-3-6-方程的根\"><a href=\"#1-3-6-方程的根\" class=\"headerlink\" title=\"1.3.6 方程的根\"></a>1.3.6 方程的根</h3><ul>\n<li>化简构造辅助函数</li>\n<li>求导得到单调区间</li>\n<li>带入端点 如果异号则有根且有一个，否则没有</li>\n</ul>\n<h3 id=\"1-3-7-微分中值定理\"><a href=\"#1-3-7-微分中值定理\" class=\"headerlink\" title=\"1.3.7 微分中值定理\"></a>1.3.7 微分中值定理</h3><h4 id=\"Rolle\"><a href=\"#Rolle\" class=\"headerlink\" title=\"Rolle\"></a>Rolle</h4><h4 id=\"Lagrange\"><a href=\"#Lagrange\" class=\"headerlink\" title=\"Lagrange\"></a>Lagrange</h4><h4 id=\"Cauthy\"><a href=\"#Cauthy\" class=\"headerlink\" title=\"Cauthy\"></a>Cauthy</h4><h4 id=\"Taylor\"><a href=\"#Taylor\" class=\"headerlink\" title=\"Taylor\"></a>Taylor</h4><blockquote id=\"fn_4\">\n<sup>4</sup>. <a href=\"https://zhuanlan.zhihu.com/p/303161999\">高阶导数公式汇总 - 知乎 (zhihu.com)</a><a href=\"#reffn_4\" title=\"Jump back to footnote [4] in the text.\"> ↩</a>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-12</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>微分部分知识点的构建</li>\n</ul>\n</div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-13</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>导数应用</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"一元函数微分学\"><a href=\"#一元函数微分学\" class=\"headerlink\" title=\"一元函数微分学\"></a>一元函数微分学</h1><h2 id=\"1-1-导数与微分\"><a href=\"#1-1-导数与微分\" class=\"headerlink\" title=\"1.1 导数与微分\"></a>1.1 导数与微分</h2><h3 id=\"导数定义\"><a href=\"#导数定义\" class=\"headerlink\" title=\"导数定义\"></a>导数定义</h3><script type=\"math/tex; mode=display\">\n\\begin{align}\n& (1) 函数在某一个点x_0上的导数, f'(x_0) = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} \n= \\lim_{\\Delta x \\to 0} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0} \\frac{f(x)- f(x_0)}{x} \\\\\n& (2) 右导数, f'_+(x_0) = \\lim_{\\Delta x \\to 0^+} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0^+} \\frac{f(x)- f(x_0)}{x} \\\\\n& (3) 左导数, f'_-(x_0) = \\lim_{\\Delta x \\to 0^-} \\frac{f(x_0+\\Delta x)- f(x_0)}{\\Delta x} \n= \\lim_{x \\to x_0^-} \\frac{f(x)- f(x_0)}{x} \\\\\n& (4) 导(函)数,f(x) = = \\lim_{\\Delta x \\to 0} \\frac{f(x+\\Delta x)- f(x)}{\\Delta x} \\\\\n& (5) 高阶导数, f^{(n)}(x_0) = \\lim_{\\Delta x \\to 0} \\frac{f^{(n-1)}(x_0+\\Delta x) - f^{(n-1)}(x_0)}{\\Delta x},\\\\\n& 该定义说明了:如果函数f(x)在x_0处存在n阶导数(存在n阶导数)，那么必然的: f^{(n-1)}(x),在某\\mathring{U}(x_0)处有定义，即在某\\mathring{U}(x_0) 内n-1阶可导\n\\end{align}</script><h3 id=\"可导的充要条件\"><a href=\"#可导的充要条件\" class=\"headerlink\" title=\"可导的充要条件\"></a>可导的充要条件</h3><p>根据导数的定义（导数实际上是极限）所以可导的充要条件和极限的充要条件差不多。</p>\n<p>为什么可导的充要条件中不去定义<script type=\"math/tex\">F'(x_0)存在</script>：</p>\n<script type=\"math/tex; mode=display\">\n根据定义：f'(x_0) = \\lim_{x \\to x_0} \\frac{f(x)-f(x_0)}{x-x_0};\\\\\n其中并没有定义f'(x_0)</script><p>该点导数存在不能直接说名该点的导数存在，只有当导函数满足连续条件后才能定义出该点的导数是多少。</p>\n<p>可导其实是导函数的极限？：经典错误！ 答案是否定的</p>\n<script type=\"math/tex; mode=display\">\nf(x) = x^2\\sin(\\frac{1}{x}) \\ \\ 在x = 0处导数存在但是导函数极限不存在</script><h3 id=\"可导的必要条件\"><a href=\"#可导的必要条件\" class=\"headerlink\" title=\"可导的必要条件\"></a>可导的必要条件</h3><p>可导必连续</p>\n<h3 id=\"导数的几何意义\"><a href=\"#导数的几何意义\" class=\"headerlink\" title=\"导数的几何意义\"></a>导数的几何意义</h3><p>变化率，切线、法线</p>\n<h3 id=\"导数极限定理\"><a href=\"#导数极限定理\" class=\"headerlink\" title=\"导数极限定理\"></a>导数极限定理</h3><p>如果 <script type=\"math/tex\">f(x)</script>==在 <script type=\"math/tex\">x_0</script>的邻域内连续==，==在 <script type=\"math/tex\">x_0</script>的去心领域内可导==，且==导函数==在 <script type=\"math/tex\">x_0</script> 处的==极限存在==，则 <script type=\"math/tex\">f(x)</script>在 <script type=\"math/tex\">x_0</script>处的导数也存在并且等于导函数的极限。</p>\n<h2 id=\"1-2-微分\"><a href=\"#1-2-微分\" class=\"headerlink\" title=\"1.2 微分\"></a>1.2 微分</h2><h3 id=\"微分定义\"><a href=\"#微分定义\" class=\"headerlink\" title=\"微分定义\"></a>微分定义</h3><script type=\"math/tex; mode=display\">\n对于函数y = f(x),在x = x_0 处 满足 \\Delta y = A\\Delta x+o(\\Delta x),即称f(x)在x_0处可微 \\\\\n记dy = A\\Delta x \\ (线性主部) , dx = \\Delta x, (请记住)dy \\neq \\Delta y</script><p>由微分的定义以及导数的定义可知:此处的<script type=\"math/tex\">A\\Delta x ,即微分中的线性主部中的A=f'(x_0)</script> 具体推导如下</p>\n<script type=\"math/tex; mode=display\">\n由导数的定义,f(x)在x_0处的导数f'(x_0) = \\lim_{x \\to x_0} \\frac{\\Delta y}{\\Delta x},\\\\\n由微分定义知道\\Delta y = A\\Delta x+o(\\Delta x),故\\\\\nf'(x_0) = \\lim_{x \\to x_0} \\frac{\\Delta y}{\\Delta x} = \\lim_{x \\to x_0} \\frac{A\\Delta x+o(\\Delta x)}{\\Delta x} =  \\lim_{x \\to x_0} A+\\frac{o(\\Delta x)}{\\Delta x} = A</script><h3 id=\"关于极限-连续-导数的三个重要结论\"><a href=\"#关于极限-连续-导数的三个重要结论\" class=\"headerlink\" title=\"关于极限  连续 导数的三个重要结论\"></a>关于极限  连续 导数的三个重要结论</h3><ul>\n<li><p>分式极限存在,且分母极限为0,则分子极限为0</p>\n</li>\n<li><p>分式极限存在且不为0时,分子极限为0,则分母极限也为0</p>\n</li>\n<li><p>如果分子在该点处连续,且分母为0,则分子在该点处的取值为0;</p>\n</li>\n<li><p>一个重要的结论</p>\n<script type=\"math/tex; mode=display\">\nf(x) = (x-x_0)^n|x-x_0| 该函数n阶可导n+1阶不可导</script></li>\n</ul>\n<div class=\"tabs\" id=\"上述的结论相关的例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#上述的结论相关的例题-1\">例题一:求函数最高几阶可导</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#上述的结论相关的例题-2\">例题二:求函数的不可导点</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"上述的结论相关的例题-1\"><script type=\"math/tex; mode=display\">\n设函数f(x) = 3x^3+2x^2|x|,问该函数几阶可导</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"上述的结论相关的例题-2\"><script type=\"math/tex; mode=display\">\n设函数f(x) = (x^2-x-2)|x^3-x|,问该函数有几个不可导的点.</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"基本函数求导\"><a href=\"#基本函数求导\" class=\"headerlink\" title=\"基本函数求导\"></a>基本函数求导</h3><p><a href=\"###常见函数的一阶导数\">上文</a></p>\n<h3 id=\"四则运算的求导\"><a href=\"#四则运算的求导\" class=\"headerlink\" title=\"四则运算的求导\"></a>四则运算的求导</h3><p>基础啊</p>\n<h3 id=\"复合函数求导\"><a href=\"#复合函数求导\" class=\"headerlink\" title=\"复合函数求导\"></a>复合函数求导</h3><p>链式法则</p>\n<h3 id=\"隐函数求导\"><a href=\"#隐函数求导\" class=\"headerlink\" title=\"隐函数求导\"></a>隐函数求导</h3><ul>\n<li>法一: 带入求导</li>\n<li>法二: 公式法 </li>\n<li>法三: 全微分</li>\n<li></li>\n</ul>\n<p>例题:</p>\n<script type=\"math/tex; mode=display\">\ny = y(x), 由y = \\tan(x+y),确定,求y'(x), y''(x)</script><h3 id=\"反函数的求导\"><a href=\"#反函数的求导\" class=\"headerlink\" title=\"反函数的求导\"></a>反函数的求导</h3><ul>\n<li>反函数存在的前提: 函数可导且单调</li>\n</ul>\n<script type=\"math/tex; mode=display\">\ny = \\Phi(x),设其反函数 x = \\Phi^{-1}(y),则有如下: \\\\\n{\\Phi^{-1}}'(y) = \\frac{dx}{dy} = \\frac{1}{\\frac{dy}{dx}} = \\frac{1}{\\Phi'(x)} \\\\\n{\\Phi^{-1}}''(y) = \\frac{d^2x}{dy^2} = \\frac{\\frac{d\\frac{dy}{dx}}{dx}}{\\frac{dy}{dx}} = -\\frac{\\Phi''(x)}{\\Phi'(x)^3} \\\\</script><p>:exclamation: ==特别注意求三角函数的反函数不能用上述方法，因为三角函数不满足单调==</p>\n<div class=\"tabs\" id=\"例题\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#例题-1\">三角函数的反函数的求导</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-2\">错解</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#例题-3\">正解</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"例题-1\"><script type=\"math/tex; mode=display\">\n39 设 y=y(x) 在 (-1,1) 二阶可导, 满足方程: \\left(1-x^2\\right) \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}-x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}+a^2 y=0, 作变 量替换 x=\\sin t 后, y 作为 t的函数满足的方程是</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-2\"><script type=\"math/tex; mode=display\">\n\\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\frac{\\mathrm{d} t}{\\mathrm{~d} x}=\\frac{1}{\\cos t} \\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\ \\ 这里\\frac{dt}{dx} \\neq \\frac{1}{\\frac{dx}{dt}} \\ \\ 因为三角函数并不满足单调性</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"例题-3\"><script type=\"math/tex; mode=display\">\n方法 2 y=y(x) 也是 y 作为 t 的函数与 t=\\arcsin x 的复合函数, 由复合函数求导法得\\\\\n\n\\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\frac{\\mathrm{d} t}{\\mathrm{~d} x}=\\frac{1}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}, x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}=\\frac{x}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}\n\n再对 x 求导得\\\\\n\n\\begin{gathered}\n\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}=\\frac{1}{\\left(1-x^2\\right)} \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+\\frac{x}{\\left(1-x^2\\right)^{\\frac{3}{2}}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t} \\\\\n\\left(1-x^2\\right) \\frac{\\mathrm{d}^2 y}{\\mathrm{~d} x^2}=\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+\\frac{x}{\\sqrt{1-x^2}} \\frac{\\mathrm{d} y}{\\mathrm{~d} t}=\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+x \\frac{\\mathrm{d} y}{\\mathrm{~d} x}\n\\end{gathered}\\\\\n\n由原方程得\n\n\\frac{\\mathrm{d}^2 y}{\\mathrm{~d} t^2}+a^2 y=0</script><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h3 id=\"参数方程的求导\"><a href=\"#参数方程的求导\" class=\"headerlink\" title=\"参数方程的求导\"></a>参数方程的求导</h3><p>链式法则</p>\n<h3 id=\"对数求导\"><a href=\"#对数求导\" class=\"headerlink\" title=\"对数求导\"></a>对数求导</h3><p>解决如下问题:</p>\n<ul>\n<li>解决幂指函数</li>\n<li>对各因式积商 \\ 开方</li>\n</ul>\n<p>例如:</p>\n<script type=\"math/tex; mode=display\">\ny = (1+x^2)^{\\sin x},求y'\\\\\ny = \\sqrt[3]{\\frac{(x+1)(x+2)}{x(1+x^2)}}</script><p>方法:</p>\n<ul>\n<li>恒等变形</li>\n<li>对数求导</li>\n</ul>\n<h3 id=\"高阶导数\"><a href=\"#高阶导数\" class=\"headerlink\" title=\"高阶导数\"></a>高阶导数</h3><p>常见高阶导数公式<sup><a href=\"#fn_4\" id=\"reffn_4\">4</a></sup>:</p>\n<ul>\n<li><p>奇偶性</p>\n</li>\n<li><p>递推公式</p>\n</li>\n<li><p>Leibniz公式</p>\n</li>\n<li><p>Taylor公式: taylor公式中系数的唯一性</p>\n</li>\n</ul>\n<h2 id=\"1-3-导数应用\"><a href=\"#1-3-导数应用\" class=\"headerlink\" title=\"1.3 导数应用\"></a>1.3 导数应用</h2><p>导数应用涉及内容</p>\n<ul>\n<li>两点<ul>\n<li>极值点</li>\n<li>拐点</li>\n</ul>\n</li>\n<li>两性<ul>\n<li>单调性</li>\n<li>凹凸性</li>\n</ul>\n</li>\n<li>两线<ul>\n<li>切线、法线</li>\n<li>渐近线</li>\n</ul>\n</li>\n<li>不等式</li>\n<li>方程的根</li>\n</ul>\n<h3 id=\"1-3-1-单调性与极值点\"><a href=\"#1-3-1-单调性与极值点\" class=\"headerlink\" title=\"1.3.1 单调性与极值点\"></a>1.3.1 单调性与极值点</h3><h4 id=\"单调性的定义\"><a href=\"#单调性的定义\" class=\"headerlink\" title=\"单调性的定义\"></a>单调性的定义</h4><h4 id=\"单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）\"><a href=\"#单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）\" class=\"headerlink\" title=\"单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）\"></a>单调性的充分条件（充分条件！如果你想推导这个函数单调可以通过这个方法）</h4><script type=\"math/tex; mode=display\">\n若x \\in I, and \\ f'(x) \\gt 0 \\Rightarrow 函数f(x)单调递增(反之递减) \\\\\n(1) 函数的一阶导函数可以不存在吗？ 例如为正无穷\\\\\n(2) 补充：(这个条件不能做充要条件的原因之一) 个别点导数为0 不影响函数的单调性。</script><h4 id=\"极值的定义\"><a href=\"#极值的定义\" class=\"headerlink\" title=\"极值的定义\"></a>极值的定义</h4><ul>\n<li><p>极小值定义</p>\n<script type=\"math/tex; mode=display\">\n存在一个U(x_0,\\delta),f(x)在该邻域内有定义,且f(x)\\gt f(x_0) \\Rightarrow f(x_0)为极小值</script></li>\n<li><p>极大值定义</p>\n<script type=\"math/tex; mode=display\">\n存在一个U(x_0,\\delta),f(x)在该邻域内有定义,且f(x)\\lt f(x_0) \\Rightarrow f(x_0)为极大值</script></li>\n</ul>\n<blockquote>\n<p>注意点：</p>\n<ul>\n<li>极值不一定是最值，最值不一定是极值</li>\n<li>在区间内部的最值是极值，连续函数唯一的极值是最值。</li>\n</ul>\n</blockquote>\n<h4 id=\"极值的必要条件（Fermat-引理）\"><a href=\"#极值的必要条件（Fermat-引理）\" class=\"headerlink\" title=\"极值的必要条件（Fermat 引理）\"></a>极值的必要条件（Fermat 引理）</h4><p>==可导的==极值点导数为0（涉及到两个定义：可导的定义、极值点的定义）</p>\n<script type=\"math/tex; mode=display\">\n若该点为极值，且函数连续并且可导，则f'(x_0) = 0</script><h4 id=\"极值的充分条件\"><a href=\"#极值的充分条件\" class=\"headerlink\" title=\"极值的充分条件\"></a>极值的充分条件</h4><ul>\n<li>充分条件一</li>\n<li>充分条件二<ul>\n<li>充分二还有推论。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"关于极值点的定义、必要条件、充分条件的一点理解\"><a href=\"#关于极值点的定义、必要条件、充分条件的一点理解\" class=\"headerlink\" title=\"关于极值点的定义、必要条件、充分条件的一点理解\"></a>关于极值点的定义、必要条件、充分条件的一点理解</h4><p>极值点的定义中没有提及：1、该点附近是否是==连续==或者==间断== 2、该点处是否可导</p>\n<p>如果可导-&gt;</p>\n<h3 id=\"1-3-2-凹凸性\"><a href=\"#1-3-2-凹凸性\" class=\"headerlink\" title=\"1.3.2 凹凸性\"></a>1.3.2 凹凸性</h3><h4 id=\"凹凸性的定义\"><a href=\"#凹凸性的定义\" class=\"headerlink\" title=\"凹凸性的定义\"></a>凹凸性的定义</h4><script type=\"math/tex; mode=display\">\n若\\forall x_1,x_2 \\in I, 有f(\\frac{x_1+x_2}{2})\\lt \\frac{f(x_1)+f(x_2)}{2},则为凹函数，否则为凸函数</script><h4 id=\"凹凸函数的充分条件\"><a href=\"#凹凸函数的充分条件\" class=\"headerlink\" title=\"凹凸函数的充分条件\"></a>凹凸函数的充分条件</h4><ul>\n<li>二阶导数的符号 可知 凹凸性</li>\n<li>一阶导数=0，二阶导数不等于0 可知凹凸性<ul>\n<li>推导 n阶导数的取值与凹凸性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-3-拐点\"><a href=\"#1-3-3-拐点\" class=\"headerlink\" title=\"1.3.3 拐点\"></a>1.3.3 拐点</h3><h4 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h4><p>凹凸函数的转折点：一边凹一边凸</p>\n<blockquote>\n<p>注意：问极值点：写横坐标；问极值：写纵坐标；问拐点：横纵坐标都写</p>\n</blockquote>\n<h4 id=\"拐点的必要条件\"><a href=\"#拐点的必要条件\" class=\"headerlink\" title=\"拐点的必要条件\"></a>拐点的必要条件</h4><p>二阶可导的拐点 该点处的二阶导数为0</p>\n<h4 id=\"拐点的充分条件（类似极值点的充分条件）\"><a href=\"#拐点的充分条件（类似极值点的充分条件）\" class=\"headerlink\" title=\"拐点的充分条件（类似极值点的充分条件）\"></a>拐点的充分条件（类似极值点的充分条件）</h4><ul>\n<li>拐点的充分条件一</li>\n<li>充分条件二<ul>\n<li>推论</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-4-渐近线\"><a href=\"#1-3-4-渐近线\" class=\"headerlink\" title=\"1.3.4 渐近线\"></a>1.3.4 渐近线</h3><ul>\n<li>水平渐近线</li>\n<li>斜渐近线</li>\n<li>垂直渐近线</li>\n</ul>\n<p>反三角函数公式</p>\n<script type=\"math/tex; mode=display\">\n\\arcsin(x)+\\arccos(x) = \\frac{\\pi}{2} \\\\\n\\arctan(x) +\\arccot(x) = \\frac{\\pi}{2} \\\\\n\\arctan(x) +\\arccot(\\frac{1}{x}) = \n\\begin{cases}\n\\frac{\\pi}{2}  , &x \\gt 0 \\\\\n-\\frac{\\pi}{2} , &x\\lt 0\n\\end{cases}\n\\\\</script><h3 id=\"1-3-5-证明不等式\"><a href=\"#1-3-5-证明不等式\" class=\"headerlink\" title=\"1.3.5 证明不等式\"></a>1.3.5 证明不等式</h3><ul>\n<li>化简构造辅助函数</li>\n<li>求导得到单调区间</li>\n<li>带入端点证明不等式—该函数在区间内符合该不等式（恒大于0 或者恒小于0）</li>\n</ul>\n<h3 id=\"1-3-6-方程的根\"><a href=\"#1-3-6-方程的根\" class=\"headerlink\" title=\"1.3.6 方程的根\"></a>1.3.6 方程的根</h3><ul>\n<li>化简构造辅助函数</li>\n<li>求导得到单调区间</li>\n<li>带入端点 如果异号则有根且有一个，否则没有</li>\n</ul>\n<h3 id=\"1-3-7-微分中值定理\"><a href=\"#1-3-7-微分中值定理\" class=\"headerlink\" title=\"1.3.7 微分中值定理\"></a>1.3.7 微分中值定理</h3><h4 id=\"Rolle\"><a href=\"#Rolle\" class=\"headerlink\" title=\"Rolle\"></a>Rolle</h4><h4 id=\"Lagrange\"><a href=\"#Lagrange\" class=\"headerlink\" title=\"Lagrange\"></a>Lagrange</h4><h4 id=\"Cauthy\"><a href=\"#Cauthy\" class=\"headerlink\" title=\"Cauthy\"></a>Cauthy</h4><h4 id=\"Taylor\"><a href=\"#Taylor\" class=\"headerlink\" title=\"Taylor\"></a>Taylor</h4><blockquote id=\"fn_4\">\n<sup>4</sup>. <a href=\"https://zhuanlan.zhihu.com/p/303161999\">高阶导数公式汇总 - 知乎 (zhihu.com)</a><a href=\"#reffn_4\" title=\"Jump back to footnote [4] in the text.\"> ↩</a>\n</blockquote>\n"},{"title":"考研数学（高数部分，第四章）复习","mathjax":true,"copyright_author":"NinoNeumann","copyright_author_href":"https://ninoneumann.cn/","date":"2023-04-21T01:37:11.000Z","updated":"2023-04-21T01:37:11.000Z","keywords":"数学","description":"苦逼二战学生的再学习记录","cover":"https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg","_content":"\n\n\n{% timeline 2023,blue %}\n\n<!-- timeline 04-21 -->\n\n- 微分方程初步复习\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n[toc]\n\n\n\n# 微分方程\n\n- 可分离\n- 一节齐次\n- 一阶线性\n- Bernoulli\n- 全微分\n\n# 一阶微分方程\n\n## 一阶微分方程的概念\n\n微分方程：含有未知函数的放曾\n\n微分方程的阶：未知函数的导数的最高阶数\n\n微分方程的解：满足微分方程的函数\n\n微分方程的解：含有与微分方程阶数相同个数的、任意常数的解\n\n## 一阶微分方程的解法\n\n### 可分离变量（题型方法论）\n\n形式：\n$$\n\\frac{dy}{dx} = f(x)g(y)\n$$\n怎么做你懂的。\n\n推论\n$$\n\\frac{dy}{dx} = f(ax+by+c) \\\\\nasume: \\ u = ax+by+c ,\\ \\ \\  then \\ \\ \\ \\frac{du}{dx} = a+b\\frac{dy}{dx} , then  \\ \\ \\frac{du}{dx} = a+bf(u).  \n$$\n\n### 一阶齐次\n\n$$\n\\frac{dy}{dx} = f(\\frac{y}{x}) \\ \\ 整体代换。\n$$\n\n## 一阶线性\n\n### 一阶线性齐次\n\n### 一阶线性非齐次\n\n# 二阶微分方程\n\n二阶常系数线性\n\n二阶可降阶\n\n欧拉\n\n差分（数三）\n\n## 二阶线性方程解的性质与结构\n\n 二阶线性微分方程的形式：\n$$\ny'' +p(x) y'+ q(x)y = f(x)\n$$\n\n### 性质：\n\n- $$y_1 y_2$$ 为齐次微分方程的解则$$c_1y_1+c_2y_2$$ 也是解  齐次方程解线性组合仍然为解。\n- $$y_1^* y_2^*$$ 为非齐次微分方程的解，则$$y_1^* - y_2^*$$ 为齐次微分方程的解\n- $$y$$ 为齐次方程的解 $$y^*$$为非齐次方程的解 $$y+y*$$ 为非齐次微分方程的解\n\n### 解的结构\n\n- $$y_1 y_2$$两个二阶齐次方程的 无关的解，齐次方程的通解为$$c_1y_1+c_2y_2$$ 为二阶齐次线性微分方程的通解\n\n- $$y_1 y_2$$两个二阶齐次方程的 无关的解，$$y*$$ 为非齐次方程的特解 ，则非齐次方程的通解为 $$c_1y_1+c_2y_2+y^*$$\n\n- 叠加原理\n  $$\n  若 y_1^* 为 y'' +p(x) y'+ q(x)y = f_1(x) 的特解 \\\\\n  y_2^* 为 y'' +p(x) y'+ q(x)y = f_2(x) 的特解 \\\\\n  则y_1^*+y_2^* 为y'' +p(x) y'+ q(x)y = f_2(x)+f_1(x)的特解\n  $$\n  \n\n## 二阶常系数\n\n### 二阶常系数线性齐次[^1]\n\n \n\n解线性方程\n\n### 二阶常系数线性非齐次\n\n$$\ny'' +py'+ qy = f(x)\n$$\n\n\n\n二阶常系数线性齐次+特解\n\n- $$f(x) = e^{\\lambda x}P_m(x), m是方程P(x)的最高次数$$\n\n  求特解：设$$y^*= x^k e^{\\lambda x}Q_m(x),m是上述方程P(x)的最高次数,k是特征方程中根的重数$$ \n\n- $$f(x) = e^{\\alpha x}[P_m(x)\\cos(\\beta x)+P_n(x)\\sin(\\beta x)],m、n分别是方程P_m(x)、P_n(x)的最高次数$$\n\n  求特解：\n  $$\n  y^*= x^k e^{\\alpha x}[Q_l(x)\\cos(\\beta x) + Q_l(x)\\sin(\\beta x)],l = \\max(m,n),k = \n  \\begin{cases}\n  & 1, \\alpha \\pm \\beta i也是齐次方程的共轭复数  \\\\\n  & 0  \\\\\n  \\end{cases}\n  $$\n  \n\n\n\n# n阶微分方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n[^1]: [常系数二阶线性齐次微分方程的求解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25518193)\n","source":"_posts/考研数学（高数部分，第四章）复习.md","raw":"---\ntitle: 考研数学（高数部分，第四章）复习\nmathjax: true\ncopyright_author: NinoNeumann\ncopyright_author_href: 'https://ninoneumann.cn/'\ndate: 2023-04-21 09:37:11\nupdated: 2023-04-21 09:37:11\ntags:\n- 考研\n- 二战\n- 数学\ncategories: 一个计科生的考研二战日记\nkeywords: 数学\ndescription: 苦逼二战学生的再学习记录\ncover: https://resource.ninoneumann.cn/Cover_img/89803879_p0.jpg\n---\n\n\n\n{% timeline 2023,blue %}\n\n<!-- timeline 04-21 -->\n\n- 微分方程初步复习\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n[toc]\n\n\n\n# 微分方程\n\n- 可分离\n- 一节齐次\n- 一阶线性\n- Bernoulli\n- 全微分\n\n# 一阶微分方程\n\n## 一阶微分方程的概念\n\n微分方程：含有未知函数的放曾\n\n微分方程的阶：未知函数的导数的最高阶数\n\n微分方程的解：满足微分方程的函数\n\n微分方程的解：含有与微分方程阶数相同个数的、任意常数的解\n\n## 一阶微分方程的解法\n\n### 可分离变量（题型方法论）\n\n形式：\n$$\n\\frac{dy}{dx} = f(x)g(y)\n$$\n怎么做你懂的。\n\n推论\n$$\n\\frac{dy}{dx} = f(ax+by+c) \\\\\nasume: \\ u = ax+by+c ,\\ \\ \\  then \\ \\ \\ \\frac{du}{dx} = a+b\\frac{dy}{dx} , then  \\ \\ \\frac{du}{dx} = a+bf(u).  \n$$\n\n### 一阶齐次\n\n$$\n\\frac{dy}{dx} = f(\\frac{y}{x}) \\ \\ 整体代换。\n$$\n\n## 一阶线性\n\n### 一阶线性齐次\n\n### 一阶线性非齐次\n\n# 二阶微分方程\n\n二阶常系数线性\n\n二阶可降阶\n\n欧拉\n\n差分（数三）\n\n## 二阶线性方程解的性质与结构\n\n 二阶线性微分方程的形式：\n$$\ny'' +p(x) y'+ q(x)y = f(x)\n$$\n\n### 性质：\n\n- $$y_1 y_2$$ 为齐次微分方程的解则$$c_1y_1+c_2y_2$$ 也是解  齐次方程解线性组合仍然为解。\n- $$y_1^* y_2^*$$ 为非齐次微分方程的解，则$$y_1^* - y_2^*$$ 为齐次微分方程的解\n- $$y$$ 为齐次方程的解 $$y^*$$为非齐次方程的解 $$y+y*$$ 为非齐次微分方程的解\n\n### 解的结构\n\n- $$y_1 y_2$$两个二阶齐次方程的 无关的解，齐次方程的通解为$$c_1y_1+c_2y_2$$ 为二阶齐次线性微分方程的通解\n\n- $$y_1 y_2$$两个二阶齐次方程的 无关的解，$$y*$$ 为非齐次方程的特解 ，则非齐次方程的通解为 $$c_1y_1+c_2y_2+y^*$$\n\n- 叠加原理\n  $$\n  若 y_1^* 为 y'' +p(x) y'+ q(x)y = f_1(x) 的特解 \\\\\n  y_2^* 为 y'' +p(x) y'+ q(x)y = f_2(x) 的特解 \\\\\n  则y_1^*+y_2^* 为y'' +p(x) y'+ q(x)y = f_2(x)+f_1(x)的特解\n  $$\n  \n\n## 二阶常系数\n\n### 二阶常系数线性齐次[^1]\n\n \n\n解线性方程\n\n### 二阶常系数线性非齐次\n\n$$\ny'' +py'+ qy = f(x)\n$$\n\n\n\n二阶常系数线性齐次+特解\n\n- $$f(x) = e^{\\lambda x}P_m(x), m是方程P(x)的最高次数$$\n\n  求特解：设$$y^*= x^k e^{\\lambda x}Q_m(x),m是上述方程P(x)的最高次数,k是特征方程中根的重数$$ \n\n- $$f(x) = e^{\\alpha x}[P_m(x)\\cos(\\beta x)+P_n(x)\\sin(\\beta x)],m、n分别是方程P_m(x)、P_n(x)的最高次数$$\n\n  求特解：\n  $$\n  y^*= x^k e^{\\alpha x}[Q_l(x)\\cos(\\beta x) + Q_l(x)\\sin(\\beta x)],l = \\max(m,n),k = \n  \\begin{cases}\n  & 1, \\alpha \\pm \\beta i也是齐次方程的共轭复数  \\\\\n  & 0  \\\\\n  \\end{cases}\n  $$\n  \n\n\n\n# n阶微分方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n[^1]: [常系数二阶线性齐次微分方程的求解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25518193)\n","slug":"考研数学（高数部分，第四章）复习","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clgtgvwmj001bbsuo1m576c6f","content":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-21</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>微分方程初步复习</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"微分方程\"><a href=\"#微分方程\" class=\"headerlink\" title=\"微分方程\"></a>微分方程</h1><ul>\n<li>可分离</li>\n<li>一节齐次</li>\n<li>一阶线性</li>\n<li>Bernoulli</li>\n<li>全微分</li>\n</ul>\n<h1 id=\"一阶微分方程\"><a href=\"#一阶微分方程\" class=\"headerlink\" title=\"一阶微分方程\"></a>一阶微分方程</h1><h2 id=\"一阶微分方程的概念\"><a href=\"#一阶微分方程的概念\" class=\"headerlink\" title=\"一阶微分方程的概念\"></a>一阶微分方程的概念</h2><p>微分方程：含有未知函数的放曾</p>\n<p>微分方程的阶：未知函数的导数的最高阶数</p>\n<p>微分方程的解：满足微分方程的函数</p>\n<p>微分方程的解：含有与微分方程阶数相同个数的、任意常数的解</p>\n<h2 id=\"一阶微分方程的解法\"><a href=\"#一阶微分方程的解法\" class=\"headerlink\" title=\"一阶微分方程的解法\"></a>一阶微分方程的解法</h2><h3 id=\"可分离变量（题型方法论）\"><a href=\"#可分离变量（题型方法论）\" class=\"headerlink\" title=\"可分离变量（题型方法论）\"></a>可分离变量（题型方法论）</h3><p>形式：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{dy}{dx} = f(x)g(y)</script><p>怎么做你懂的。</p>\n<p>推论</p>\n<script type=\"math/tex; mode=display\">\n\\frac{dy}{dx} = f(ax+by+c) \\\\\nasume: \\ u = ax+by+c ,\\ \\ \\  then \\ \\ \\ \\frac{du}{dx} = a+b\\frac{dy}{dx} , then  \\ \\ \\frac{du}{dx} = a+bf(u).</script><h3 id=\"一阶齐次\"><a href=\"#一阶齐次\" class=\"headerlink\" title=\"一阶齐次\"></a>一阶齐次</h3><script type=\"math/tex; mode=display\">\n\\frac{dy}{dx} = f(\\frac{y}{x}) \\ \\ 整体代换。</script><h2 id=\"一阶线性\"><a href=\"#一阶线性\" class=\"headerlink\" title=\"一阶线性\"></a>一阶线性</h2><h3 id=\"一阶线性齐次\"><a href=\"#一阶线性齐次\" class=\"headerlink\" title=\"一阶线性齐次\"></a>一阶线性齐次</h3><h3 id=\"一阶线性非齐次\"><a href=\"#一阶线性非齐次\" class=\"headerlink\" title=\"一阶线性非齐次\"></a>一阶线性非齐次</h3><h1 id=\"二阶微分方程\"><a href=\"#二阶微分方程\" class=\"headerlink\" title=\"二阶微分方程\"></a>二阶微分方程</h1><p>二阶常系数线性</p>\n<p>二阶可降阶</p>\n<p>欧拉</p>\n<p>差分（数三）</p>\n<h2 id=\"二阶线性方程解的性质与结构\"><a href=\"#二阶线性方程解的性质与结构\" class=\"headerlink\" title=\"二阶线性方程解的性质与结构\"></a>二阶线性方程解的性质与结构</h2><p> 二阶线性微分方程的形式：</p>\n<script type=\"math/tex; mode=display\">\ny'' +p(x) y'+ q(x)y = f(x)</script><h3 id=\"性质：\"><a href=\"#性质：\" class=\"headerlink\" title=\"性质：\"></a>性质：</h3><ul>\n<li><script type=\"math/tex\">y_1 y_2</script> 为齐次微分方程的解则<script type=\"math/tex\">c_1y_1+c_2y_2</script> 也是解  齐次方程解线性组合仍然为解。</li>\n<li><script type=\"math/tex\">y_1^* y_2^*</script> 为非齐次微分方程的解，则<script type=\"math/tex\">y_1^* - y_2^*</script> 为齐次微分方程的解</li>\n<li><script type=\"math/tex\">y</script> 为齐次方程的解 <script type=\"math/tex\">y^*</script>为非齐次方程的解 <script type=\"math/tex\">y+y*</script> 为非齐次微分方程的解</li>\n</ul>\n<h3 id=\"解的结构\"><a href=\"#解的结构\" class=\"headerlink\" title=\"解的结构\"></a>解的结构</h3><ul>\n<li><p><script type=\"math/tex\">y_1 y_2</script>两个二阶齐次方程的 无关的解，齐次方程的通解为<script type=\"math/tex\">c_1y_1+c_2y_2</script> 为二阶齐次线性微分方程的通解</p>\n</li>\n<li><script type=\"math/tex; mode=display\">y_1 y_2$$两个二阶齐次方程的 无关的解，$$y*$$ 为非齐次方程的特解 ，则非齐次方程的通解为 $$c_1y_1+c_2y_2+y^*</script></li>\n<li><p>叠加原理</p>\n<script type=\"math/tex; mode=display\">\n若 y_1^* 为 y'' +p(x) y'+ q(x)y = f_1(x) 的特解 \\\\\ny_2^* 为 y'' +p(x) y'+ q(x)y = f_2(x) 的特解 \\\\\n则y_1^*+y_2^* 为y'' +p(x) y'+ q(x)y = f_2(x)+f_1(x)的特解</script></li>\n</ul>\n<h2 id=\"二阶常系数\"><a href=\"#二阶常系数\" class=\"headerlink\" title=\"二阶常系数\"></a>二阶常系数</h2><h3 id=\"二阶常系数线性齐次1\"><a href=\"#二阶常系数线性齐次1\" class=\"headerlink\" title=\"二阶常系数线性齐次1\"></a>二阶常系数线性齐次<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></h3><p>解线性方程</p>\n<h3 id=\"二阶常系数线性非齐次\"><a href=\"#二阶常系数线性非齐次\" class=\"headerlink\" title=\"二阶常系数线性非齐次\"></a>二阶常系数线性非齐次</h3><script type=\"math/tex; mode=display\">\ny'' +py'+ qy = f(x)</script><p>二阶常系数线性齐次+特解</p>\n<ul>\n<li><script type=\"math/tex; mode=display\">f(x) = e^{\\lambda x}P_m(x), m是方程P(x)的最高次数</script><p>求特解：设<script type=\"math/tex\">y^*= x^k e^{\\lambda x}Q_m(x),m是上述方程P(x)的最高次数,k是特征方程中根的重数</script> </p>\n</li>\n<li><script type=\"math/tex; mode=display\">f(x) = e^{\\alpha x}[P_m(x)\\cos(\\beta x)+P_n(x)\\sin(\\beta x)],m、n分别是方程P_m(x)、P_n(x)的最高次数</script><p>求特解：</p>\n<script type=\"math/tex; mode=display\">\ny^*= x^k e^{\\alpha x}[Q_l(x)\\cos(\\beta x) + Q_l(x)\\sin(\\beta x)],l = \\max(m,n),k = \n\\begin{cases}\n& 1, \\alpha \\pm \\beta i也是齐次方程的共轭复数  \\\\\n& 0  \\\\\n\\end{cases}</script></li>\n</ul>\n<h1 id=\"n阶微分方程\"><a href=\"#n阶微分方程\" class=\"headerlink\" title=\"n阶微分方程\"></a>n阶微分方程</h1><blockquote id=\"fn_1\">\n<sup>1</sup>. <a href=\"https://zhuanlan.zhihu.com/p/25518193\">常系数二阶线性齐次微分方程的求解 - 知乎 (zhihu.com)</a><a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> ↩</a>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<div class=\"timeline blue\"><div class=\"timeline-item headline\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>2023</p>\n</div></div></div><div class=\"timeline-item\"><div class=\"timeline-item-title\"><div class=\"item-circle\"><p>04-21</p>\n</div></div><div class=\"timeline-item-content\"><ul>\n<li>微分方程初步复习</li>\n</ul>\n</div></div></div>\n<p>[toc]</p>\n<h1 id=\"微分方程\"><a href=\"#微分方程\" class=\"headerlink\" title=\"微分方程\"></a>微分方程</h1><ul>\n<li>可分离</li>\n<li>一节齐次</li>\n<li>一阶线性</li>\n<li>Bernoulli</li>\n<li>全微分</li>\n</ul>\n<h1 id=\"一阶微分方程\"><a href=\"#一阶微分方程\" class=\"headerlink\" title=\"一阶微分方程\"></a>一阶微分方程</h1><h2 id=\"一阶微分方程的概念\"><a href=\"#一阶微分方程的概念\" class=\"headerlink\" title=\"一阶微分方程的概念\"></a>一阶微分方程的概念</h2><p>微分方程：含有未知函数的放曾</p>\n<p>微分方程的阶：未知函数的导数的最高阶数</p>\n<p>微分方程的解：满足微分方程的函数</p>\n<p>微分方程的解：含有与微分方程阶数相同个数的、任意常数的解</p>\n<h2 id=\"一阶微分方程的解法\"><a href=\"#一阶微分方程的解法\" class=\"headerlink\" title=\"一阶微分方程的解法\"></a>一阶微分方程的解法</h2><h3 id=\"可分离变量（题型方法论）\"><a href=\"#可分离变量（题型方法论）\" class=\"headerlink\" title=\"可分离变量（题型方法论）\"></a>可分离变量（题型方法论）</h3><p>形式：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{dy}{dx} = f(x)g(y)</script><p>怎么做你懂的。</p>\n<p>推论</p>\n<script type=\"math/tex; mode=display\">\n\\frac{dy}{dx} = f(ax+by+c) \\\\\nasume: \\ u = ax+by+c ,\\ \\ \\  then \\ \\ \\ \\frac{du}{dx} = a+b\\frac{dy}{dx} , then  \\ \\ \\frac{du}{dx} = a+bf(u).</script><h3 id=\"一阶齐次\"><a href=\"#一阶齐次\" class=\"headerlink\" title=\"一阶齐次\"></a>一阶齐次</h3><script type=\"math/tex; mode=display\">\n\\frac{dy}{dx} = f(\\frac{y}{x}) \\ \\ 整体代换。</script><h2 id=\"一阶线性\"><a href=\"#一阶线性\" class=\"headerlink\" title=\"一阶线性\"></a>一阶线性</h2><h3 id=\"一阶线性齐次\"><a href=\"#一阶线性齐次\" class=\"headerlink\" title=\"一阶线性齐次\"></a>一阶线性齐次</h3><h3 id=\"一阶线性非齐次\"><a href=\"#一阶线性非齐次\" class=\"headerlink\" title=\"一阶线性非齐次\"></a>一阶线性非齐次</h3><h1 id=\"二阶微分方程\"><a href=\"#二阶微分方程\" class=\"headerlink\" title=\"二阶微分方程\"></a>二阶微分方程</h1><p>二阶常系数线性</p>\n<p>二阶可降阶</p>\n<p>欧拉</p>\n<p>差分（数三）</p>\n<h2 id=\"二阶线性方程解的性质与结构\"><a href=\"#二阶线性方程解的性质与结构\" class=\"headerlink\" title=\"二阶线性方程解的性质与结构\"></a>二阶线性方程解的性质与结构</h2><p> 二阶线性微分方程的形式：</p>\n<script type=\"math/tex; mode=display\">\ny'' +p(x) y'+ q(x)y = f(x)</script><h3 id=\"性质：\"><a href=\"#性质：\" class=\"headerlink\" title=\"性质：\"></a>性质：</h3><ul>\n<li><script type=\"math/tex\">y_1 y_2</script> 为齐次微分方程的解则<script type=\"math/tex\">c_1y_1+c_2y_2</script> 也是解  齐次方程解线性组合仍然为解。</li>\n<li><script type=\"math/tex\">y_1^* y_2^*</script> 为非齐次微分方程的解，则<script type=\"math/tex\">y_1^* - y_2^*</script> 为齐次微分方程的解</li>\n<li><script type=\"math/tex\">y</script> 为齐次方程的解 <script type=\"math/tex\">y^*</script>为非齐次方程的解 <script type=\"math/tex\">y+y*</script> 为非齐次微分方程的解</li>\n</ul>\n<h3 id=\"解的结构\"><a href=\"#解的结构\" class=\"headerlink\" title=\"解的结构\"></a>解的结构</h3><ul>\n<li><p><script type=\"math/tex\">y_1 y_2</script>两个二阶齐次方程的 无关的解，齐次方程的通解为<script type=\"math/tex\">c_1y_1+c_2y_2</script> 为二阶齐次线性微分方程的通解</p>\n</li>\n<li><script type=\"math/tex; mode=display\">y_1 y_2$$两个二阶齐次方程的 无关的解，$$y*$$ 为非齐次方程的特解 ，则非齐次方程的通解为 $$c_1y_1+c_2y_2+y^*</script></li>\n<li><p>叠加原理</p>\n<script type=\"math/tex; mode=display\">\n若 y_1^* 为 y'' +p(x) y'+ q(x)y = f_1(x) 的特解 \\\\\ny_2^* 为 y'' +p(x) y'+ q(x)y = f_2(x) 的特解 \\\\\n则y_1^*+y_2^* 为y'' +p(x) y'+ q(x)y = f_2(x)+f_1(x)的特解</script></li>\n</ul>\n<h2 id=\"二阶常系数\"><a href=\"#二阶常系数\" class=\"headerlink\" title=\"二阶常系数\"></a>二阶常系数</h2><h3 id=\"二阶常系数线性齐次1\"><a href=\"#二阶常系数线性齐次1\" class=\"headerlink\" title=\"二阶常系数线性齐次1\"></a>二阶常系数线性齐次<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></h3><p>解线性方程</p>\n<h3 id=\"二阶常系数线性非齐次\"><a href=\"#二阶常系数线性非齐次\" class=\"headerlink\" title=\"二阶常系数线性非齐次\"></a>二阶常系数线性非齐次</h3><script type=\"math/tex; mode=display\">\ny'' +py'+ qy = f(x)</script><p>二阶常系数线性齐次+特解</p>\n<ul>\n<li><script type=\"math/tex; mode=display\">f(x) = e^{\\lambda x}P_m(x), m是方程P(x)的最高次数</script><p>求特解：设<script type=\"math/tex\">y^*= x^k e^{\\lambda x}Q_m(x),m是上述方程P(x)的最高次数,k是特征方程中根的重数</script> </p>\n</li>\n<li><script type=\"math/tex; mode=display\">f(x) = e^{\\alpha x}[P_m(x)\\cos(\\beta x)+P_n(x)\\sin(\\beta x)],m、n分别是方程P_m(x)、P_n(x)的最高次数</script><p>求特解：</p>\n<script type=\"math/tex; mode=display\">\ny^*= x^k e^{\\alpha x}[Q_l(x)\\cos(\\beta x) + Q_l(x)\\sin(\\beta x)],l = \\max(m,n),k = \n\\begin{cases}\n& 1, \\alpha \\pm \\beta i也是齐次方程的共轭复数  \\\\\n& 0  \\\\\n\\end{cases}</script></li>\n</ul>\n<h1 id=\"n阶微分方程\"><a href=\"#n阶微分方程\" class=\"headerlink\" title=\"n阶微分方程\"></a>n阶微分方程</h1><blockquote id=\"fn_1\">\n<sup>1</sup>. <a href=\"https://zhuanlan.zhihu.com/p/25518193\">常系数二阶线性齐次微分方程的求解 - 知乎 (zhihu.com)</a><a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> ↩</a>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clgtgvwm70009bsuob1tw64g7","category_id":"clgtgvwm40004bsuo3upj3gi6","_id":"clgtgvwma000fbsuobwj24blf"},{"post_id":"clgtgvwly0001bsuo9jhab3hj","category_id":"clgtgvwm40004bsuo3upj3gi6","_id":"clgtgvwmc000jbsuo9vs35y0l"},{"post_id":"clgtgvwm10003bsuoecng2fjl","category_id":"clgtgvwm8000bbsuocpeyc8gh","_id":"clgtgvwmd000obsuo3mub5lot"},{"post_id":"clgtgvwm8000absuobps6ct03","category_id":"clgtgvwm8000bbsuocpeyc8gh","_id":"clgtgvwme000sbsuo9t7j9it4"},{"post_id":"clgtgvwmd000qbsuoehp60gqe","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmg000ybsuo0ch8d57d"},{"post_id":"clgtgvwm9000dbsuoc3bee1sh","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmg0012bsuoherf020s"},{"post_id":"clgtgvwme000rbsuocdhpglh1","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmh0016bsuo0bln55ea"},{"post_id":"clgtgvwmf000vbsuoe3i59frc","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmi0019bsuo97ln3vc5"},{"post_id":"clgtgvwma000ebsuo4a9ib89f","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmj001cbsuobbok1tqh"},{"post_id":"clgtgvwmf000xbsuohbepgc1s","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmj001dbsuo1or9dzma"},{"post_id":"clgtgvwmg0011bsuofuy269m4","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmj001fbsuoa9xrcgg0"},{"post_id":"clgtgvwmb000ibsuo4yt3dg66","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmj001hbsuo9gye1ksk"},{"post_id":"clgtgvwmh0015bsuod42lbmlq","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmk001kbsuo8xbu7c9v"},{"post_id":"clgtgvwmi0018bsuoa714fwws","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmk001lbsuobgci4j91"},{"post_id":"clgtgvwmc000lbsuo21we7ffg","category_id":"clgtgvwmh0017bsuodhxae7if","_id":"clgtgvwmk001nbsuoh5ya2x0a"},{"post_id":"clgtgvwmj001bbsuo1m576c6f","category_id":"clgtgvwmd000nbsuohxdedjbh","_id":"clgtgvwmk001pbsuo2ioqea99"}],"PostTag":[{"post_id":"clgtgvwly0001bsuo9jhab3hj","tag_id":"clgtgvwm50005bsuo56fx2j3e","_id":"clgtgvwmc000kbsuoakyh6su1"},{"post_id":"clgtgvwly0001bsuo9jhab3hj","tag_id":"clgtgvwm9000cbsuoehg203bt","_id":"clgtgvwmd000mbsuo7e6h6trk"},{"post_id":"clgtgvwm10003bsuoecng2fjl","tag_id":"clgtgvwma000hbsuo0xgl8fgm","_id":"clgtgvwmf000wbsuo5wwd26rz"},{"post_id":"clgtgvwm10003bsuoecng2fjl","tag_id":"clgtgvwmd000pbsuo3ec73c3d","_id":"clgtgvwmg0010bsuofi526v66"},{"post_id":"clgtgvwm60007bsuoeudl7d9h","tag_id":"clgtgvwmf000ubsuo7ru08u22","_id":"clgtgvwmh0014bsuogjqn6vnv"},{"post_id":"clgtgvwm70009bsuob1tw64g7","tag_id":"clgtgvwmg0013bsuo0gr9aowk","_id":"clgtgvwmj001gbsuobenv5c02"},{"post_id":"clgtgvwm70009bsuob1tw64g7","tag_id":"clgtgvwmi001absuo5s8752ik","_id":"clgtgvwmk001ibsuo9u7wf5z1"},{"post_id":"clgtgvwm8000absuobps6ct03","tag_id":"clgtgvwma000hbsuo0xgl8fgm","_id":"clgtgvwmk001obsuocy7yathn"},{"post_id":"clgtgvwm8000absuobps6ct03","tag_id":"clgtgvwmd000pbsuo3ec73c3d","_id":"clgtgvwmk001qbsuo1ot5enuj"},{"post_id":"clgtgvwm9000dbsuoc3bee1sh","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwml001vbsuo7v4j0nvk"},{"post_id":"clgtgvwm9000dbsuoc3bee1sh","tag_id":"clgtgvwmk001rbsuoc98dgwwp","_id":"clgtgvwml001wbsuodp847gob"},{"post_id":"clgtgvwm9000dbsuoc3bee1sh","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwml001ybsuo8ckoec6f"},{"post_id":"clgtgvwm9000dbsuoc3bee1sh","tag_id":"clgtgvwml001tbsuo1gnz0wy2","_id":"clgtgvwml001zbsuo33u20bkh"},{"post_id":"clgtgvwma000ebsuo4a9ib89f","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwml0022bsuoc9952fvy"},{"post_id":"clgtgvwma000ebsuo4a9ib89f","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwml0023bsuocmasaio0"},{"post_id":"clgtgvwma000ebsuo4a9ib89f","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmm0025bsuoaf3jbv3t"},{"post_id":"clgtgvwmb000ibsuo4yt3dg66","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmm0028bsuo3oerhuui"},{"post_id":"clgtgvwmb000ibsuo4yt3dg66","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmm0029bsuo7z5p8ug6"},{"post_id":"clgtgvwmb000ibsuo4yt3dg66","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmm002bbsuo15se4p9i"},{"post_id":"clgtgvwmc000lbsuo21we7ffg","tag_id":"clgtgvwmm0027bsuo0m93am3u","_id":"clgtgvwmm002cbsuo72ba6pmc"},{"post_id":"clgtgvwmd000qbsuoehp60gqe","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmn002gbsuoenqk54p2"},{"post_id":"clgtgvwmd000qbsuoehp60gqe","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmn002hbsuo5tv49aut"},{"post_id":"clgtgvwmd000qbsuoehp60gqe","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmn002jbsuob8as618q"},{"post_id":"clgtgvwme000rbsuocdhpglh1","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmo002mbsuo3c0d78oc"},{"post_id":"clgtgvwme000rbsuocdhpglh1","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmo002nbsuo4u99ahgv"},{"post_id":"clgtgvwme000rbsuocdhpglh1","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmo002pbsuobx2i9p3h"},{"post_id":"clgtgvwmf000vbsuoe3i59frc","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmo002sbsuo1n6w8pwu"},{"post_id":"clgtgvwmf000vbsuoe3i59frc","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmo002tbsuo0wmee5th"},{"post_id":"clgtgvwmf000vbsuoe3i59frc","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmo002vbsuo4tudc5wy"},{"post_id":"clgtgvwmf000xbsuohbepgc1s","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmp002ybsuoctye9m7s"},{"post_id":"clgtgvwmf000xbsuohbepgc1s","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmp002zbsuo9nvm55ru"},{"post_id":"clgtgvwmf000xbsuohbepgc1s","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmp0031bsuodkvjeber"},{"post_id":"clgtgvwmg0011bsuofuy269m4","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmp0034bsuo9q9n3z6e"},{"post_id":"clgtgvwmg0011bsuofuy269m4","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmp0035bsuo2mgi9b92"},{"post_id":"clgtgvwmg0011bsuofuy269m4","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmp0037bsuohg57cbkp"},{"post_id":"clgtgvwmh0015bsuod42lbmlq","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmq003absuoby9mb3d8"},{"post_id":"clgtgvwmh0015bsuod42lbmlq","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmq003bbsuo2qj032ud"},{"post_id":"clgtgvwmh0015bsuod42lbmlq","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmq003dbsuohs5l3oy8"},{"post_id":"clgtgvwmi0018bsuoa714fwws","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmq003gbsuo3yhq0xof"},{"post_id":"clgtgvwmi0018bsuoa714fwws","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmq003hbsuo14xk4zya"},{"post_id":"clgtgvwmi0018bsuoa714fwws","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmq003jbsuo234d84ce"},{"post_id":"clgtgvwmj001bbsuo1m576c6f","tag_id":"clgtgvwmk001mbsuofuua4uh9","_id":"clgtgvwmr003lbsuocof13zn7"},{"post_id":"clgtgvwmj001bbsuo1m576c6f","tag_id":"clgtgvwmk001sbsuoa9o60j0z","_id":"clgtgvwmr003mbsuoc0af3vvp"},{"post_id":"clgtgvwmj001bbsuo1m576c6f","tag_id":"clgtgvwml0020bsuofz1o6phw","_id":"clgtgvwmr003nbsuo2by5av8p"}],"Tag":[{"name":"CMU15445","_id":"clgtgvwm50005bsuo56fx2j3e"},{"name":"database","_id":"clgtgvwm9000cbsuoehg203bt"},{"name":"algorithm","_id":"clgtgvwma000hbsuo0xgl8fgm"},{"name":"PAT certificate","_id":"clgtgvwmd000pbsuo3ec73c3d"},{"name":"start","_id":"clgtgvwmf000ubsuo7ru08u22"},{"name":"主题美化","_id":"clgtgvwmg0013bsuo0gr9aowk"},{"name":"标签速查","_id":"clgtgvwmi001absuo5s8752ik"},{"name":"考研","_id":"clgtgvwmk001mbsuofuua4uh9"},{"name":"DS","_id":"clgtgvwmk001rbsuoc98dgwwp"},{"name":"二战","_id":"clgtgvwmk001sbsuoa9o60j0z"},{"name":"复习","_id":"clgtgvwml001tbsuo1gnz0wy2"},{"name":"数学","_id":"clgtgvwml0020bsuofz1o6phw"},{"name":"c++","_id":"clgtgvwmm0027bsuo0m93am3u"}]}}